\chapter{式}
\label{expressionchapter}

\newcommand{\syntax}{{\em Syntax: }}
\newcommand{\semantics}{{\em Semantics: }}

形式は{\em プリミティブ}または{\em 派生}に分類されます。
プリミティブ形式は変数や手続き呼び出しなどです。
派生形式は意味論的にプリミティブでなく、代わりにマクロで定義されているものです。
\ref{derivedsection}~節にいくつかの派生形式の適切な構文定義が掲載されています。

{\cf delay}, {\cf delay-force}, および {\cf parameterize} と密接に関連する手続き
{\cf force}, {\cf promise?}, {\cf make-promise}, および {\cf make-parameter}
もこの章で説明しています。

\section{プリミティブ形式}
\label{primitivexps}

\subsection{変数参照}\unsection

\begin{entry}{%
\pproto{\hyper{variable}}{\exprtype}}

変数\index{variable}(\ref{variablesection}~節)から成る式は変数参照です。
変数参照の値はその変数が束縛されている場所に格納されている値です。
束縛されていない\index{unbound}変数を参照することはエラーです。

\begin{scheme}
(define x 28)
x   \ev  28%
\end{scheme}
\end{entry}

\subsection{リテラル式}\unsection
\label{literalsection}

\begin{entry}{%
\proto{quote}{ \hyper{datum}}{\exprtype}
\pproto{\singlequote\hyper{datum}}{\exprtype}
\pproto{\hyper{constant}}{\exprtype}}

{\cf (quote \hyper{datum})}は\hyper{datum}に評価されます。\mainschindex{'}
\hyper{datum}
には任意のSchemeのオブジェクトの外部表現(\ref{externalreps}~節を参照)を指定できます。
Schemeのコードにリテラル定数を含めるためにこの記法を使います。

\begin{scheme}%
(quote a)                     \ev  a
(quote \sharpsign(a b c))     \ev  \#(a b c)
(quote (+ 1 2))               \ev  (+ 1 2)%
\end{scheme}

{\cf (quote \hyper{datum})}は省略して\singlequote\hyper{datum}と書くことが出来ます。
この2種類の記法はあらゆる点で等価です。

\begin{scheme}
'a                   \ev  a
'\#(a b c)           \ev  \#(a b c)
'()                  \ev  ()
'(+ 1 2)             \ev  (+ 1 2)
'(quote a)           \ev  (quote a)
''a                  \ev  (quote a)%
\end{scheme}

数値定数、文字列定数、文字定数、ベクタ定数、バイトベクタ定数、ブーリアン定数は
それ自身に評価されます。
クォートする必要はありません。

\begin{scheme}
'145932    \ev  145932
145932     \ev  145932
'"abc"     \ev  "abc"
"abc"      \ev  "abc"
'\#\space   \ev  \#\space
\#\space   \ev  \#\space
'\#(a 10)  \ev  \#(a 10)
\#(a 10)  \ev  \#(a 10)
'\#u8(64 65)  \ev  \#u8(64 65)
\#u8(64 65)  \ev  \#u8(64 65)
'\schtrue  \ev  \schtrue
\schtrue   \ev  \schtrue%
\end{scheme}

\ref{storagemodel}~節で述べたように、
{\cf set-car!}や{\cf string-set!}のような変更手続きを使用して定数
(すなわちリテラル式の値)の変更を試みるのはエラーです。

\end{entry}

\subsection{手続き呼び出し}\unsection

\begin{entry}{%
\pproto{(\hyper{operator} \hyperi{operand} \dotsfoo)}{\exprtype}}

手続き呼び出しは、呼び出す手続きに対する式に続く渡す引数に対する式を括弧で囲った中に書きます。
演算子と被演算子の式が評価され(順番は規定されていません)、結果の手続きに結果の引数が渡されます。
\mainindex{call}\mainindex{procedure call}
\begin{scheme}%
(+ 3 4)                          \ev  7
((if \schfalse + *) 3 4)         \ev  12%
\end{scheme}

この文章に掲載されている手続きは、標準ライブラリからエクスポートされている変数の値として利用可能です。
例えば、上記の例の加算手続きと乗算手続きは、baseライブラリの変数{\cf +}および{\cf *}の値です。
\lambdaexp{} (\ref{lambda}~節を参照) を評価することで新しい手続きを作ることが出来ます。

手続きは任意の個数の値を返すことが出来ます(\ref{proceduresection}~節の\ide{values}を参照)。
この報告書で定義されている手続きのほとんどは、ひとつの値を返します。
{\cf apply}のような手続きの場合、引数に渡した手続きを呼び出した戻り値がそのまま返されます。
例外はそれぞれ個別の説明に記載されています。


\begin{note} 他のLisp方言と異なり、評価順は規定されていません。
また、演算子の式と被演算子の式は常に同じ評価規則で評価されます。
\end{note}

\begin{note}
評価順は規定されていませんが、
演算子と被演算子の式を並列的に評価する場合は
何らかの逐次的な評価順と一貫性を持たなければならないという制約があります。
評価順は手続き呼び出しのたびに異なっていても構いません。
\end{note}

\begin{note} 多くのLisp方言では、空リスト{\tt ()}は自分自身に評価される正当な式です。
Schemeではエラーです。
\end{note}

\end{entry}


\subsection{手続き}\unsection
\label{lamba}

\begin{entry}{%
\proto{lambda}{ \hyper{formals} \hyper{body}}{\exprtype}}

\syntax
\hyper{formals}は後述の仮引数リストです。
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。

\semantics
\vest \lambdaexp{}は手続きに評価されます。
\lambdaexp{}が評価されたときの有効な環境が手続きの一部として記憶されます。
後ほど手続きがいくつかの実引数を伴って呼び出されると、
\lambdaexp{}が評価されたときの環境が仮引数リストの変数に新しい場所を束縛することによって拡張され、
対応する実引数の値がそれらの場所に格納されます。
(\defining{新しい}場所とは、それまで存在していたどの場所とも異なる場所のことです。)
次に、ラムダ式の本体の式
(定義があれば、{\cf letrec*}形式で表されます --- \ref{letrecstar}~節を参照)
が、その拡張された環境で逐次的に評価されます。
その本体の最後の式の結果が、その手続き呼び出しの結果として返されます。


\begin{scheme}
(lambda (x) (+ x x))      \ev  {\em{}手続き}
((lambda (x) (+ x x)) 4)  \ev  8

(define reverse-subtract
  (lambda (x y) (- y x)))
(reverse-subtract 7 10)         \ev  3

(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                        \ev  10%
\end{scheme}

\hyper{Formals}は以下のいずれかの形です。

\begin{itemize}
\item {\tt(\hyperi{variable} \dotsfoo)}:
手続きは固定の個数の引数を取ります。
手続きが呼ばれたとき、引数は対応する変数に束縛されている新しい場所に格納されます。

\item \hyper{variable}:
手続きは任意の個数の引数を取ります。
手続きが呼ばれたとき、実引数の並びは新しく割り当てられたリストに変換され、
そのリストが\hyper{variable}に束縛されている新しい場所に格納されます。

\item {\tt(\hyperi{variable} \dotsfoo{} \hyper{variable$_{n}$}\ {\bf.}\
\hyper{variable$_{n+1}$})}:
最後の変数の前にスペースで区切られたピリオドがある場合、
手続きは$n$個以上の引数を取ります。
ただし$n$はピリオドの前の仮引数の数です
(最低ひとつ以上なければエラーです)。
最後の変数の束縛に格納される値は
他の仮引数に対して実引数を一致させた後に残った実引数の
新たに割り当てられたリストになります。
\end{itemize}

\hyper{variable}が\hyper{formals}に2回以上現れる場合はエラーです。

\begin{scheme}
((lambda x x) 3 4 5 6)          \ev  (3 4 5 6)
((lambda (x y . z) z)
 3 4 5 6)                       \ev  (5 6)%
\end{scheme}

\end{entry}

\lambdaexp{} を評価した結果作成された手続きはそれぞれ
(概念的に)ある記憶領域の位置に紐付けられます。
それにより手続きに対して\ide{eqv?}および\ide{eq?}を適用することができます
(\ref{equivalencesection}~節を参照)。


\subsection{条件判定}\unsection

\begin{entry}{%
\proto{if}{ \hyper{test} \hyper{consequent} \hyper{alternate}}{\exprtype}
\rproto{if}{ \hyper{test} \hyper{consequent}}{\exprtype}}  %\/ if hyper = italic

\syntax
\hyper{test}、\hyper{consequent}および\hyper{alternate}は式です。

\semantics
{\cf if}式は以下のように評価されます。
まず、\hyper{test}が評価されます。
その結果が真の値\index{true}であった場合
(\ref{booleansection}~節を参照)、
\hyper{consequent}が評価され、その値が返されます。
そうでなければ\hyper{alternate}が評価され、その値が返されます。
\hyper{test}の結果が偽の値であり、\hyper{alternate}が指定されていない場合、
式の結果は規定されていません。

\begin{scheme}
(if (> 3 2) 'yes 'no)           \ev  yes
(if (> 2 3) 'yes 'no)           \ev  no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                    \ev  1%
\end{scheme}

\end{entry}


\subsection{代入}\unsection
\label{assignment}

\begin{entry}{%
\proto{set!}{ \hyper{variable} \hyper{expression}}{\exprtype}}

\semantics
\hyper{expression}が評価され、
その結果の値が\hyper{variable}の束縛されている場所に格納されます。
\hyper{variable}が{\cf set!}式を囲むいずれの有効範囲\index{region}にも
大域的にも束縛されていなければエラーです。
{\cf set!}式の結果は規定されていません。

\begin{scheme}
(define x 2)
(+ x 1)                 \ev  3
(set! x 4)              \ev  \unspecified
(+ x 1)                 \ev  5%
\end{scheme}

\end{entry}

\subsection{インクルード}\unsection
\label{inclusion}
\begin{entry}{%
\proto{include}{ \hyperi{string} \hyperii{string} \dotsfoo}{\exprtype}
\rproto{include-ci}{ \hyperi{string} \hyperii{string} \dotsfoo}{\exprtype}}

\semantics
\ide{include}および\ide{include-ci}は両方とも、
文字列定数として表されたひとつ以上のファイル名を取り、
処理系固有のアルゴリズムを適用して対応するファイルを検索し、
{\cf read}を繰り返し適用したかのように順番にそのファイルの内容を読み込み、
そのファイルから読み込んだ内容を含む{\cf begin}式で、
その{\cf include}式または{\cf include-ci}式を実質的に置換します。
この2つの違いは以下のようなものです。
\ide{include-ci}は各ファイルの先頭に{\cf{}\#!fold-case}指令があるかのように読み込みます。
\ide{include}はそのようなことをしません。

\begin{note}
処理系は、インクルードする側のファイルがあるディレクトリでファイルを検索することが推奨されます。
また、ユーザが他の検索ディレクトリを指定するための方法を用意することが推奨されます。
\end{note}

\end{entry}

\section{派生形式}
\label{derivedexps}

この節の構文は、\ref{macrosection}~節で述べられてるように、衛生的です。
リファレンス目的のため、
この節で説明している構文のほとんどを前の節で説明したプリミティブ構文に変換する構文定義が
\ref{derivedsection}~節に掲載されています。


\subsection{条件判定}\unsection

\begin{entry}{%
\proto{cond}{ \hyperi{clause} \hyperii{clause} \dotsfoo}{\exprtype}
\pproto{else}{\auxiliarytype}
\pproto{=>}{\auxiliarytype}}

\syntax
\hyper{clauses}は、以下のいずれかの形をひとつ以上取ります。
\begin{scheme}
(\hyper{test} \hyperi{expression} \dotsfoo)%
\end{scheme}
ただし\hyper{test}は任意の式です。
\begin{scheme}
(\hyper{test} => \hyper{expression})%
\end{scheme}
最後の\hyper{clause}は、以下のような``else節''にすることも出来ます。
\begin{scheme}
(else \hyperi{expression} \hyperii{expression} \dotsfoo)\rm.%
\end{scheme}
\mainschindex{else}
\mainschindex{=>}

\semantics
{\cf cond}式は以下のように評価されます。
まず、真の値\index{true}(\ref{booleansection}~節を参照)
に評価されるまで、一連の\hyper{clause}の\hyper{test}式が順番に評価されます。
\hyper{test}が真の値に評価されると、
その\hyper{clause}の中の残りの\hyper{expression}が順に評価され、
その\hyper{clause}の中の最後の\hyper{expression}の結果が
{\cf cond}式全体の値として返されます。

選択された\hyper{clause}が\hyper{test}だけで\hyper{expression}を持たない場合、
\hyper{test}の値が結果として返されます。
選択された\hyper{clause}が\ide{=>}代理形を使っている場合、
まず\hyper{expression}が評価されます。
その値が引数をひとつ受け取る手続きでなければエラーです。
\hyper{test}の値に対してその手続きが呼び出され、
その手続きが返した値が{\cf cond}式から返されます。

すべての\hyper{test}が\schfalse{}に評価され、else節がない場合、
{\cf cond}式の結果は規定されていません。
else節があれば、その\hyper{expression}が順に評価され、
その最後の値が返されます。

\begin{scheme}
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))         \ev  greater%

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))            \ev  equal%

(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else \schfalse{}))         \ev  2%
\end{scheme}


\end{entry}


\begin{entry}{%
\proto{case}{ \hyper{key} \hyperi{clause} \hyperii{clause} \dotsfoo}{\exprtype}}

\syntax
\hyper{key}は任意の式を指定できます。
それぞれの\hyper{clause}は以下の形です。
\begin{scheme}
((\hyperi{datum} \dotsfoo) \hyperi{expression} \hyperii{expression} \dotsfoo)\rm,%
\end{scheme}
ただしそれぞれの\hyper{datum}は何らかのオブジェクトの外部表現です。
式の中に同じ\hyper{datum}がふたつ以上ある場合はエラーです。
また、\hyper{clause}は以下の形も指定できます。
\begin{scheme}
((\hyperi{datum} \dotsfoo) => \hyper{expression})%
\end{scheme}
最後の\hyper{clause}は以下のいずれかの形を持つ``else節''に出来ます。
\begin{scheme}
(else \hyperi{expression} \hyperii{expression} \dotsfoo)
(else => \hyper{expression})\rm.%
\end{scheme}
\schindex{else}

\semantics
{\cf case}式は以下のように評価されます。
\hyper{key}が評価され、その結果が各々の\hyper{datum}と比較されます。
\hyper{key}の評価結果が\hyper{datum}と等しい
({\cf eqv?}の意味で; \ref{eqv?}~節を参照)
場合、対応する\hyper{clause}内の式が順番に評価され、
その\hyper{clause}の最後の式の結果が{\cf case}式の結果として返されます。

\hyper{key}の評価結果がどの\hyper{datum}とも異なる場合、
else節があれば、その式が評価され、その最後の結果が{\cf case}式の結果になります。
そうでなければ、{\cf case}式の結果は規定されていません。

選択された\hyper{clause}またはelse節が\ide{=>}代理形を使っている場合、
まず\hyper{expression}が評価されます。
その値がひとつの引数を受け取る手続きでなければエラーです。
\hyper{key}の値に対してその手続きが呼び出され、
その手続きが返した値が{\cf case}式から返されます。

\begin{scheme}
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite))     \ev  composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b))                     \ev  \unspecified
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else => (lambda (x) x)))     \ev  c%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{and}{ \hyperi{test} \dotsfoo}{\exprtype}}

\semantics
\hyper{test}式が左から右に評価され、
いずれかの式が\schfalse{}に評価されると、そこで\schfalse{}が返されます。
残りの式は評価されません。
すべての式が真の値に評価された場合、その最後の式の値が返されます。
式がひとつも無い場合、\schtrue{}を返します。

\begin{scheme}
(and (= 2 2) (> 2 1))           \ev  \schtrue
(and (= 2 2) (< 2 1))           \ev  \schfalse
(and 1 2 'c '(f g))             \ev  (f g)
(and)                           \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{or}{ \hyperi{test} \dotsfoo}{\exprtype}}

\semantics
\hyper{test}式が左から右に評価され、
真の値(\ref{booleansection}~節を参照)
に評価された最初の式の値が返されます
残りの式は評価されません。
すべての式が\schfalse{}に評価された場合、
または式がひとつもない場合、\schfalse{}を返します。

\begin{scheme}
(or (= 2 2) (> 2 1))            \ev  \schtrue
(or (= 2 2) (< 2 1))            \ev  \schtrue
(or \schfalse \schfalse \schfalse) \ev  \schfalse
(or (memq 'b '(a b c))
    (/ 3 0))                    \ev  (b c)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{when}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

\syntax
\hyper{test}は式です。

\semantics
\hyper{test}が評価され、それが真の値に評価された場合、
\hyper{expression}が順番に評価されます。
{\cf when}式の戻り値は規定されていません。

\begin{scheme}
(when (= 1 1.0)
  (display "1")
  (display "2"))  \ev  \unspecified
 \>{\em and prints}  12%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{unless}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

\syntax
\hyper{test}は式です。

\semantics
\hyper{test}が評価され、それが\schfalse{}に評価された場合、
\hyper{expression}が順番に評価されます。
{\cf unless}式の戻り値は規定されていません。

\begin{scheme}
(unless (= 1 1.0)
  (display "1")
  (display "2"))  \ev  \unspecified
 \>{\em and prints nothing}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{cond-expand}{ \hyperi{ce-clause} \hyperii{ce-clause} \dotsfoo}{\exprtype}}

\syntax
\ide{cond-expand}形式は処理系に依存して異なる式に静的に展開される方法を提供します。
\hyper{ce-clause}節は以下の形を取ります。

{\tt(\hyper{feature requirement} \hyper{expression} \dotsfoo)}

最後の節は以下の形の``else節''に出来ます。

{\tt(else \hyper{expression} \dotsfoo)}

\hyper{feature requirement}は以下の形のいずれかひとつを取ります。

\begin{itemize}
\item {\tt\hyper{feature identifier}}
\item {\tt(library \hyper{library name})}
\item {\tt(and \hyper{feature requirement} \dotsfoo)}
\item {\tt(or \hyper{feature requirement} \dotsfoo)}
\item {\tt(not \hyper{feature requirement})}
\end{itemize}

\semantics
各処理系は、インポート可能なライブラリのリストと同様に、
存在する特徴識別子のリストを管理しています。
それぞれの\hyper{feature identifier}および{\tt(library \hyper{library name})}を、
それが処理系の持つリストにある場合は \schtrue、ない場合は \schfalse に置き換え、
その結果の式を{\cf and}, {\cf or}, {\cf not}の通常の解釈の下で
Schemeのブーリアン式として評価することによって、
\hyper{feature requirement}の値が決定されます。

次に、一連の\hyper{ce-clause}の\hyper{feature requirement}が、
\schtrue を返すまで順番に評価されます。
真の値が見つかったら、対応する\hyper{expression}が{\cf begin}に展開されます。
残りの節は無視されます。
どの\hyper{feature requirement}も \schtrue に評価されない場合、
else節があれば、その\hyper{expression}が含まれます。
そうでなければ、\ide{cond-expand}の動作は規定されていません。
{\cf cond}と異なり、{\cf cond-expand}は何の変数の値にも依存しません。

appendix~\ref{stdfeatures}.
用意されている正確な特徴は処理系定義ですが、
移植性のために特徴の中核となる集合が付録~\ref{stdfeatures}掲載されています。

\end{entry}

\subsection{束縛構文}
\label{bindingsection}

束縛構文
{\cf let}, {\cf let*}, {\cf letrec}, {\cf letrec*}, {\cf let-values}, {\cf let*-values}
はAlgol 60のようなブロック構造をSchemeにもたらします。
最初の4つは同じ構文ですが、
それらが確立する変数束縛の有効範囲\index{region}が異なっています。
{\cf let}式では、どの変数が束縛されるよりも前に初期値が計算されます。
{\cf let*}式では、束縛と評価が逐次的に行われます。
{\cf letrec}式および{\cf letrec*}式では、
初期値が計算されている間もすべての束縛が有効であり、
これによって相互再帰を定義することが出来ます。
{\cf let-values}構文および{\cf let*-values}構文は
それぞれ{\cf let}および{\cf let*}に似たものですが、
多値の式を処理できるよう設計されており、
その戻り値をそれぞれ異なる識別子に束縛できます。

\begin{entry}{%
\proto{let}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
それぞれの\hyper{init}は式で、
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。
束縛される変数のリストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\semantics
\hyper{init}が現在の環境で(何らかの規定されていない順番で)評価され、
その結果を格納した新しい場所に\hyper{variable}が束縛され、
その拡張された環境で\hyper{body}が評価され、
\hyper{body}の最後の式の値が返されます。
各\hyper{variable}の束縛は\hyper{body}をその有効範囲として持ちます。\index{region}

\begin{scheme}
(let ((x 2) (y 3))
  (* x y))                      \ev  6

(let ((x 2) (y 3))
  (let ((x 7)
        (z (+ x y)))
    (* z x)))                   \ev  35%
\end{scheme}

\ref{namedlet}節の``名前付き{\cf let}''も参照してください。

\end{entry}


\begin{entry}{%
\proto{let*}{ \hyper{bindings} \hyper{body}}{\exprtype}}\nobreak

\nobreak
\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。

\semantics
{\cf let*}束縛構文は{\cf let}と同様ですが、束縛が左から右に逐次的に行われます。
{\cf(\hyper{variable} \hyper{init})} によって示される束縛の有効範囲\index{region}は
{\cf let*}式のその束縛より右側の部分になります。
そのため、ふたつめの束縛は最初の束縛が見える環境で行われ、以下同様です。
\hyper{variable}はそれぞれ異なっている必要はありません。

\begin{scheme}
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))             \ev  70%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{letrec}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。
束縛される変数のリストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\semantics
\hyper{variable}が規定されていない値を格納した新しい場所に束縛され、
その結果の環境で\hyper{init}が(何らかの規定されていない順番で)評価され、
\hyper{init}の結果がそれぞれ対応する\hyper{varible}に代入され、
その結果の環境で\hyper{body}が評価され、
\hyper{body}の最後の式の値が返されます。
各\hyper{variable}の束縛は{\cf letrec}式全体をその有効範囲として持ちます。\index{region}
それにより相互再帰手続きを定義することが可能です。

\begin{scheme}
(letrec ((even?
          (lambda (n)
            (if (zero? n)
                \schtrue
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                \schfalse
                (even? (- n 1))))))
  (even? 88))
		\ev  \schtrue%
\end{scheme}

{\cf letrec}には非常に重要な制限がひとつあります。
各\hyper{init}は、どの\hyper{variable}にも代入も参照もせずに評価できなければなりません。
さもなければエラーです。
この制限は必要なものです。
{\cf lambda}式が\hyper{variable}を\hyper{init}の値に束縛する
手続き呼び出しによって{\cf letrec}が定義されているためです。
{\cf letrec}のほとんどの用途では、
\hyper{init}は\lambdaexp{}であり、
この制限は自動的に満たされます。

\end{entry}


\begin{entry}{%
\proto{letrec*}{ \hyper{bindings} \hyper{body}}{\exprtype}}
\label{letrecstar}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
\hyper{body}\index{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。
束縛される変数のリストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\semantics
\hyper{variable}が新しい場所に束縛され、
左から右の順番で\hyper{init}が評価されその結果がそれぞれ対応する\hyper{variable}に代入され、
その結果の環境で\hyper{body}が評価され、
\hyper{body}の最後の式が返されます。
左から右の評価代入の順番にもかかわらず、
各\hyper{variable}の束縛は{\cf letrec*}式全体をその有効範囲\index{region}として持ちます。
それにより相互再帰手続きを定義することが可能です。

各\hyper{init}は対応する\hyper{variable}の値、およびそれより右側の
どの\hyper{bindings}の\hyper{variable}にも参照も代入もせず評価できなければなりません。
さもなければエラーです。
もうひとつ制限があります。
\hyper{init}の継続を2回以上呼び出すことはエラーです。

\begin{scheme}
(letrec* ((p
           (lambda (x)
             (+ 1 (q (- x 1)))))
          (q
           (lambda (y)
             (if (zero? y)
                 0
                 (+ 1 (p (- y 1))))))
          (x (p 5))
          (y x))
  y)
                \ev  5%
\end{scheme}

\begin{entry}{%
\proto{let-values}{ \hyper{mv binding spec} \hyper{body}}{\exprtype}}

\syntax
\hyper{mv binding spec}は以下の形を取ります。
\begin{scheme}
((\hyperi{formals} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}

それぞれの\hyper{init}は式で、
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}も参照してください。
\hyper{formals}の集合内に同じ変数がふたつ以上現れた場合はエラーです。

\semantics
\hyper{init}が現在の環境で(何らかの規定されていない順番で)
{\cf call-with-values}によって呼び出されたかのように評価され、
\hyper{init}の戻り値を格納した新しい場所に\hyper{formals}内の変数が束縛されます。
ただし\hyper{formals}は、
{\cf lambda}式が手続き呼び出しの際に引数を一致させるのと同じ方法で、
その戻り値を一致させます。
それから、その拡張された環境で\hyper{body}が評価され、
\hyper{body}の最後の式の値が返されます。
それぞれの\hyper{variable}の束縛は\hyper{body}をその有効範囲とします。\index{region}

\hyper{init}の返した値の数が対応する\hyper{formals}に一致しない場合はエラーです。

\begin{scheme}
(let-values (((root rem) (exact-integer-sqrt 32)))
  (* root rem))                \ev  35%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{let*-values}{ \hyper{mv binding spec} \hyper{body}}{\exprtype}}\nobreak

\nobreak
\syntax
\hyper{mv binding spec}は以下の形を取ります。
\begin{scheme}
((\hyper{formals} \hyper{init}) \dotsfoo)\rm,%
\end{scheme}
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}も参照してください。
それぞれの\hyper{formals}において、同じ変数がふたつ以上現れた場合はエラーです。

\semantics
{\cf let*-values}構文は{\cf let-values}に似ています。
\hyper{init}が評価され、左から右に逐次的に束縛が作成されます。
それぞれの\hyper{formals}の束縛の有効範囲は
\hyper{body}と同様にその\hyper{init}の右側も含まれます。
そのため、ふたつめの\hyper{init}はひとつめの束縛の集合が見えて初期化された環境で評価され、
以下同様です。

\begin{scheme}
(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let*-values (((a b) (values x y))
                ((x y) (values a b)))
    (list a b x y)))     \ev (x y x y)%
\end{scheme}

\end{entry}

\end{entry}


\subsection{逐次実行}\unsection
\label{sequencing}

Schemeの逐次実行構文は両方とも{\cf begin}という名前ですが、
それぞれ微妙に異なった形と用途があります。

\begin{entry}{%
\proto{begin}{ \hyper{expression or definition} \dotsfoo}{\exprtype}}

この形の{\cf begin}は\hyper{body}の部分、\hyper{program}の最上位、REPL、
またはこの形の{\cf begin}に直接ネストしている場合に使うことが出来ます。
囲んでいる{\cf begin}構文が存在しない場合とまったく同様に、
内部の式および定義が評価されます。

\begin{rationale}
この形は一般に、
複数の定義を生成し、それらを展開先の文脈に繋ぎ合わせる必要のある
マクロの出力で使われます(\ref{macrosection}~節を参照)。
\end{rationale}

\end{entry}

\begin{entry}{%
\rproto{begin}{ \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

この形の{\cf begin}は普通の式として使うことができます。
\hyper{expression}は左から右に逐次的に評価され、
最後の\hyper{expression}の値が返されます。
この形式は代入や入出力のような副作用を逐次実行するために使われます。

\begin{scheme}
(define x 0)

(and (= x 0)
     (begin (set! x 5)
            (+ x 1)))              \ev  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))      \ev  \unspecified
 \>{\em and prints}  4 plus 1 equals 5%
\end{scheme}

\end{entry}

ちなみに、ライブラリ宣言として使われるみっつめの形式の{\cf begin}があります。
\ref{librarydeclarations}~節を参照してください。

\subsection{Iteration}%\unsection

\noindent%
\pproto{(do ((\hyperi{variable} \hyperi{init} \hyperi{step})}{\exprtype}
\mainschindex{do}{\tt\obeyspaces%
     \dotsfoo)\\
    (\hyper{test} \hyper{expression} \dotsfoo)\\
  \hyper{command} \dotsfoo)}

\syntax
All of \hyper{init}, \hyper{step}, \hyper{test}, and \hyper{command}
are expressions.

\semantics
A {\cf do} expression is an iteration construct.  It specifies a set of variables to
be bound, how they are to be initialized at the start, and how they are
to be updated on each iteration.  When a termination condition is met,
the loop exits after evaluating the \hyper{expression}s.

A {\cf do} expression is evaluated as follows:
The \hyper{init} expressions are evaluated (in some unspecified order),
the \hyper{variable}s are bound to fresh locations, the results of the
\hyper{init} expressions are stored in the bindings of the
\hyper{variable}s, and then the iteration phase begins.

\vest Each iteration begins by evaluating \hyper{test}; if the result is
false (see section~\ref{booleansection}), then the \hyper{command}
expressions are evaluated in order for effect, the \hyper{step}
expressions are evaluated in some unspecified order, the
\hyper{variable}s are bound to fresh locations, the results of the
\hyper{step}s are stored in the bindings of the
\hyper{variable}s, and the next iteration begins.

\vest If \hyper{test} evaluates to a true value, then the
\hyper{expression}s are evaluated from left to right and the values of
the last \hyper{expression} are returned.  If no \hyper{expression}s
are present, then the value of the {\cf do} expression is unspecified.

\vest The region\index{region} of the binding of a \hyper{variable}
consists of the entire {\cf do} expression except for the \hyper{init}s.
It is an error for a \hyper{variable} to appear more than once in the
list of {\cf do} variables.

\vest A \hyper{step} can be omitted, in which case the effect is the
same as if {\cf(\hyper{variable} \hyper{init} \hyper{variable})} had
been written instead of {\cf(\hyper{variable} \hyper{init})}.

\begin{scheme}
(do ((vec (make-vector 5))
     (i 0 (+ i 1)))
    ((= i 5) vec)
  (vector-set! vec i i))          \ev  \#(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
  (do ((x x (cdr x))
       (sum 0 (+ sum (car x))))
      ((null? x) sum)))             \ev  25%
\end{scheme}



\begin{entry}{%
\rproto{let}{ \hyper{variable} \hyper{bindings} \hyper{body}}{\exprtype}}

\label{namedlet}
\semantics
``Named {\cf let}'' is a variant on the syntax of \ide{let} which provides
a more general looping construct than {\cf do} and can also be used to express
recursion.
It has the same syntax and semantics as ordinary {\cf let}
except that \hyper{variable} is bound within \hyper{body} to a procedure
whose formal arguments are the bound variables and whose body is
\hyper{body}.  Thus the execution of \hyper{body} can be repeated by
invoking the procedure named by \hyper{variable}.

%                                              |  <-- right margin
\begin{scheme}
(let loop ((numbers '(3 -2 1 6 -5))
           (nonneg '())
           (neg '()))
  (cond ((null? numbers) (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((< (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg))))) %
  \lev  ((6 1 3) (-5 -2))%
\end{scheme}

\end{entry}


\subsection{Delayed evaluation}\unsection

\begin{entry}{%
\proto{delay}{ \hyper{expression}}{lazy library syntax}}

\todo{Fix.}

\semantics
The {\cf delay} construct is used together with the procedure \ide{force} to
implement \defining{lazy evaluation} or \defining{call by need}.
{\tt(delay~\hyper{expression})} returns an object called a
\defining{promise} which at some point in the future can be asked (by
the {\cf force} procedure) to evaluate
\hyper{expression}, and deliver the resulting value.
\todo{consider removing unspecified effect}
The effect of \hyper{expression} returning multiple values
is unspecified.

\end{entry}

\begin{entry}{%
\proto{delay-force}{ \hyper{expression}}{lazy library syntax}}

\todo{Fix.}

\semantics
The expression {\cf (delay-force \var{expression})} is conceptually similar to 
{\cf (delay (force \var{expression}))},
with the difference that forcing the result
of {\cf delay-force} will in effect result in a tail call to 
{\cf (force \var{expression})},
while forcing the result of
{\cf (delay (force \var{expression}))}
might not.  Thus
iterative lazy algorithms that might result in a long series of chains of
{\cf delay} and {\cf force}
can be rewritten using {\cf delay-force} to prevent consuming
unbounded space during evaluation.

\end{entry}

\begin{entry}{%
\proto{force}{ promise}{lazy library procedure}}

The {\cf force} procedure forces the value of a \var{promise} created
by \ide{delay}, \ide{delay-force}, or \ide{make-promise}.\index{promise}
If no value has been computed for the promise, then a value is
computed and returned.  The value of the promise must be cached (or
``memoized'') so that if it is forced a second time, the previously
computed value is returned.
Consequently, a delayed expression is evaluated using the parameter
values and exception handler of the call to {\cf force} which first
requested its value.
If \var{promise} is not a promise, it may be returned unchanged.

\begin{scheme}
(force (delay (+ 1 2)))   \ev  3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))  
                               \ev  (3 3)

(define integers
  (letrec ((next
            (lambda (n)
              (delay (cons n (next (+ n 1)))))))
    (next 0)))
(define head
  (lambda (stream) (car (force stream))))
(define tail
  (lambda (stream) (cdr (force stream))))

(head (tail (tail integers)))  
                               \ev  2%
\end{scheme}

The following example is a mechanical transformation of a lazy
stream-filtering algorithm into Scheme.  Each call to a constructor is
wrapped in {\cf delay}, and each argument passed to a deconstructor is
wrapped in {\cf force}.  The use of {\cf (delay-force ...)} instead of {\cf
(delay (force ...))} around the body of the procedure ensures that an
ever-growing sequence of pending promises does not 
exhaust available storage,
because {\cf force} will in effect force such sequences iteratively.

\begin{scheme}
(define (stream-filter p? s)
  (delay-force
   (if (null? (force s)) 
       (delay '())
       (let ((h (car (force s)))
             (t (cdr (force s))))
         (if (p? h)
             (delay (cons h (stream-filter p? t)))
             (stream-filter p? t))))))

(head (tail (tail (stream-filter odd? integers))))
                               \ev 5%
\end{scheme}

The following examples are not intended to illustrate good programming
style, as {\cf delay}, {\cf force}, and {\cf delay-force} are mainly intended
for programs written in the functional style.
However, they do illustrate the property that only one value is
computed for a promise, no matter how many times it is forced.

\begin{scheme}
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                     \ev  {\it{}a promise}
(force p)             \ev  6
p                     \ev  {\it{}a promise, still}
(begin (set! x 10)
       (force p))     \ev  6%
\end{scheme}

Various extensions to this semantics of {\cf delay}, {\cf force} and
{\cf delay-force} are supported in some implementations:

\begin{itemize}
\item Calling {\cf force} on an object that is not a promise may simply
return the object.

\item It may be the case that there is no means by which a promise can be
operationally distinguished from its forced value.  That is, expressions
like the following may evaluate to either \schtrue{} or to \schfalse{},
depending on the implementation:

\begin{scheme}
(eqv? (delay 1) 1)          \ev  \unspecified
(pair? (delay (cons 1 2)))  \ev  \unspecified%
\end{scheme}

\item Implementations may implement ``implicit forcing,'' where
the value of a promise is forced by procedures
that operate only on arguments of a certain type, like {\cf cdr}
and {\cf *}.  However, procedures that operate uniformly on their
arguments, like {\cf list}, must not force them.

\begin{scheme}
(+ (delay (* 3 7)) 13)  \ev  \unspecified
(car
  (list (delay (* 3 7)) 13))    \ev {\it{}a promise}%
\end{scheme}
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{promise?} { \var{obj}}{lazy library procedure}}

The {\cf promise?} procedure returns 
\schtrue{} if its argument is a promise, and \schfalse{} otherwise.  Note
that promises are not necessarily disjoint from other Scheme types such
as procedures.

\end{entry}

\begin{entry}{%
\proto{make-promise} { \var{obj}}{lazy library procedure}}

The {\cf make-promise} procedure returns a promise which, when forced, will return
\var{obj}.  It is similar to {\cf delay}, but does not delay
its argument: it is a procedure rather than syntax.
If \var{obj} is already a promise, it is returned.

\end{entry}

\subsection{Dynamic bindings}\unsection

The \defining{dynamic extent} of a procedure call is the time between
when it is initiated and when it returns.  In Scheme, {\cf
  call-with-current-continuation} (section~\ref{continuations}) allows
reentering a dynamic extent after its procedure call has returned.
Thus, the dynamic extent of a call might not be a single, continuous time
period.

This sections introduces \defining{parameter objects}, which can be
bound to new values for the duration of a dynamic extent.  The set of
all parameter bindings at a given time is called the \defining{dynamic
  environment}.

\begin{entry}{%
\proto{make-parameter}{ init}{procedure}
\rproto{make-parameter}{ init converter}{procedure}}

Returns a newly allocated parameter object,
which is a procedure that accepts zero arguments and
returns the value associated with the parameter object.
Initially, this value is the value of
{\cf (\var{converter} \var{init})}, or of \var{init}
if the conversion procedure \var{converter} is not specified.
The associated value can be temporarily changed
using {\cf parameterize}, which is described below.

The effect of passing arguments to a parameter object is
implementation-dependent.
\end{entry}

\begin{entry}{%
\pproto{(parameterize ((\hyperi{param} \hyperi{value}) \dotsfoo)}{syntax}
{\tt\obeyspaces%
\hspace*{1em}\hyper{body})}}
\mainschindex{parameterize}

\syntax
Both \hyperi{param} and \hyperi{value} are expressions.

\domain{It is an error if the value of any \hyper{param} expression is not a parameter object.}
\semantics
A {\cf parameterize} expression is used to change the values returned by
specified parameter objects during the evaluation of the body.

The \hyper{param} and \hyper{value} expressions
are evaluated in an unspecified order.  The \hyper{body} is
evaluated in a dynamic environment in which calls to the
parameters return the results of passing the corresponding values
to the conversion procedure specified when the parameters were created.
Then the previous values of the parameters are restored without passing
them to the conversion procedure.
The results of the last
expression in the \hyper{body} are returned as the results of the entire
{\cf parameterize} expression.

\begin{note}
If the conversion procedure is not idempotent, the results of
{\cf (parameterize ((x (x))) ...)},
which appears to bind the parameter \var{x} to its current value,
might not be what the user expects.
\end{note}

If an implementation supports multiple threads of execution, then
{\cf parameterize} must not change the associated values of any parameters
in any thread other than the current thread and threads created
inside \hyper{body}.

Parameter objects can be used to specify configurable settings for a
computation without the need to pass the value to every
procedure in the call chain explicitly.

\begin{scheme}
(define radix
  (make-parameter
   10
   (lambda (x)
     (if (and (exact-integer? x) (<= 2 x 16))
         x
         (error "invalid radix")))))

(define (f n) (number->string n (radix)))

(f 12)                                       \ev "12"
(parameterize ((radix 2))
  (f 12))                                    \ev "1100"
(f 12)                                       \ev "12"

(radix 16)                                   \ev \unspecified

(parameterize ((radix 0))
  (f 12))                                    \ev \scherror%
\end{scheme}
\end{entry}


\subsection{Exception handling}\unsection

\begin{entry}{%
\pproto{(guard (\hyper{variable}}{\exprtype}
{\tt\obeyspaces%
\hspace*{4em}\hyperi{cond clause} \hyperii{cond clause} \dotsfoo)\\
\hspace*{2em}\hyper{body})}\\
}
\mainschindex{guard}

\syntax
Each \hyper{cond clause} is as in the specification of {\cf cond}.

\semantics
The \hyper{body} is evaluated with an exception
handler that binds the raised object (see \ide{raise} in section~\ref{exceptionsection})
to \hyper{variable} and, within the scope of
that binding, evaluates the clauses as if they were the clauses of a
{\cf cond} expression. That implicit {\cf cond} expression is evaluated with the
continuation and dynamic environment of the {\cf guard} expression. If every
\hyper{cond clause}'s \hyper{test} evaluates to \schfalse{} and there
is no else clause, then
{\cf raise-continuable} is invoked on the raised object within the dynamic
environment of the original call to {\cf raise}
or {\cf raise-continuable}, except that the current
exception handler is that of the {\cf guard} expression.


See section~\ref{exceptionsection} for a more complete discussion of
exceptions.

\begin{scheme}
(guard (condition
         ((assq 'a condition) => cdr)
         ((assq 'b condition)))
  (raise (list (cons 'a 42))))
\ev 42

(guard (condition
         ((assq 'a condition) => cdr)
         ((assq 'b condition)))
  (raise (list (cons 'b 23))))
\ev (b . 23)%
\end{scheme}
\end{entry}


\subsection{Quasiquotation}\unsection
\label{quasiquotesection}

\begin{entry}{%
\proto{quasiquote}{ \hyper{qq template}}{\exprtype} \nopagebreak
\pproto{\backquote\hyper{qq template}}{\exprtype}
\pproto{unquote}{\auxiliarytype}
\pproto{\comma}{\auxiliarytype}
\pproto{unquote-splicing}{\auxiliarytype}
\pproto{\commaatsign}{\auxiliarytype}}

``Quasiquote''\index{backquote} expressions are useful
for constructing a list or vector structure when some but not all of the
desired structure is known in advance.  If no
commas\index{comma} appear within the \hyper{qq template}, the result of
evaluating
\backquote\hyper{qq template} is equivalent to the result of evaluating
\singlequote\hyper{qq template}.  If a comma\mainschindex{,} appears within the
\hyper{qq template}, however, the expression following the comma is
evaluated (``unquoted'') and its result is inserted into the structure
instead of the comma and the expression.  If a comma appears followed
without intervening whitespace by a commercial at-sign (\atsign),\mainschindex{,@} then it is an error if the following
expression does not evaluate to a list; the opening and closing parentheses
of the list are then ``stripped away'' and the elements of the list are
inserted in place of the comma at-sign expression sequence.  A comma
at-sign normally appears only within a list or vector \hyper{qq template}.

\begin{note}
In order to unquote an identifier beginning with {\cf @}, it is necessary
to use either an explicit {\cf unquote} or to put whitespace after the comma,
to avoid colliding with the comma at-sign sequence.
\end{note}

\begin{scheme}
`(list ,(+ 1 2) 4)  \ev  (list 3 4)
(let ((name 'a)) `(list ,name ',name)) %
          \lev  (list a (quote a))
`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b) %
          \lev  (a 3 4 5 6 b)
`(({\cf foo} ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons))) %
          \lev  ((foo 7) . cons)
`\#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8) %
          \lev  \#(10 5 2 4 3 8)
(let ((foo '(foo bar)) (@baz 'baz))
  `(list ,@foo , @baz))%
          \lev  (list foo bar baz)%
\end{scheme}

Quasiquote expressions can be nested.  Substitutions are made only for
unquoted components appearing at the same nesting level
as the outermost quasiquote.  The nesting level increases by one inside
each successive quasiquotation, and decreases by one inside each
unquotation.

\begin{scheme}
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f) %
          \lev  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e)) %
          \lev  (a `(b ,x ,'y d) e)%
\end{scheme}

A quasiquote expression may return either newly allocated, mutable objects or
literal structure for any structure that is constructed at run time
during the evaluation of the expression. Portions that do not need to
be rebuilt are always literal. Thus,

\begin{scheme}
(let ((a 3)) `((1 2) ,a ,4 ,'five 6))%
\end{scheme}

may be treated as equivalent to either of the following expressions:

\begin{scheme}
`((1 2) 3 4 five 6)

(let ((a 3))
  (cons '(1 2)
        (cons a (cons 4 (cons 'five '(6))))))%
\end{scheme}

However, it is not equivalent to this expression:

\begin{scheme}
(let ((a 3)) (list (list 1 2) a 4 'five 6))%
\end{scheme}

The two notations
 \backquote\hyper{qq template} and {\tt (quasiquote \hyper{qq template})}
 are identical in all respects.
 {\cf,\hyper{expression}} is identical to {\cf (unquote \hyper{expression})},
 and
 {\cf,@\hyper{expression}} is identical to {\cf (unquote-splicing \hyper{expression})}.
The \ide{write} procedure may output either format.
\mainschindex{`}

\begin{scheme}
(quasiquote (list (unquote (+ 1 2)) 4)) %
          \lev  (list 3 4)
'(quasiquote (list (unquote (+ 1 2)) 4)) %
          \lev  `(list ,(+ 1 2) 4)
     {\em{}i.e.,} (quasiquote (list (unquote (+ 1 2)) 4))%
\end{scheme}


It is an error if any of the identifiers {\cf quasiquote}, {\cf unquote},
or {\cf unquote-splicing} appear in positions within a \hyper{qq template}
otherwise than as described above.

\end{entry}

\subsection{Case-lambda}\unsection
\label{caselambdasection}
\begin{entry}{%
\proto{case-lambda}{ \hyper{clause} \dotsfoo}{case-lambda library syntax}}

\syntax
Each \hyper{clause} is of the form
(\hyper{formals} \hyper{body}),
where \hyper{formals} and \hyper{body} have the same syntax
as in a \lambdaexp.

\semantics
A {\cf case-lambda} expression evaluates to a procedure that accepts
a variable number of arguments and is lexically scoped in the same
manner as a procedure resulting from a \lambdaexp. When the procedure
is called, the first \hyper{clause} for which the arguments agree
with \hyper{formals} is selected, where agreement is specified as for
the \hyper{formals} of a \lambdaexp. The variables of \hyper{formals} are
bound to fresh locations, the values of the arguments are stored in those
locations, the \hyper{body} is evaluated in the extended environment,
and the results of \hyper{body} are returned as the results of the
procedure call.

It is an error for the arguments not to agree with
the \hyper{formals} of any \hyper{clause}.

\begin{scheme}
(define range
  (case-lambda
   ((e) (range 0 e))
   ((b e) (do ((r '() (cons e r))
               (e (- e 1) (- e 1)))
              ((< e b) r)))))

(range 3)    \ev (0 1 2)
(range 3 5)  \ev (3 4)%
\end{scheme}

\end{entry}

\section{Macros}
\label{macrosection}

Scheme programs can define and use new derived expression types,
 called {\em macros}.\mainindex{macro}
Program-defined expression types have the syntax
\begin{scheme}
(\hyper{keyword} {\hyper{datum}} ...)%
\end{scheme}%
where \hyper{keyword} is an identifier that uniquely determines the
expression type.  This identifier is called the {\em syntactic
keyword}\index{syntactic keyword}, or simply {\em
keyword}\index{keyword}, of the macro\index{macro keyword}.  The
number of the \hyper{datum}s, and their syntax, depends on the
expression type.

Each instance of a macro is called a {\em use}\index{macro use}
of the macro.
The set of rules that specifies
how a use of a macro is transcribed into a more primitive expression
is called the {\em transformer}\index{macro transformer}
of the macro.

The macro definition facility consists of two parts:

\begin{itemize}
\item A set of expressions used to establish that certain identifiers
are macro keywords, associate them with macro transformers, and control
the scope within which a macro is defined, and

\item a pattern language for specifying macro transformers.
\end{itemize}

The syntactic keyword of a macro can shadow variable bindings, and local
variable bindings can shadow syntactic bindings.  \index{keyword}  
Two mechanisms are provided to prevent unintended conflicts:

\begin{itemize}

\item If a macro transformer inserts a binding for an identifier
(variable or keyword), the identifier will in effect be renamed
throughout its scope to avoid conflicts with other identifiers.
Note that a global variable definition may or may not introduce a binding;
see section~\ref{defines}.

\item If a macro transformer inserts a free reference to an
identifier, the reference refers to the binding that was visible
where the transformer was specified, regardless of any local
bindings that surround the use of the macro.

\end{itemize}

In consequence, all macros
defined using the pattern language  are ``hygienic'' and ``referentially
transparent'' and thus preserve Scheme's lexical scoping.~\cite{Kohlbecker86,
hygienic,Bawden88,macrosthatwork,syntacticabstraction}
\mainindex{hygienic}\mainindex{referentially transparent}

Implementations may provide macro facilities of other types.

\subsection{Binding constructs for syntactic keywords}
\label{bindsyntax}

The {\cf let-syntax} and {\cf letrec-syntax} binding constructs are
analogous to {\cf let} and {\cf letrec}, but they bind
syntactic keywords to macro transformers instead of binding variables
to locations that contain values.  Syntactic keywords can also be
bound globally or locally with {\cf define-syntax};
see section~\ref{define-syntax}.

\begin{entry}{%
\proto{let-syntax}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{Bindings} has the form
\begin{scheme}
((\hyper{keyword} \hyper{transformer spec}) \dotsfoo)%
\end{scheme}
Each \hyper{keyword} is an identifier,
each \hyper{transformer spec} is an instance of {\cf syntax-rules}, and
\hyper{body} is a sequence of one or more definitions followed
by one or more expressions.  It is an error
for a \hyper{keyword} to appear more than once in the list of keywords
being bound.

\semantics
The \hyper{body} is expanded in the syntactic environment
obtained by extending the syntactic environment of the
{\cf let-syntax} expression with macros whose keywords are
the \hyper{keyword}s, bound to the specified transformers.
Each binding of a \hyper{keyword} has \hyper{body} as its region.

\begin{scheme}
(let-syntax ((given-that (syntax-rules ()
                     ((given-that test stmt1 stmt2 ...)
                      (if test
                          (begin stmt1
                                 stmt2 ...))))))
  (let ((if \schtrue))
    (given-that if (set! if 'now))
    if))                           \ev  now

(let ((x 'outer))
  (let-syntax ((m (syntax-rules () ((m) x))))
    (let ((x 'inner))
      (m))))                       \ev  outer%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{letrec-syntax}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
Same as for {\cf let-syntax}.

\semantics
 The \hyper{body} is expanded in the syntactic environment obtained by
extending the syntactic environment of the {\cf letrec-syntax}
expression with macros whose keywords are the
\hyper{keyword}s, bound to the specified transformers.
Each binding of a \hyper{keyword} has the \hyper{transformer spec}s
as well as the \hyper{body} within its region,
so the transformers can
transcribe expressions into uses of the macros
introduced by the {\cf letrec-syntax} expression.

\begin{scheme}
(letrec-syntax
    ((my-or (syntax-rules ()
              ((my-or) \schfalse)
              ((my-or e) e)
              ((my-or e1 e2 ...)
               (let ((temp e1))
                 (if temp
                     temp
                     (my-or e2 ...)))))))
  (let ((x \schfalse)
        (y 7)
        (temp 8)
        (let odd?)
        (if even?))
    (my-or x
           (let temp)
           (if y)
           y)))        \ev  7%
\end{scheme}

\end{entry}

\subsection{Pattern language}
\label{patternlanguage}

A \hyper{transformer spec} has one of the following forms:

\begin{entry}{%
\pproto{(syntax-rules (\hyper{literal} \dotsfoo)}{\exprtype}
{\tt\obeyspaces%
\hspace*{1em}\hyper{syntax rule} \dotsfoo)\\
}
\pproto{(syntax-rules \hyper{ellipsis} (\hyper{literal} \dotsfoo)}{\exprtype}
{\tt\obeyspaces%
\hspace*{1em}\hyper{syntax rule} \dotsfoo)}\\
\pproto{\_}{\auxiliarytype}
\pproto{\dotsfoo}{\auxiliarytype}}
\mainschindex{_}

\syntax
It is an error if any of the \hyper{literal}s, or the \hyper{ellipsis} in the second form,
is not an identifier.
It is also an error if
\hyper{syntax rule} is not of the form
\begin{scheme}
(\hyper{pattern} \hyper{template})%
\end{scheme}
The \hyper{pattern} in a \hyper{syntax rule} is a list \hyper{pattern}
whose first element is an identifier.

A \hyper{pattern} is either an identifier, a constant, or one of the
following
\begin{scheme}
(\hyper{pattern} \ldots)
(\hyper{pattern} \hyper{pattern} \ldots . \hyper{pattern})
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots
  . \hyper{pattern})
\#(\hyper{pattern} \ldots)
\#(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)%
\end{scheme}
and a \hyper{template} is either an identifier, a constant, or one of the following
\begin{scheme}
(\hyper{element} \ldots)
(\hyper{element} \hyper{element} \ldots . \hyper{template})
(\hyper{ellipsis} \hyper{template})
\#(\hyper{element} \ldots)%
\end{scheme}
where an \hyper{element} is a \hyper{template} optionally
followed by an \hyper{ellipsis}.
An \hyper{ellipsis} is the identifier specified in the second form
of {\cf syntax-rules}, or the default identifier {\cf ...}
(three consecutive periods) otherwise.\schindex{...}

\semantics An instance of {\cf syntax-rules} produces a new macro
transformer by specifying a sequence of hygienic rewrite rules.  A use
of a macro whose keyword is associated with a transformer specified by
{\cf syntax-rules} is matched against the patterns contained in the
\hyper{syntax rule}s, beginning with the leftmost \hyper{syntax rule}.
When a match is found, the macro use is transcribed hygienically
according to the template.

An identifier appearing within a \hyper{pattern} can be an underscore
({\cf \_}), a literal identifier listed in the list of \hyper{literal}s,
or the \hyper{ellipsis}.
All other identifiers appearing within a \hyper{pattern} are
{\em pattern variables}.

The keyword at the beginning of the pattern in a
\hyper{syntax rule} is not involved in the matching and
is considered neither a pattern variable nor a literal identifier.

Pattern variables match arbitrary input elements and
are used to refer to elements of the input in the template.
It is an error for the same pattern variable to appear more than once in a
\hyper{pattern}.

Underscores also match arbitrary input elements but are not pattern variables
and so cannot be used to refer to those elements.  If an underscore appears
in the \hyper{literal}s list, then that takes precedence and
underscores in the \hyper{pattern} match as literals.
Multiple underscores can appear in a \hyper{pattern}.

Identifiers that appear in \texttt{(\hyper{literal} \dotsfoo)} are
interpreted as literal
identifiers to be matched against corresponding elements of the input.
An element in the input matches a literal identifier if and only if it is an
identifier and either both its occurrence in the macro expression and its
occurrence in the macro definition have the same lexical binding, or
the two identifiers are the same and both have no lexical binding.

A subpattern followed by \hyper{ellipsis} can match zero or more elements of
the input, unless \hyper{ellipsis} appears in the \hyper{literal}s, in which
case it is matched as a literal.

More formally, an input expression $E$ matches a pattern $P$ if and only if:

\begin{itemize}
\item $P$ is an underscore ({\cf \_}).

\item $P$ is a non-literal identifier; or

\item $P$ is a literal identifier and $E$ is an identifier with the same
      binding; or

\item $P$ is a list {\cf ($P_1$ $\dots$ $P_n$)} and $E$ is a
      list of $n$
      elements that match $P_1$ through $P_n$, respectively; or

\item $P$ is an improper list
      {\cf ($P_1$ $P_2$ $\dots$ $P_n$ . $P_{n+1}$)}
      and $E$ is a list or
      improper list of $n$ or more elements that match $P_1$ through $P_n$,
      respectively, and whose $n$th tail matches $P_{n+1}$; or

\item $P$ is of the form
      {\cf ($P_1$ $\dots$ $P_k$ $P_e$ \meta{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$)}
      where $E$ is
      a proper list of $n$ elements, the first $k$ of which match
      $P_1$ through $P_k$, respectively,
      whose next $m-k$ elements each match $P_e$,
      whose remaining $n-m$ elements match $P_{m+1}$ through $P_n$; or

\item $P$ is of the form
      {\cf ($P_1$ $\dots$ $P_k$ $P_{e}$ \meta{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$ . $P_x$)}
      where $E$ is
      a list or improper list of $n$ elements, the first $k$ of which match
      $P_1$ through $P_k$,
      whose next $m-k$ elements each match $P_e$,
      whose remaining $n-m$ elements match $P_{m+1}$ through $P_n$,
      and whose $n$th and final cdr matches $P_x$; or

\item $P$ is a vector of the form {\cf \#($P_1$ $\dots$ $P_n$)}
      and $E$ is a vector
      of $n$ elements that match $P_1$ through $P_n$; or

\item $P$ is of the form
      {\cf \#($P_1$ $\dots$ $P_k$ $P_{e}$ \meta{ellipsis} $P_{m+1}$ \dotsfoo $P_n$)}
      where $E$ is a vector of $n$
      elements the first $k$ of which match $P_1$ through $P_k$,
      whose next $m-k$ elements each match $P_e$,
      and whose remaining $n-m$ elements match $P_{m+1}$ through $P_n$; or

\item $P$ is a constant and $E$ is equal to $P$ in the sense of
      the {\cf equal?} procedure.
\end{itemize}

It is an error to use a macro keyword, within the scope of its
binding, in an expression that does not match any of the patterns.

When a macro use is transcribed according to the template of the
matching \hyper{syntax rule}, pattern variables that occur in the
template are replaced by the elements they match in the input.
Pattern variables that occur in subpatterns followed by one or more
instances of the identifier
\hyper{ellipsis} are allowed only in subtemplates that are
followed by as many instances of \hyper{ellipsis}.
They are replaced in the
output by all of the elements they match in the input, distributed as
indicated.  It is an error if the output cannot be built up as
specified.

%%% This description of output construction is very vague.  It should
%%% probably be formalized, but that is not easy...

Identifiers that appear in the template but are not pattern variables
or the identifier
\hyper{ellipsis} are inserted into the output as literal identifiers.  If a
literal identifier is inserted as a free identifier then it refers to the
binding of that identifier within whose scope the instance of
{\cf syntax-rules} appears.
If a literal identifier is inserted as a bound identifier then it is
in effect renamed to prevent inadvertent captures of free identifiers.

A template of the form
{\cf (\hyper{ellipsis} \hyper{template})} is identical to \hyper{template},
except that
ellipses within the template have no special meaning.
That is, any ellipses contained within \hyper{template} are
treated as ordinary identifiers.
In particular, the template {\cf (\hyper{ellipsis} \hyper{ellipsis})} produces
a single \hyper{ellipsis}.
This allows syntactic abstractions to expand into code containing
ellipses.

\begin{scheme}
(define-syntax be-like-begin
  (syntax-rules ()
    ((be-like-begin name)
     (define-syntax name
       (syntax-rules ()
         ((name expr (... ...))
          (begin expr (... ...))))))))

(be-like-begin sequence)
(sequence 1 2 3 4) \ev 4%
\end{scheme}

As an example, if \ide{let} and \ide{cond} are defined as in
section~\ref{derivedsection} then they are hygienic (as required) and
the following is not an error.

\begin{scheme}
(let ((=> \schfalse))
  (cond (\schtrue => 'ok)))           \ev ok%
\end{scheme}

The macro transformer for {\cf cond} recognizes {\cf =>}
as a local variable, and hence an expression, and not as the
base identifier {\cf =>}, which the macro transformer treats
as a syntactic keyword.  Thus the example expands into

\begin{scheme}
(let ((=> \schfalse))
  (if \schtrue (begin => 'ok)))%
\end{scheme}

instead of

\begin{scheme}
(let ((=> \schfalse))
  (let ((temp \schtrue))
    (if temp ('ok temp))))%
\end{scheme}

which would result in an invalid procedure call.

\end{entry}

\subsection{Signaling errors in macro transformers}


\begin{entry}{%
\pproto{(syntax-error \hyper{message} \hyper{args} \dotsfoo)}{\exprtype}}
\mainschindex{syntax-error}

{\cf syntax-error} behaves similarly to {\cf error} (\ref{exceptionsection}) except that implementations
with an expansion pass separate from evaluation should signal an error
as soon as {\cf syntax-error} is expanded.  This can be used as
a {\cf syntax-rules} \hyper{template} for a \hyper{pattern} that is
an invalid use of the macro, which can provide more descriptive error
messages.  \hyper{message} is a string literal, and \hyper{args}
arbitrary expressions providing additional information.
Applications cannot count on being able to catch syntax errors with
exception handlers or guards.

\todo{Shinn: This doesn't check all non-identifier cases, think of a better example.}

\begin{scheme}
(define-syntax simple-let
  (syntax-rules ()
    ((\_ (head ... ((x . y) val) . tail)
        body1 body2 ...)
     (syntax-error
      "expected an identifier but got"
      (x . y)))
    ((\_ ((name val) ...) body1 body2 ...)
     ((lambda (name ...) body1 body2 ...)
       val ...))))%
\end{scheme}

\end{entry}

