% Initial environment

%\vfill\eject
\chapter{標準手続き}
\label{initialenv}
\label{builtinchapter}

\mainindex{initial environment}
\mainindex{global environment}
\mainindex{procedure}

この章ではSchemeの組み込み手続きを説明します。

{\cf force}、{\cf promise?}および{\cf make-promise}は
形式{\cf delay}および{\cf delay-force}と密接に関連しているため、\ref{force}~節で説明しています。
同様に、手続き{\cf make-parameter}は形式{\cf parameterize}と密接に関連しているため、
\ref{make-parameter}~節で説明しています。

\todo{consider removing unspecified effect}
プログラムは大域変数定義を用いて任意の変数を束縛出来ます。
それらの束縛は後に代入によって変更される場合があります(\ref{assignment}~節を参照)。
これらの操作がこの報告書で定義されている手続きの動作を変更することはありません。
また、ライブラリ(\ref{libraries}~節を参照)からインポートされた手続きの動作を変更することもありません。
定義によって導入されたものでない大域変数を変更した場合、
この章で定義されている手続きの動作に与える効果は規定されていません。

手続きが\defining{新しく割り当てられた}オブジェクトを返すと言うとき、
それはそのオブジェクトの場所が新しいという意味です。

\section{等値述語}
\label{equivalencesection}

常にブーリアン値(\schtrue{}または\schfalse)を返す手続きを\defining{述語}と呼びます。
\defining{等値述語}は数学の等値関係をコンピュータ的に真似たものです。
つまり、対称性を持ち、反射性を持ち、推移的です。
この節で説明している等値述語は、
{\cf eq?}が最も細く(最も識別性が高く)、
{\cf equal?}が最も粗く、
{\cf eqv?}がその中間です。


\begin{entry}{%
\proto{eqv?}{ \vari{obj} \varii{obj}}{procedure}}

{\cf eqv?}手続きはオブジェクトに対する有用な等値関係を定義します。
大まかに言うと、{\cf eqv?}は
\vari{obj}と\varii{obj}が普通に考えて同じオブジェクトである場合に
\schtrue{}を返します。
この関係は若干解釈の余地が残されていますが、
以下に述べる{\cf eqv?}の部分的仕様はすべてのScheme処理系において維持されています。


{\cf eqv?}は以下の場合に\schtrue{}を返します。

\begin{itemize}
\item \vari{obj}と\varii{obj}が共に\schtrue{}であるか、共に\schfalse{}である。

\item \vari{obj}と\varii{obj}が共にシンボルであり、
{\cf symbol=?}手続きによれば等しい(\ref{symbolsection}~節)。

\item \vari{obj}と\varii{obj}が共に正確な数値であり、
({\cf =}の意味で)数値的に等しい。

\item \vari{obj}と\varii{obj}が共に不正確な数値であり、
({\cf =}の意味で)数値的に等しく、
そしてScheme標準の数値計算手続き(ただしNaN値を返さない場合に限る)
の有限個の合成関数として定義することの出来る任意の他の手続きに
引数として渡したときに({\cf eqv?}の意味で)同じ結果を生成する。

\item \vari{obj}と\varii{obj}が共に文字であり、
{\cf char=?}手続きによれば同じ文字である(\ref{charactersection}~節)。

\item \vari{obj}と\varii{obj}が共に空リストである。

\item \vari{obj} and \varii{obj} are pairs, vectors, bytevectors, records,
or strings that denote the same location in the store
(section~\ref{storagemodel}).
\item \vari{obj}と\varii{obj}がペア、ベクタ、バイトベクタ、レコードまたは文字列であり、
同じ格納場所を指し示す(\ref{storagemodel}~節)。

\item \vari{obj}と\varii{obj}が手続きであり、
同じ場所に紐付けられている(\ref{lambda}~節)。
\end{itemize}

{\cf eqv?}手続きは以下の場合に\schfalse{}を返します。

\begin{itemize}
\item \vari{obj}と\varii{obj}が異なる型である
(\ref{disjointness}~節)。

\item \vari{obj}または\varii{obj}の一方が\schtrue{}であり、
他方が\schfalse{}である。

\item \vari{obj}および\varii{obj}がシンボルであるが、
{\cf symbol=?}手続きによれば同じシンボルではない
(\ref{symbolsection}~節)。

\item \vari{obj}または\varii{obj}の一方が正確な整数であり、
他方が不正確な整数である。

\item \vari{obj}と\varii{obj}が共に正確な数値であるが、
({\cf =}の意味で)数値的に等しくない。

\item \vari{obj}と\varii{obj}が共に不正確な数値であり、
({\cf =}の意味で)数値的に等しくないか、
またはScheme標準の数値計算手続き(ただしNaN値を返さない場合に限る)
の有限個の合成関数として定義することの出来る任意の他の手続きに
引数として渡したときに({\cf eqv?}の意味で)同じ結果を生成しない。
例外として、\vari{obj}と\varii{obj}が共にNaNであるとき、
{\cf eqv?}の動作は規定されていません。

\item \vari{obj}および\varii{obj}が文字であり、
{\cf char=?}手続きが\schfalse{}を返す。

\item \vari{obj}または\varii{obj}の一方が空リストであり、他方がそうではない。

\item \vari{obj}および\varii{obj}がペア、ベクタ、バイトベクタ、レコードまたは文字列であり、
その指し示す場所が異なる。

\item \vari{obj}および\varii{obj}が手続きであり、
何らかの引数に対して異なる動作をする(異なる値を返すか、異なる副作用を持つ)。

\end{itemize}

\begin{scheme}
(eqv? 'a 'a)                     \ev  \schtrue
(eqv? 'a 'b)                     \ev  \schfalse
(eqv? 2 2)                       \ev  \schtrue
(eqv? 2 2.0)                     \ev  \schfalse
(eqv? '() '())                   \ev  \schtrue
(eqv? 100000000 100000000)       \ev  \schtrue
(eqv? 0.0 +nan.0)                \ev  \schfalse
(eqv? (cons 1 2) (cons 1 2))     \ev  \schfalse
(eqv? (lambda () 1)
      (lambda () 2))             \ev  \schfalse
(let ((p (lambda (x) x)))
  (eqv? p p))                    \ev  \schtrue
(eqv? \#f 'nil)                  \ev  \schfalse%
\end{scheme}

The following examples illustrate cases in which the above rules do
not fully specify the behavior of {\cf eqv?}.  All that can be said
about such cases is that the value returned by {\cf eqv?} must be a
boolean.
前述のルールで{\cf eqv?}の動作が完全には規定されていない状況を以下の例に示します。
そのような場合において言えることは、
{\cf eqv?}の返す値がブーリアンでなければならない、ということのみです。

\begin{scheme}
(eqv? "" "")             \ev  \unspecified
(eqv? '\#() '\#())         \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (x) x))    \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (y) y))    \ev  \unspecified
(eqv? 1.0e0 1.0f0)       \ev  \unspecified
(eqv? +nan.0 +nan.0)     \ev  \unspecified%
\end{scheme}

負のゼロが区別されている場合、{\cf (eqv? 0.0 -0.0)}は\schfalse{}を返し、
負のゼロが区別されていない場合は\schtrue{}を返します。

次の一連の例は、局所的な状態を持つ手続きに対する{\cf eqv?}の使用を示します。
{\cf gen-counter}手続きは、毎回別々の手続きを返さなければなりません。
なぜなら、それぞれ別個の内部カウンタが必要であるためです。
しかし{\cf gen-loser}手続きは、毎回操作的に同等な手続きを返します。
なぜなら、局所状態がその手続きの値にも副作用にも影響しないためです。
しかし{\cf eqv?}は、この等しさを検出できる場合もあれば、できない場合もあります。

\begin{scheme}
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-counter) (gen-counter))
                        \ev  \schfalse
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-loser) (gen-loser))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g))))
  (eqv? f g))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both))))
  (eqv? f g))
                        \ev  \schfalse%
\end{scheme}

定数オブジェクト(リテラル式によって返される)を変更することはエラーであるので、
処理系は適切な状況においては定数間で構造を共有する場合があります。
そのため定数に対する{\cf eqv?}の値は処理系依存になる場合があります。

\begin{scheme}
(eqv? '(a) '(a))                 \ev  \unspecified
(eqv? "a" "a")                   \ev  \unspecified
(eqv? '(b) (cdr '(a b)))	 \ev  \unspecified
(let ((x '(a)))
  (eqv? x x))                    \ev  \schtrue%
\end{scheme}

上で述べた{\cf eqv?}の定義は手続きおよびリテラルの扱いについて処理系に自由を与えます。
処理系は、
2つの手続きや2つのリテラルがお互いに同等であるか検出できてもできなくてもよく、
2つの同等なオブジェクトの表現を同じビットパターンやポインタを用いて
マージするかしないかを選ぶことが出来ます。

\begin{note}
不正確な数値がIEEE二進浮動小数点数値で表現している場合、
同じサイズの不正確な数値を単純にビットごとの比較で行う{\cf eqv?}の実装は、
上記の定義によれば、正しいものです。
\end{note}

\end{entry}


\begin{entry}{%
\proto{eq?}{ \vari{obj} \varii{obj}}{procedure}}

{\cf eq?}手続きは{\cf eqv?}手続きに似ています。
ただし、いくつかの場合において{\cf eqv?}で検出可能なよりも細かい差異を識別する能力があります。
{\cf eqv?}が\schfalse{}を返す状況では同様に\schfalse{}を返さなければなりませんが、
{\cf eqv?}が\schfalse{}を返す状況でも\schtrue{}を返す場合があります。

\vest シンボル、ブーリアン、空リスト、ペア、レコード、
および空でない文字列、ベクタ、バイトベクタにおいて、
{\cf eq?}と{\cf eqv?}は同じ動作をすることが保証されています。
手続きにおいては、引数の場所の紐付けが同じ場合{\cf eq?}を返します。
数値および文字においては、{\cf eq?}の動作は処理系依存です。
ただし、必ず真または偽のどちらかを返します。
空文字列、空ベクタ、空バイトベクタにおいても、{\cf eq?}と{\cf eqv?}は異なる動作をする場合があります。

\begin{scheme}
(eq? 'a 'a)                     \ev  \schtrue
(eq? '(a) '(a))                 \ev  \unspecified
(eq? (list 'a) (list 'a))       \ev  \schfalse
(eq? "a" "a")                   \ev  \unspecified
(eq? "" "")                     \ev  \unspecified
(eq? '() '())                   \ev  \schtrue
(eq? 2 2)                       \ev  \unspecified
(eq? \#\backwhack{}A \#\backwhack{}A) \ev  \unspecified
(eq? car car)                   \ev  \schtrue
(let ((n (+ 2 3)))
  (eq? n n))      \ev  \unspecified
(let ((x '(a)))
  (eq? x x))      \ev  \schtrue
(let ((x '\#()))
  (eq? x x))      \ev  \schtrue
(let ((p (lambda (x) x)))
  (eq? p p))      \ev  \schtrue%
\end{scheme}


\begin{rationale}
通常{\cf eq?}は{\cf eqv?}よりも非常に効率的に実装することが出来ます。
例えば、{\cf eqv?}がいくらか複雑な操作をする代わりに、{\cf eq?}は単なるポインタの比較で済みます。
その理由のひとつは、
2つの数値の{\cf eqv?}を計算することが常に定数時間で出来るわけではないということです。
それに対してポインタ比較で実装された{\cf eq?}は常に定数時間で処理できます。
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{equal?}{ \vari{obj} \varii{obj}}{procedure}}

{\cf equal?}手続きは、ペア、ベクタ、文字列、バイトベクタに適用された場合、それらを再帰的に比較します。
それらを(無限長の可能性もある)木構造に展開したとき、
順序付きの木構造として({\cf equal?}の意味で)等しければ\schtrue{}を返し、
そうでなければ\schfalse{}を返します。
ブーリアン、シンボル、数値、文字、ポート、手続きおよび空リストに適用されたときは
{\cf eqv?}と同じです。
それ以外のすべての状況では、
{\cf equal?}は\schtrue{}を返す場合も\schfalse{}を返す場合もあります。
%% Note that records are {\cf equal?} if their record types are the same
%% and their correspondingly named fields are {\cf equal?}.

引数が循環データ構造であっても、{\cf equal?}は必ず終了しなければなりません。

\begin{scheme}
(equal? 'a 'a)                  \ev  \schtrue
(equal? '(a) '(a))              \ev  \schtrue
(equal? '(a (b) c)
        '(a (b) c))             \ev  \schtrue
(equal? "abc" "abc")            \ev  \schtrue
(equal? 2 2)                    \ev  \schtrue
(equal? (make-vector 5 'a)
        (make-vector 5 'a))     \ev  \schtrue
(equal? '\#1=(a b . \#1\#)
        '\#2=(a b a b . \#2\#))    \ev  \schtrue
(equal? (lambda (x) x)
        (lambda (y) y))  \ev  \unspecified%
\end{scheme}

\begin{note}
大まかに言って、2つのオブジェクトが同じようにプリントされる場合、
一般的にそれらは{\cf equal?}です。
\end{note}



\end{entry}


\section{数値}
\label{numbersection}
\index{number}

\newcommand{\type}[1]{{\it#1}}
\newcommand{\tupe}[1]{{#1}}

数学の数値と、
それをモデル化したSchemeの数値と、
それを表現するために使われる機械表現と、
数値を書くために使われる記法を、区別することは重要です。
この報告書では、
\type{数値},\type{複素数},\type{実数},\type{有理数},\type{整数}
といった型を、数学の数値とSchemeの数値の両方を示すために用います。

\subsection{数値の型}
\label{numericaltypes}
\index{numerical types}

\vest 数学的には、各階がそれより上の階の部分型であるような塔に、数値を編成することが出来ます。
\begin{tabbing}
\ \ \ \ \ \ \ \ \ \=\tupe{数値} \\
\> \tupe{複素数} \\
\> \tupe{実数} \\
\> \tupe{有理数} \\
\> \tupe{整数} 
\end{tabbing}

例えば、3は整数です。
またそれゆえ、3は有理数でもあり、実数でもあり、複素数でもあります。
これは3をモデル化したSchemeの数値においても同様です。
Schemeの数値では、述語
\ide{number?}、\ide{complex?}、\ide{real?}、\ide{rational?}および\ide{integer?}
により、これらの型が定義されます。

数値の型とそのコンピュータ内における表現の間には、単純な関係はありません。
ほとんどのScheme処理系では、3の表現が少なくとも2種類は用意されていますが、
これらの異なる表現は同じ整数を表しています。

Schemeの数値計算では、
数値を可能な限りその表現と独立した抽象的なデータとして扱います。
Scheme処理系は数値の内部表現を複数用いても構いませんが、
単純なプログラムを書くカジュアルプログラマーには判らないようにするべきです。

\subsection{正確性}

\mainindex{exactness} \label{exactly}

正確に表現された数値と、そうでない可能性のある数値の区別は、有用です。
例えば、データ構造へのインデックスは、
記号代数系における多項式の係数と同様に、
正確に判明している必要があります。
他方、計測の結果などは本質的に不正確であったり、
無理数などは有理数によって近似された不正確な近似値であったりします。
正確な数値が必要なところでの不正確な数値の使用を捕えるために、
Schemeでは正確な数値と不正確な数値を区別しています。
この区別は型の次元とは直交しています。

Schemeでは、正確な定数として書かれたか、
\tupe{正確}な演算のみを用いて\tupe{正確}な数値から得られた場合、
その数値は\type{正確}です。
不正確な数値として書かれたか、
\tupe{不正確}な発生源から得られたか、
\tupe{不正確}な演算を用いて得られた場合、
その数値は\type{不正確}です。
従って数値の\tupe{不正確}性は伝染する性質を持ちます。
特に、\defining{正確な複素数}は正確な実部と正確な虚部を持ち、
そうでないすべての複素数は\defining{不正確な複素数}です。

\vest 2つの処理系がある計算に対して
\tupe{不正確}な中間結果を生じずに\tupe{正確}な結果を生成する場合、
その2つの最終結果は数学的に等しくなります。
このことは\tupe{不正確}な数値を生成する計算では一般に真ではありません。
浮動小数点計算のような近似的な手法が使われる場合があるためです。
しかし各々の処理系は数学上の理想的な結果に実用上十分な程度近い結果を生成する義務があります。

\vest {\cf +}のような有理数の演算は
\tupe{正確}な引数が与えられると必ず\tupe{正確}な結果を生成します。
演算が\tupe{正確}な結果を生成することが出来ない場合は、
処理系の制限の違反を報告するか、
その結果を\tupe{不正確}な値に黙って変換しても構いません。
しかしながら、{\cf (/~3~4)}が数学的に不正確な値である{\cf 0}を返すようなことは許容されません。
\ref{restrictions}~節を参照してください。

\vest \ide{exact}を除き、
この節で説明されている演算は一般に、不正確な引数が与えられた場合、不正確な結果を返さなければなりません。
ただし、その結果の値が引数の不正確性に影響を受けないことが保証できる場合は、
\tupe{正確}な結果を返しても構いません。
例えば、\tupe{正確}なゼロにはどんな数値を掛けても、
たとえそれが\tupe{不正確}な値であっても、
\tupe{正確}なゼロの結果を生成することが出来ます。

具体的な例として、
式 {\cf (* 0 +inf.0)} は
{\cf 0}を返しても構いませんし、
{\cf +nan.0}を返しても構いませんし、
不正確な数値をサポートしていない旨を報告しても構いませんし、
無理数をサポートしていない旨を報告しても構いませんし、
黙って死んでも構いませんし、
あるいは処理系固有の方法で騒がしくエラーを出しても構いません。

\subsection{処理系の制限}

\index{implementation restriction}\label{restrictions}

\vest Scheme処理系は\ref{numericaltypes}~節で述べている部分型の塔の全体を実装することは要求されていません。
しかし、処理系の目的とScheme言語の精神の両方を満たす、一貫性のある部分集合を実装しなければなりません。
例えば、
すべての数値が\tupe{実数}である処理系、
\tupe{実数}以外の数値が常に\tupe{不正確}である処理系、
\tupe{正確}な数値が常に\tupe{整数}である処理系、
などは依然として非常に有用でしょう。

\vest 処理系は、この節の要求を満たす限り、
任意の型の数値の、ある特定の範囲のみをサポートしても構いません。
任意の型の\tupe{正確}な数値のサポートされている範囲が
その型の\tupe{不正確}な数値のサポートされている範囲と異なっていても構いません。
例えば、
すべての\tupe{不正確}な\tupe{実数}を表現するためにIEEE二進倍精度浮動小数点数値を採用している処理系では、
\tupe{不正確}な\tupe{実数}の範囲(ゆえに\tupe{不正確}な\tupe{整数}および\tupe{有理数}の範囲も)が
IEEE二進倍精度形式のダイナミックレンジに制限されていながら、
\tupe{正確}な\tupe{整数}と\tupe{有理数}を事実上無制限の範囲でサポートしていて構いません。
さらに言えば、そのような処理系では、この範囲制限に近づくにつれ、
表現可能な\tupe{不正確}な\tupe{整数}および\tupe{有理数}の隙間が
非常に大きくなる可能性があります。

\vest Scheme処理系は、
リスト、ベクタ、バイトベクタ、文字列のインデックスのために、
およびそれらの長さを計算した結果のために必要な数値の範囲全体に対して、
正確な整数をサポートしなければなりません。
\ide{length}、\ide{vector-length}、\ide{bytevector-length}および\ide{string-length}
手続きは正確な整数を返さなければなりません。
また、インデックスとして正確な整数以外のものを使用することはエラーです。
さらに、インデックス範囲内のあらゆる整数定数は、
この範囲外で適用されるいかなる処理系の制限にも関わらず、
正確な整数の構文で表現されていれば、
正確な整数として読めなればなりません。
最後に、以下の一覧に記載されている手続きは、
すべての引数が正確な整数でかつ数学的に期待される結果が処理系の範囲内の正確な整数で表現可能ならば、
必ず正確な整数の結果を返さなければなりません。

\begin{scheme}
-                     *
+                     abs
ceiling               denominator
exact-integer-sqrt    expt
floor                 floor/
floor-quotient        floor-remainder
gcd                   lcm
max                   min
modulo                numerator
quotient              rationalize
remainder             round
square                truncate
truncate/             truncate-quotient
truncate-remainder
\end{scheme}

\vest 処理系は、
事実上無制限の大きさと精度を持つ\tupe{正確}な\tupe{整数}と\tupe{正確}な\tupe{有理数}とサポートし、
上記の手続きと{\cf /}手続きを\tupe{正確}な引数に対して必ず\tupe{正確}な結果を返すよう実装することが、
推奨されますが、要求はされません。
これらの手続きはいずれも、
\tupe{正確}な引数を与えられたとき\tupe{正確}な結果を返すことが出来なければ、
処理系の制限の違反を報告しても構いませんし、
黙ってその結果を\tupe{不正確}な数値に変換しても構いません。
そのような変換は後のエラーの原因となる可能性があります。
とはいえ、\tupe{正確}な有理数を用意していない処理系は
処理系の制限を報告するよりも\tupe{不正確}な有理数を返す方が良いでしょう。

\vest 処理系は\tupe{不正確}な数値に対して浮動小数点や他の近似表現戦略を用いても構いません。
この報告書では IEEE 754 標準に従った浮動小数点表現を用いること、
他の表現方法を用いる処理系はこの浮動小数点の標準を用いて達成可能な精度と同等かそれを超えることが
推奨されていますが、要求はされません。
特に、そのような実装は IEEE 754-2008 の超越関数の記述に、とりわけ無限大とNaNに関して、従うべきです。

Schemeは数値に対する様々な書き方を用意していますが、
処理系はそれらの一部しかサポートしなくても構いません。
例えば、数値がすべて\tupe{実数}である処理系は、複素数の直交座標表示や極座標表示をサポートする必要はありません。
処理系が\tupe{正確}な数値として表現できない\tupe{正確}な数値定数に出くわした場合、
処理系の制限の違反を報告しても構いませんし、
黙って\tupe{不正確}な数値で表現しても構いません。

\subsection{処理系の拡張}
\index{implementation extension}

\vest 処理系によっては2つ以上の異なる精度の浮動小数点数値表現を用意している場合があります。
そのような処理系では、不正確な結果は少なくともその演算に使われた
どの不正確引数も表現できるだけの精度を持っていなければなりません。
{\cf sqrt}のような潜在的に不正確な演算は、
\tupe{正確}な引数を適用したときは\tupe{正確}な結果を生成することが望ましいものの、
もし\tupe{正確}な数値を演算して\tupe{不正確}な結果を生成する場合は、
利用可能な中で最も精度の高い表現を用いなければなりません。
例えば、 {\cf (sqrt 4)} の値は{\cf 2}となるべきですが、
単精度と倍精度の浮動小数点数値を両方用意している処理系では、
後者を用いても構いませんが、前者を用いてはなりません。

その処理系で表現するには大きすぎる絶対値や仮数部を持つ
不正確な数値オブジェクトの使用を避けるのはプログラマの責任です。

さらに、処理系は\tupe{正の無限大}、\tupe{負の無限大}、\tupe{NaN}、および
\tupe{負のゼロ}といった特別な数値を区別しても構いません。

正の無限大は、
有理数で表現可能ないかなる数値よりも大きな不定の値を表現する、
不正確な実数(しかし有理数ではない)と見なされます。
負の無限大は、不正確な実数
有理数で表現可能ないかなる数値よりも小さな不定の値を表現する、
不正確な実数(しかし有理数ではない)と見なされます。

無限大の値にいかなる有限の実数を加算および乗算しても、
その結果は(適切な符号の)無限大となります。
しかし、正の無限大と負の無限大の和はNaNです。
正の無限大はゼロの逆数で、負の無限大は負のゼロの逆数です。
IEEE 754 に従った超越関数の動作は無限大に対して非常に複雑です。

NaNは、任意の実数を表し得る不定の不正確な実数(しかし有理数ではない)と見なされます。
これには、正負の無限大や、正の無限大より大きな値、負の無限大より小さな値も含まれます。
実数以外の数値をサポートしない処理系では、
{\cf (sqrt -1.0)}や{\cf (asin 2.0)}のような実数でない値を表現するために
NaNを用いても構いません。

NaNはどのような数値と比較しても必ず偽になります。
NaN自身と比較しても同様です。
数値演算は引数のいずれかがNaNであればNaNを返します。
ただしそのNaNをどのような有理数と置き換えても結果は同じであると処理系が保証できる場合を除きます。
ゼロをゼロで除算すると、両方のゼロが正確でなければ、結果はNaNになります。

%% IEEE 754 specifies multiple NaN values.  Scheme generally does
%% not care if there is a single value (bit pattern) for NaN,
%% or if there are multiple values: if there are multiple NaN
%% values, or just one, they are all equivalent in terms of Scheme
%% computation.

負のゼロは、不正確な実数であり、{\cf -0.0}と書かれ、
({\cf eqv?}の意味で){\cf 0.0}と区別されます。
Scheme処理系は負のゼロを区別することは要求されません。
しかし区別する場合は、超越関数の動作は IEEE 754 に従った複雑なものになります。
特に、複素数と負のゼロを両方サポートするScheme処理系は、
複素対数関数の分岐を{\cf (imag-part (log -1.0-0.0i))}が$\pi$でなく$-\pi$となるように処理しなければなりません。

さらに、負のゼロに対する負の値は通常のゼロであり、逆も同様です。
これは、2つ以上の負のゼロの和が負であり、
負のゼロから(正の)ゼロを引いた結果も同様に負であることを暗黙に示しています。
しかし、数値的な比較においては、負のゼロとゼロは等しいものとして扱われます。

ちなみに、複素数の実部と虚部いずれにも
無限大、NaNまたは負のゼロを取ることが出来ます。

\subsection{数値定数の構文}
\label{numbernotations}

数値の表現を書くための構文は\ref{numbersyntax}~節で正式に記述されています。
ちなみに数値定数では大文字小文字は区別されません。

数値は基数接頭辞を使うことで二進数、八進数、十進数または十六進数で書くことが出来ます。
基数接頭辞は
{\cf \#b}\sharpindex{b} (二進数)、
{\cf \#o}\sharpindex{o} (八進数)、
{\cf \#d}\sharpindex{d} (十進数)、および
{\cf \#x}\sharpindex{x} (十六進数) です。
基数接頭辞が無い場合、数値は十進数で表現されているとみなされます。

数値定数は接頭辞によって\tupe{正確}または\tupe{不正確}のいずれかを指定出来ます。
\tupe{正確}の接頭辞は{\cf \#e}\sharpindex{e}で
\tupe{不正確}の接頭辞は{\cf \#i}\sharpindex{i}です。
正確性接頭辞は基数接頭辞の前でも後でも構いません。
正確性接頭辞を付けずに数値の表現を書いた場合、
小数点または指数があればその定数は\tupe{不正確}であり、
そうでなければ\tupe{正確}です。

様々な精度の\tupe{不正確}な数値を持つシステムでは、
定数の精度を指定できると有用です。
このため、処理系は
\tupe{不正確}な表現の希望精度を指定する指数マーカーが書かれた数値定数
を受け付けても構いません。
その場合、文字{\cf e}の場所で、その代わりに
{\cf s}、{\cf f}、{\cf d}または{\cf l}を使うことができ、
それぞれ\var{短精度}、\var{単精度}、\var{倍精度}、\var{長精度}を意味しています。
デフォルトの精度は少なくとも\var{倍精度}以上でなければなりませんが、
処理系はこのデフォルトをユーザーの設定によって変更できても構いません。

\begin{scheme}
3.14159265358979F0
       {\rm Round to single ---} 3.141593
0.6L0
       {\rm Extend to long ---} .600000000000000%
\end{scheme}

正の無限大、負の無限大、NaNは、それぞれ
{\cf +inf.0}、{\cf -inf.0}、{\cf +nan.0}と書かれます。
NaNは{\cf -nan.0}と書かれることもあります。
書かれた表現の符号の使用は、もしNaN値の内部表現に符号があっても、それを反映する必要はありません。
処理系はこれらの数値をサポートすることは要求されていませんが、
サポートする場合は、全般的に IEEE 754 に準拠しなければなりません。
ただし、処理系は Signaling NaN をサポートしたり
異なる NaN を区別する方法を用意したりすることは要求されません。

実数でない複素数を表記するための記法が2つあります。
ひとつは\defining{直交座標表示}で、 \var{a}{\cf +}\var{b}{\cf i} のように表記します。
ただし\var{a}は実部で、\var{b}は虚部です。
もうひとつは\defining{極座標表示}で、 \var{r}{\cf @}$\theta$ のように表記します。
ただし\var{r}は動径、 $\theta$ はラジアンで表した位相(偏角)です。
これらは
$a+b\mathrm{i} = r \cos\theta + (r \sin\theta) \mathrm{i}$
の関係があります。
\var{a}、\var{b}、\var{r}および $\theta$ はすべて実数です。


\subsection{数値演算}

数値ルーチンの引数の型の制限を指定するために使われる命名規約の要約について
\ref{typeconventions}~節を参照してください。
この節の例では\tupe{正確}な表記で書かれた数値定数は常に
実際\tupe{正確}な数値を表しているものとみなしています。
また\tupe{不正確}な表記で書かれた特定の数値定数は
精度を失うことなく表現されているものとみなしています。
そういった\tupe{不正確}な定数は、
不正確な数値の表現に IEEE 二進倍精度を採用している処理系で
その仮定が成立するように選ばれています。

\todo{Scheme provides the usual set of operations for manipulating
numbers, etc.}

\begin{entry}{%
\proto{number?}{ obj}{procedure}
\proto{complex?}{ obj}{procedure}
\proto{real?}{ obj}{procedure}
\proto{rational?}{ obj}{procedure}
\proto{integer?}{ obj}{procedure}}

これらの数値述語は、数値でないものを含むいかなる型の引数にも適用できます。
オブジェクトがその名前の型であれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。
一般的に、ある型の述語がある数値に対して真であれば、
より上位の型の述語もすべて、その数値に対して真となります。
そのため、ある型の述語がある数値に対して偽であれば、
より下位の型の述語もすべて、その数値に対して偽となります。

\vr{z}が複素数の場合、
{\cf (real? \vr{z})} は {\cf (zero? (imag-part \vr{z}))} が真のときに限り真となります。
\vr{x}が不正確な実数である場合、
{\cf (integer? \vr{x})} は {\cf (= \vr{x} (round \vr{x}))} が真のときに限り真となります。

{\cf +inf.0}、{\cf -inf.0}および{\cf +nan.0}は実数ですが有理数ではありません。

\begin{scheme}
(complex? 3+4i)         \ev  \schtrue
(complex? 3)            \ev  \schtrue
(real? 3)               \ev  \schtrue
(real? -2.5+0i)         \ev  \schtrue
(real? -2.5+0.0i)       \ev  \schfalse
(real? \#e1e10)          \ev  \schtrue
(real? +inf.0)           \ev  \schtrue
(real? +nan.0)           \ev  \schtrue
(rational? -inf.0)       \ev  \schfalse
(rational? 3.5)          \ev  \schtrue
(rational? 6/10)        \ev  \schtrue
(rational? 6/3)         \ev  \schtrue
(integer? 3+0i)         \ev  \schtrue
(integer? 3.0)          \ev  \schtrue
(integer? 8/4)          \ev  \schtrue%
\end{scheme}

\begin{note}
\tupe{不正確}な数値に対するこれらの型の述語の動作は信頼できません。
不正確さが結果に影響する場合があるためです。
\end{note}

\begin{note}
多くの処理系では\ide{complex?}手続きは\ide{number?}と同じですが、
ある種の無理数を正確に表現できたり、
数値系を拡張して何らかの複素数でない数値をサポートしたりする、
普通でない処理系があるかもしれません。
\end{note}

\end{entry}

\begin{entry}{%
\proto{exact?}{ \vr{z}}{procedure}
\proto{inexact?}{ \vr{z}}{procedure}}

これらの数値述語は値の正確性を判定します。
あらゆるSchemeの数値は、これらの述語のいずれか一方だけが真になります。

\begin{scheme}
(exact? 3.0)           \ev  \schfalse
(exact? \#e3.0)         \ev  \schtrue
(inexact? 3.)          \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{exact-integer?}{ \vr{z}}{procedure}}

\vr{z}が\tupe{正確}かつ\tupe{整数}であれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。

\begin{scheme}
(exact-integer? 32) \ev \schtrue{}
(exact-integer? 32.0) \ev \schfalse{}
(exact-integer? 32/5) \ev \schfalse{}%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{finite?}{ \vr{z}}{inexact library procedure}}

{\cf finite?}手続きは
{\cf +inf.0}、{\cf -inf.0}、{\cf +nan.0}以外のすべての実数、
および実部と虚部が共に有限である複素数に対して、\schtrue{}を返します。
そうでなければ\schfalse{}を返します。

\begin{scheme}
(finite? 3)         \ev  \schtrue
(finite? +inf.0)       \ev  \schfalse
(finite? 3.0+inf.0i)   \ev  \schfalse%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{infinite?}{ \vr{z}}{inexact library procedure}}

{\cf infinite?}手続きは
{\cf +inf.0}、{\cf -inf.0}、および
実部または虚部または両方が無限大である複素数に対して、\schtrue{}を返します。
そうでなければ\schfalse{}を返します。

\begin{scheme}
(infinite? 3)         \ev  \schfalse
(infinite? +inf.0)       \ev  \schtrue
(infinite? +nan.0)       \ev  \schfalse
(infinite? 3.0+inf.0i)   \ev  \schtrue%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{nan?}{ \vr{z}}{inexact library procedure}}

{\cf nan?}手続きは{\cf +nan.0}、および
実部または虚部または両方が{\cf +nan.0}である複素数に対して、\schtrue{}を返します。
そうでなければ\schfalse{}を返します。

\begin{scheme}
(nan? +nan.0)          \ev  \schtrue
(nan? 32)              \ev  \schfalse
(nan? +nan.0+5.0i)     \ev  \schtrue
(nan? 1+2i)            \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{=}{ \vri{z} \vrii{z} \vriii{z} \dotsfoo}{procedure}
\proto{<}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{>}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{<=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{>=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}}

これらの手続きは引数が(それぞれ)
等しい、単調に増加している、単調に減少している、
単調に減少していない、または単調に増加していない場合に、
\schtrue{}を返し、そうでなければ\schfalse{}を返します。
引数のいずれかが{\cf +nan.0}の場合は、どの手続きも\schfalse{}を返します。
これらは不正確なゼロと不正確な負のゼロを区別しません。

これらの手続きは推移的であることが要求されます。

\begin{note}
いずれかの引数が不正確であればすべての引数を不正確な数値に変換する、
というような実装手法は推移的ではありません。
例えば、{\cf big}を{\cf (expt 2 1000)}として、
その{\cf big}が正確であり、
不正確な数値は64ビットのIEEE二進浮動小数点数で表現されているとしましょう。
その場合、この実装手法では、大きな整数のIEEE表現の制限のため、
{\cf (= (- big 1) (inexact big))} と {\cf (= (inexact big) (+ big 1))} が共に真でありながら
{\cf (= (- big 1) (+ big 1))} は偽となってしまうでしょう。
不正確な数値を、それと({\cf =}の意味で)同じ正確な数値に変換すれば、この問題を回避できますが、
無限大に対して特別な配慮が必要となります。
\end{note}

\begin{note}
これらの述語を用いて\tupe{不正確}な数値を比較することはエラーではありませんが、
わずかな不正確さが結果に影響を及ぼす可能性があるため、その結果は信頼できません。
\ide{=}や\ide{zero?}の場合、特にそうです。
嘘だと思うなら数値解析の専門家に聞いてみてください。

\end{note}

\end{entry}

\begin{entry}{%
\proto{zero?}{ \vr{z}}{procedure}
\proto{positive?}{ \vr{x}}{procedure}
\proto{negative?}{ \vr{x}}{procedure}
\proto{odd?}{ \vr{n}}{procedure}
\proto{even?}{ \vr{n}}{procedure}}

これらの数値述語は特定の性質を判定し、\schtrue{} または \schfalse を返します。
上記の注意点も参照してください。

\end{entry}

\begin{entry}{%
\proto{max}{ \vri{x} \vrii{x} \dotsfoo}{procedure}
\proto{min}{ \vri{x} \vrii{x} \dotsfoo}{procedure}}

これらの手続きは引数の最大値または最小値を返します。

\begin{scheme}
(max 3 4)              \ev  4    ; exact
(max 3.9 4)            \ev  4.0  ; inexact%
\end{scheme}

\begin{note}
いずれかの引数が不正確であれば、結果も不正確になります
(その不正確性が結果に影響を与えないくらい大きいことが保証できる場合は除きますが、
そのようなことは普通でない処理系にのみ可能なことです)。
{\cf min}または{\cf max}は正確性が混在した数値を比較するために使うことができ、
その結果の数値を正確さを犠牲にすることなく不正確な数値で表現することが出来ない場合、
これらの手続きは処理系の制限の違反を報告する場合があります。
\end{note}

\end{entry}


\begin{entry}{%
\proto{+}{ \vri{z} \dotsfoo}{procedure}
\proto{*}{ \vri{z} \dotsfoo}{procedure}}

これらの手続きは引数の和または積を返します。

\begin{scheme}
(+ 3 4)                 \ev  7
(+ 3)                   \ev  3
(+)                     \ev  0
(* 4)                   \ev  4
(*)                     \ev  1%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{-}{ \vr{z}}{procedure}
\rproto{-}{ \vri{z} \vrii{z} \dotsfoo}{procedure}
\proto{/}{ \vr{z}}{procedure}
\rproto{/}{ \vri{z} \vrii{z} \dotsfoo}{procedure}}

引数がふたつ以上の場合、
これらの手続きは左結合で引数の差または商を返します。
しかし引数がひとつの場合は、
その引数の反数または逆数を返します。

{\cf /}の第2引数以降のいずれかが正確なゼロの場合はエラーです。
第1引数が正確なゼロであり、他の引数がいずれもNaNでなければ、
正確なゼロを返す場合があります。

\begin{scheme}
(- 3 4)                 \ev  -1
(- 3 4 5)               \ev  -6
(- 3)                   \ev  -3
(/ 3 4 5)               \ev  3/20
(/ 3)                   \ev  1/3%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{abs}{ x}{procedure}}

{\cf abs}手続きは引数の絶対値を返します。
\begin{scheme}
(abs -7)                \ev  7%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{floor/}{ \vri{n} \vrii{n}}{procedure}
\proto{floor-quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{floor-remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{truncate/}{ \vri{n} \vrii{n}}{procedure}
\proto{truncate-quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{truncate-remainder}{ \vri{n} \vrii{n}}{procedure}}

これらの手続きは数論的な(整数)除算を実装します。
\vrii{n}がゼロの場合はエラーです。
{\cf /}で終わる手続きはふたつの整数を返し、それ以外の手続きはひとつの整数を返します。
どの手続きも
$\vri{n} = \vrii{n} \vr{n_q} + \vr{n_r}$
が成り立つような商\vr{n_q}と剰余\vr{n_r}を計算します。
それぞれの除算演算子に対して、3つの手続きが以下のように定義されます。

\begin{scheme}
(\hyper{operator}/ \vri{n} \vrii{n})             \ev \vr{n_q} \vr{n_r}
(\hyper{operator}-quotient \vri{n} \vrii{n})     \ev \vr{n_q}
(\hyper{operator}-remainder \vri{n} \vrii{n})    \ev \vr{n_r}%
\end{scheme}

剰余\vr{n_r}は整数\vr{n_q}が決まると自動的に
$\vr{n_r} = \vri{n} - \vrii{n} \vr{n_q}$
のように決定されます。
\vr{n_q}の決め方は各演算子によって異なります。

\begin{tabular}{l l}
\texttt{floor}     & $\vr{n_q} = \lfloor\vri{n} / \vrii{n}\rfloor$ \\
\texttt{truncate}  & $\vr{n_q} = \text{truncate}(\vri{n} / \vrii{n})$ \\
\end{tabular}

For any of the operators, and for integers \vri{n} and \vrii{n}
with \vrii{n} not equal to 0,
いずれの演算子も、またいずれの整数\vri{n}および\vrii{n}(ただし\vrii{n}がゼロでない場合)においても、
以下が成り立ちます。
\begin{scheme}
     (= \vri{n} (+ (* \vrii{n} (\hyper{operator}-quotient \vri{n} \vrii{n}))
           (\hyper{operator}-remainder \vri{n} \vrii{n})))
                                 \ev  \schtrue%
\end{scheme}
ただしすべての数値が正確な計算によって得られる場合の話です。

例:

\begin{scheme}
(floor/ 5 2)         \ev 2 1
(floor/ -5 2)        \ev -3 1
(floor/ 5 -2)        \ev -3 -1
(floor/ -5 -2)       \ev 2 -1
(truncate/ 5 2)      \ev 2 1
(truncate/ -5 2)     \ev -2 -1
(truncate/ 5 -2)     \ev -2 1
(truncate/ -5 -2)    \ev 2 -1
(truncate/ -5.0 -2)  \ev 2.0 -1.0%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{modulo}{ \vri{n} \vrii{n}}{procedure}}

{\cf quotient}および{\cf remainder}手続きはそれぞれ
{\cf truncate-quotient}および{\cf truncate-remainder}と同等であり、
{\cf modulo}は{\cf floor-remainder}と同等です。

\begin{note}
これらの手続きは以前のバージョンの報告書との後方互換性のために用意されています。
\end{note}
\end{entry}

\begin{entry}{%
\proto{gcd}{ \vri{n} \dotsfoo}{procedure}
\proto{lcm}{ \vri{n} \dotsfoo}{procedure}}

これらの手続きは引数の最大公約数または最小公倍数を返します。
結果は必ず非負です。

\begin{scheme}
(gcd 32 -36)            \ev  4
(gcd)                   \ev  0
(lcm 32 -36)            \ev  288
(lcm 32.0 -36)          \ev  288.0  ; inexact
(lcm)                   \ev  1%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{numerator}{ \vr{q}}{procedure}
\proto{denominator}{ \vr{q}}{procedure}}

これらの手続きは引数の分子または分母を返します。
結果は引数が既約分数として表現されているかのように計算されます。
分母は必ず正です。
ゼロの分母は1であると定義されます。
\todo{More description and examples needed.}
\begin{scheme}
(numerator (/ 6 4))  \ev  3
(denominator (/ 6 4))  \ev  2
(denominator
  (inexact (/ 6 4))) \ev 2.0%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{floor}{ x}{procedure}
\proto{ceiling}{ x}{procedure}
\proto{truncate}{ x}{procedure}
\proto{round}{ x}{procedure}
}

これらの手続きは整数を返します。
\vest {\cf floor}手続きは\vr{x}より大きくない最も大きな整数を返します。
{\cf ceiling}手続きは\vr{x}より小さくない最も小さな整数を返します。
{\cf truncate}手続きは絶対値が\vr{x}の絶対値より大きくない\vr{x}に最も近い整数を返します。
{\cf round}手続きは\vr{x}に最も近い整数を返しますが、
\vr{x}がふたつの整数の中央のときは偶数側に丸めます。

\begin{rationale}
{\cf round}手続きの偶数丸めは IEEE 754 IEEE浮動小数点標準で規定されている
デフォルトの丸めモードとの一貫性のためです。
\end{rationale}

\begin{note}
これらの手続きの引数が不正確な場合、結果も不正確になります。
正確な値が必要であれば結果を{\cf exact}手続きに渡しても構いません。
引数が無限大またはNaNの場合は、そのまま返されます。
\end{note}

\begin{scheme}
(floor -4.3)          \ev  -5.0
(ceiling -4.3)        \ev  -4.0
(truncate -4.3)       \ev  -4.0
(round -4.3)          \ev  -4.0

(floor 3.5)           \ev  3.0
(ceiling 3.5)         \ev  4.0
(truncate 3.5)        \ev  3.0
(round 3.5)           \ev  4.0  ; inexact

(round 7/2)           \ev  4    ; exact
(round 7)             \ev  7%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{rationalize}{ x y}{procedure}
}

{\cf rationalize}手続きは\vr{x}から±\vr{y}以内の{\em 最も簡単}な有理数を返します。
ある有理数 $r_1$ が別の有理数 $r_2$ より{\em 簡単}であるとは、\mainindex{simplest rational}
$r_1 = p_1/q_1$ および $r_2 = p_2/q_2$ (いずれも既約) としたとき、
$|p_1| \leq |p_2|$ かつ $|q_1| \leq |q_2|$ である場合のことを言います。
つまり $3/5$ は $4/7$ より簡単です。
すべての有理数がこの順序付けで比較できるわけではありませんが
($2/7$ と $3/5$ を考えてみてください)、
どのような区間においても他のすべての有理数より簡単な有理数というものがひとつ存在しています
($2/7$ と $3/5$ の間には、より簡単な $2/5$ があります)。
ちなみにすべての有理数のうち最も簡単なものは $0 = 0/1$ です。

\begin{scheme}
(rationalize
  (exact .3) 1/10)  \ev 1/3    ; exact
(rationalize .3 1/10)        \ev \#i1/3  ; inexact%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{exp}{ \vr{z}}{inexact library procedure}
\proto{log}{ \vr{z}}{inexact library procedure}
\rproto{log}{ \vri{z} \vrii{z}}{inexact library procedure}
\proto{sin}{ \vr{z}}{inexact library procedure}
\proto{cos}{ \vr{z}}{inexact library procedure}
\proto{tan}{ \vr{z}}{inexact library procedure}
\proto{asin}{ \vr{z}}{inexact library procedure}
\proto{acos}{ \vr{z}}{inexact library procedure}
\proto{atan}{ \vr{z}}{inexact library procedure}
\rproto{atan}{ \vr{y} \vr{x}}{inexact library procedure}}

これらの手続きは通常の超越関数を計算します。
{\cf log}手続きは引数がひとつの場合は\vr{z}の自然対数を計算し(底を10とする対数ではありません)、
引数がふたつの場合は底を\vrii{z}とする\vri{z}の対数を計算します。
{\cf asin}、{\cf acos}、{\cf atan}手続きはそれぞれ
逆正弦($\sin^{-1}$)、逆余弦($\cos^{-1}$)、逆正接($\tan^{-1}$)を計算します。
{\cf atan}の2引数版は
{\tt (angle (make-rectangular \vr{x} \vr{y}))}
(後述)を計算します(処理系が複素数をサポートしていない場合でも)。

一般的に、対数、逆正弦、逆余弦、逆正接といった数学関数は多重定義されます。
$\log z$ の値はその虚部が $-\pi$ ({\cf -0.0}が区別されている場合は含まれず、そうでなければ含まれる)
から $\pi$ (常に含まれる) の範囲にある場合は1に定義されます。
$\log 0$の値は数学的に未定義です。
$\log$をこのように定義すると、
$\sin^{-1} z$、$\cos^{-1} z$、$\tan^{-1} z$は以下の式に従います。
$$\sin^{-1} z = -i \log (i z + \sqrt{1 - z^2})$$
$$\cos^{-1} z = \pi / 2 - \sin^{-1} z$$
$$\tan^{-1} z = (\log (1 + i z) - \log (1 - i z)) / (2 i)$$

しかし、処理系が無限大 (および {\cf -0.0}) をサポートしている場合、
{\cf (log 0.0)} は {\cf -inf.0} を返します
(また {\cf (log -0.0)} は {\cf -inf.0+$\pi$i} を返します)。

\texttt{({\cf atan} \var{y} \var{x})} の範囲は以下の表のようになります。
星印 (*) はマイナスゼロを区別する処理系に適用される項目であることを示しています。

\begin{center}
\begin{tabular}{clll}
& $y$の条件 & $x$の条件 & 結果$r$の範囲\\\hline
& $y = 0.0$ & $x > 0.0$ & $0.0$\\
$\ast$ & $y = +0.0$  & $x > 0.0$ & $+0.0$\\
$\ast$ & $y = -0.0$ & $x > 0.0$ & $-0.0$\\
& $y > 0.0$ & $x > 0.0$ & $0.0 < r < \frac{\pi}{2}$\\
& $y > 0.0$ & $x = 0.0$ & $\frac{\pi}{2}$\\
& $y > 0.0$ & $x < 0.0$ & $\frac{\pi}{2} < r < \pi$\\
& $y = 0.0$ & $x < 0$ & $\pi$\\
$\ast$ & $y = +0.0$ & $x < 0.0$ & $\pi$\\
$\ast$ & $y = -0.0$ & $x < 0.0$ & $-\pi$\\
&$y < 0.0$ & $x < 0.0$ & $-\pi< r< -\frac{\pi}{2}$\\
&$y < 0.0$ & $x = 0.0$ & $-\frac{\pi}{2}$\\
&$y < 0.0$ & $x > 0.0$ & $-\frac{\pi}{2} < r< 0.0$\\
&$y = 0.0$ & $x = 0.0$ & undefined\\
$\ast$& $y = +0.0$ & $x = +0.0$ & $+0.0$\\
$\ast$& $y = -0.0$ & $x = +0.0$& $-0.0$\\
$\ast$& $y = +0.0$ & $x = -0.0$ & $\pi$\\
$\ast$& $y = -0.0$ & $x = -0.0$ & $-\pi$\\
$\ast$& $y = +0.0$ & $x = 0$ & $\frac{\pi}{2}$\\
$\ast$& $y = -0.0$ & $x = 0$    & $-\frac{\pi}{2}$
\end{tabular}
\end{center}

上記の仕様は\cite{CLtL}に従ったもので、それは\cite{Penfield81}から引用されたものです。
分岐条件や境界条件、およびこれらの関数の実装についてのより詳細な議論は、
これらの情報源を参照してください。
可能であれば、これらの手続きは実数の引数から実数の結果を生成します。


\end{entry}

\begin{entry}{%
\proto{square}{ \vr{z}}{procedure}}

\vr{z}の平方を返します。
これは \texttt{({\cf *} \var{z} \var{z})} と同等です。
\begin{scheme}
(square 42)       \ev 1764
(square 2.0)     \ev 4.0%
\end{scheme}

%% Removing this since it's inaccurate and not reflective of the
%% real rationale most members listed.  We need a proper rationale
%% document to go into detail.
%% \begin{rationale}
%% Taking the square of a large integer is more efficient than
%% multiplying arbitrary integers, and floating-point processors often
%% have a primitive square operator.
%% \end{rationale}

\end{entry}

\begin{entry}{%
\proto{sqrt}{ \vr{z}}{inexact library procedure}}

\vr{z}の正の平方根を返します。
結果は正の実部を持つか、ゼロの実部と非負の虚部を持つかのいずれかです。

\begin{scheme}
(sqrt 9)  \ev 3
(sqrt -1) \ev +i%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{exact-integer-sqrt}{ k}{procedure}}

$\var{k} = s^2 + r$ および $\var{k} < (s+1)^2$ が成り立つ
ふたつの非負の正確な整数$s$および$r$を返します。

\begin{scheme}
(exact-integer-sqrt 4) \ev 2 0
(exact-integer-sqrt 5) \ev 2 1%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{expt}{ \vri{z} \vrii{z}}{procedure}}

\vri{z}の\vrii{z}乗を返します。
\vri{z}がゼロでなければ、これは $${z_1}^{z_2} = e^{z_2 \log {z_1}}$$ です。
$0^z$ の値は{\cf (zero? z)}の場合$1$、
{\cf (real-part z)}が正の場合$0$で、
それ以外はエラーです。
$0.0^z$の場合も同様ですが、不正確な結果になります。
\end{entry}




\begin{entry}{%
\proto{make-rectangular}{ \vri{x} \vrii{x}}{complex library procedure}
\proto{make-polar}{ \vriii{x} \vriv{x}}{complex library procedure}
\proto{real-part}{ \vr{z}}{complex library procedure}
\proto{imag-part}{ \vr{z}}{complex library procedure}
\proto{magnitude}{ \vr{z}}{complex library procedure}
\proto{angle}{ \vr{z}}{complex library procedure}}

実数\vri{x}、\vrii{x}、\vriii{x}、\vriv{x}および
複素数\vr{z}について
 $$ \vr{z} = \vri{x} + \vrii{x}\hbox{$i$}
 = \vriii{x} \cdot e^{i x_4}$$
が成り立つ場合、以下がすべて成り立ちます。
\begin{scheme}
(make-rectangular \vri{x} \vrii{x}) \ev \vr{z}
(make-polar \vriii{x} \vriv{x})     \ev \vr{z}
(real-part \vr{z})                  \ev \vri{x}
(imag-part \vr{z})                  \ev \vrii{x}
(magnitude \vr{z})                  \ev $|\vriii{x}|$
(angle \vr{z})                      \ev $x_{angle}$%
\end{scheme}
ただし $-\pi \le x_{angle} \le \pi$ かつ $x_{angle} = \vriv{x} + 2\pi n$
($n$は整数)とします。

{\cf make-polar}は引数が正確であっても不正確な複素数を返す場合があります。
{\cf real-part}および{\cf imag-part}手続きは、不正確な複素数に適用した場合でも、
{\cf make-rectangular}に渡された対応する引数が正確であったならば、正確な実数を返す場合があります。


\begin{rationale}
{\cf magnitude}手続きは実数の引数に対しては\ide{abs}と同じですが、
{\cf abs}はbaseライブラリの手続きであるのに対し、
{\cf magnitude}はオプションのcomplexライブラリの手続きとなっています。
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{inexact}{ \vr{z}}{procedure}
\proto{exact}{ \vr{z}}{procedure}}

手続き{\cf inexact}は\vr{z}の\tupe{不正確}な表現を返します。
戻り値は数値的に引数に最も近い\tupe{不正確}な数値です。
不正確な引数に対しては、その引数と同じ値を返します。
正確な複素数に対しては、引数の実部と虚部をそれぞれ{\cf inexact}に適用した結果を
実部と虚部に持つ複素数を返します。
\tupe{正確}な引数に十分近い({\cf =}の意味で)同等な\tupe{不正確}な値がない場合、
処理系の制限の違反が報告される場合があります。

手続き{\cf exact}は\vr{z}の\tupe{正確}な表現を返します。
戻り値は数値的に引数に近い\tupe{正確}な値です。
正確な引数に対しては、その引数と同じ値を返します。
不正確な整数でない実数の引数に対しては、有理数による近似値を返す場合もあれば、
処理系の制限の違反が報告される場合もあります。
不正確な複素数の引数に対しては、引数の実部と虚部をそれぞれ{\cf exact}に適用した結果を
実部と虚部に持つ複素数を返します。
\tupe{不正確}な引数に十分近い({\cf =}の意味で)同等な\tupe{正確}な値がない場合、
処理系の制限の違反が報告される場合があります。

これらの手続きは処理系依存の範囲内の\tupe{正確}な整数と\tupe{不正確}な整数に対して
自然な1対1の対応関係を実装しています。
\ref{restrictions}~節を参照してください。

\begin{note}
これらの手続きは \rfivers\ ではそれぞれ
{\cf exact->inexact}および{\cf inexact->exact}として知られていました。
しかしこれらは常にどちらの正確性の引数も受け付けていました。
新しい名前は \rsixrs と互換性があるのと同様に明確で短いものです。
\end{note}

\end{entry}

\medskip

\subsection{数値の入出力}

\begin{entry}{%
\proto{number->string}{ z}{procedure}
\rproto{number->string}{ z radix}{procedure}}

\domain{\vr{radix}が2、8、10、16のいずれでもなければエラーです。}
手続き{\cf number\coerce{}string}は数値と基数を取り、
以下の式を満たすような指定した基数における指定した数値の外部表現を、
文字列として返します。
\begin{scheme}
(let ((number \vr{number})
      (radix \vr{radix}))
  (eqv? number
        (string->number (number->string number
                                        radix)
                        radix)))%
\end{scheme}
この式を満たせる結果が存在しない場合はエラーです。
\vr{radix}を省略した場合のデフォルト値は10です。

\vr{z}が不正確で、基数が10で、かつ小数点を含む結果によって上記の式が満たせる場合、
その結果は小数点を含み、
上記の式を満たすために必要な最小限の桁数(指数と末尾のゼロを除く)
で表現されます~\cite{howtoprint,howtoread}。
そうでない場合、結果の書式は規定されていません。

{\cf number\coerce{}string}の戻り値が明示的な基数接頭辞を持つことはありません。

\begin{note}
エラーの状況は、\vr{z}が複素数でないか、
実部または虚部が有理数でない複素数の場合にのみ、発生する可能性があります。
\end{note}

\begin{rationale}
\vr{z}が不正確な数値かつ基数が10の場合、
上記の式は通常、小数点を含む結果によって満たすことが出来ます。
規定されていない結果は
無限大、NaN、あるいは普通でない表現の場合に許容されます。
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{string->number}{ string}{procedure}
\rproto{string->number}{ string radix}{procedure}}


\vr{string}によって表現された最大限に正確な表現の数値を返します。
\domain{\vr{radix}が2、8、10、16のいずれでもなければエラーです。}
\vr{radix}が指定された場合、それがデフォルトの基数となります。
これは\vr{string}に明示的な基数接頭辞 (例えば {\tt "\#o177"})
があればオーバーライドされます。
\vr{radix}が指定されなかった場合、デフォルトの基数は10です。
\vr{string}が構文的に有効な数値の表記でない場合、
または結果の数値を処理系が表現できない場合、
{\cf string->number}は\schfalse{}を返します。
\vr{string}の中身を理由にエラーが通知されることはありません。

\begin{scheme}
(string->number "100")        \ev  100
(string->number "100" 16)     \ev  256
(string->number "1e2")        \ev  100.0%
\end{scheme}

\begin{note}
{\cf string->number}の定義域は以下のように処理系によって制限される場合があります。
処理系のサポートする数値が実数のみの場合、
\vr{string}が極座標表示または直交座標表示の複素数を用いたら
{\cf string->number}は\schfalse{}を返すことが許容されます。
数値が整数のみの場合、
分数表記が使われたら\schfalse{}を返しても構いません。
正確な数値のみの場合、
指数マーカーや明示的な正確性接頭辞が使われたら\schfalse{}を返しても構いません。
不正確な数値が整数のみの場合、
小数点が使われたら\schfalse{}を返しても構いません。

内部の数値処理、I/O、プログラム処理の間で一貫性を維持するため、
ある特定の処理系が{\cf string->number}に対して用いるルールは、
{\cf read}やプログラムの読み込みルーチンにも適用されなければなりません。
それにより、-\var{string}が明示的な基数接頭辞を持っている場合は
\schfalse{}を返しても良いという \rfivers\ の記述は廃止されました。
\end{note}

\end{entry}

\section{ブーリアン}
\label{booleansection}

真および偽に対する標準のブーリアンオブジェクトは
\schtrue{}および\schfalse のように書きます。\sharpindex{t}\sharpindex{f}  
代わりに、それぞれ\sharptrue および \sharpfalse と書くことも出来ます。
これらの重要な点はSchemeの条件式
({\cf if}, {\cf cond}, {\cf and}, {\cf or}, {\cf when}, {\cf unless}, {\cf do})
が真\index{true}または偽\index{false}として扱うオブジェクトであるということです。
用語``真の値''\index{true}(または単に``真'')は
条件式において真として扱われるあらゆるオブジェクトを意味し、
用語``偽の値''\index{false}(または``偽'')は
条件式において偽として扱われるあらゆるオブジェクトを意味します。

\vest すべてのSchemeの値のうち、
\schfalse{}のみが条件式において偽とみなされます。
\schtrue{}を含め、
それ以外のすべてのSchemeの値は真とみなされます。

\begin{note}
他のLisp方言と異なり、
Schemeでは\schfalse{}と空リスト\index{empty list}はお互いに区別され、
またシンボル\ide{nil}とも区別されます。
\end{note}

\vest ブーリアン定数はそれ自身に評価されるため、プログラム中で引用する必要はありません。

\begin{scheme}
\schtrue         \ev  \schtrue
\schfalse        \ev  \schfalse
'\schfalse       \ev  \schfalse%
\end{scheme}


\begin{entry}{%
\proto{not}{ obj}{procedure}}

{\cf not}手続きは
\var{obj}が偽の場合\schtrue{}を返し、
そうでなければ\schfalse{}を返します。

\begin{scheme}
(not \schtrue)   \ev  \schfalse
(not 3)          \ev  \schfalse
(not (list 3))   \ev  \schfalse
(not \schfalse)  \ev  \schtrue
(not '())        \ev  \schfalse
(not (list))     \ev  \schfalse
(not 'nil)       \ev  \schfalse%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{boolean?}{ obj}{procedure}}

{\cf boolean?}述語は\var{obj}が\schtrue{}または\schfalse{}の場合
\schtrue{}を返し、そうでなければ\schfalse{}を返します。

\begin{scheme}
(boolean? \schfalse)  \ev  \schtrue
(boolean? 0)          \ev  \schfalse
(boolean? '())        \ev  \schfalse%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{boolean=?}{ \vari{boolean} \varii{boolean} \variii{boolean} \dotsfoo}{procedure}}

引数がすべてブーリアンで、
すべて\schtrue{}であるかすべて\schfalse{}であれば、
\schtrue{}を返します。

\end{entry}
 
\section{ペアとリスト}
\label{listsection}

\defining{ペア} (\defining{ドット対}と呼ばれることもあります)
は、(歴史的理由により) carおよびcdrという名前で呼ばれるふたつのフィールドを持つレコード構造です。
ペアは手続き{\cf cons}で作ることが出来ます。
手続き{\cf car}および{\cf cdr}でcarおよびcdrフィールドにアクセス出来ます。
手続き{\cf set-car!}および{\cf set-cdr!}でcarおよびcdrフィールドに代入出来ます。

ペアは主にリストを表現するために使われます。
\defining{リスト}は、
空リスト\index{empty list}またはcdrがリストであるペアとして、
再帰的に定義できます。
より正確に言うと、リストの集合は以下を満たす最小の集合\var{X}として定義されます。

\begin{itemize}
\item 空リストは\var{X}の要素です。
\item \var{リスト}が\var{X}の要素であれば、
      cdrフィールドに\var{リスト}を持つペアもすべて\var{X}の要素です。
\end{itemize}

リストを構成するペアのcarフィールドのオブジェクトは、そのリストの要素です。
例えば2要素のリストとは、ペアであって、そのペアのcarが最初の要素、そのペアのcdrがまたペアであって、
そのペアのcarが2番目の要素、そのペアのcdrが空リストであるようなものを言います。
リストの長さは要素の長さ、つまりペアの数と同じです。

空リスト\mainindex{empty list}は独立した型を持つ特殊なオブジェクトです。
それはペアではなく、要素を持たず、その長さはゼロです。

\begin{note}
上記の定義は、すべてのリストが有限の長さを持ち、空リストで終端することを暗黙に示しています。
\end{note}

Schemeのペアの最も汎用的な表記 (外部表現) は
\hbox{\cf (\vari{c} .\ \varii{c})}
のような``ドット''記法です。
ただし\vari{c}はcarフィールドの値で、\varii{c}はcdrフィールドの値です。
例えば {\cf (4 .\ 5)} はcarが4でありcdrが5であるペアです。
{\cf (4 .\ 5)} はペアの外部表現であって、ペアに評価される式ではないことに注意してください。

リストに対してはより流線的な記法が使われます。
単純にリストの要素をスペースで区切って括弧で囲みます。
空リスト\index{empty list}は{\tt()}と書きます。
例を挙げます。

\begin{scheme}
(a b c d e)%
\end{scheme}

これはシンボルのリストの表記で、以下と同等です。

\begin{scheme}
(a . (b . (c . (d . (e . ())))))%
\end{scheme}

空リストで終端しないペアのチェーンは\defining{非真正リスト}と呼ばれます。
非真正リストはリストではないことに注意してください。
リストとドット記法を組み合わせて非真正リストを表現することが出来ます。

\begin{scheme}
(a b c . d)%
\end{scheme}

これは以下と同等です。

\begin{scheme}
(a . (b . (c . d)))%
\end{scheme}

与えられたペアがリストであるかどうかは、cdrフィールドに何が格納されているかに依ります。
\ide{set-cdr!}手続きを使うと、
ある瞬間にはリストであったオブジェクトが次の瞬間にはそうでなくなる場合があります。

\begin{scheme}
(define x (list 'a 'b 'c))
(define y x)
y                       \ev  (a b c)
(list? y)               \ev  \schtrue
(set-cdr! x 4)          \ev  \unspecified
x                       \ev  (a . 4)
(eqv? x y)              \ev  \schtrue
y                       \ev  (a . 4)
(list? y)               \ev  \schfalse
(set-cdr! x x)          \ev  \unspecified
(list? x)               \ev  \schfalse%
\end{scheme}

リテラル式や\ide{read}手続きによって読み込んだオブジェクトの表現の中では、
\singlequote\hyper{datum}\schindex{'}、
\backquote\hyper{datum}、
{\tt,}\hyper{datum}\schindex{,}、
{\tt,@}\hyper{datum}
といった形は、最初の要素がそれぞれシンボル
\ide{quote}、\ide{quasiquote}、\hbox{\ide{unquote}}、\ide{unquote-splicing}
である2要素のリストを表します。
この規約により任意のSchemeプログラムをリストとして表現出来ます。
つまり、Schemeの文法によれば、
すべての\meta{expression}は\meta{datum}でもある、
ということです(\ref{datum}~節を参照)。
特に、これにより、{\cf read}手続きでSchemeのプログラムを解析出来るようになっています。
\ref{externalreps}~節も参照してください。
 

\begin{entry}{%
\proto{pair?}{ obj}{procedure}}

{\cf pair?}手続きは、\var{obj}がペアであれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。

\begin{scheme}
(pair? '(a . b))        \ev  \schtrue
(pair? '(a b c))        \ev  \schtrue
(pair? '())             \ev  \schfalse
(pair? '\#(a b))         \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{cons}{ \vari{obj} \varii{obj}}{procedure}}

carが\vari{obj}でありcdrが\varii{obj}である新しく割り当てられたペアを返します。
このペアは既存のいかなるオブジェクトとも({\cf eqv?}の意味で)異なることが保証されています。

\begin{scheme}
(cons 'a '())           \ev  (a)
(cons '(a) '(b c d))    \ev  ((a) b c d)
(cons "a" '(b c))       \ev  ("a" b c)
(cons 'a 3)             \ev  (a . 3)
(cons '(a b) 'c)        \ev  ((a b) . c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{car}{ pair}{procedure}}

\var{pair}のcarフィールドの内容を返します。
空リスト\index{empty list}のcarを取ることはエラーであることに注意してください。

\begin{scheme}
(car '(a b c))          \ev  a
(car '((a) b c d))      \ev  (a)
(car '(1 . 2))          \ev  1
(car '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{cdr}{ pair}{procedure}}

\var{pair}のcdrフィールドの内容を返します。
空リストのcdrを取ることはエラーであることに注意してください。

\begin{scheme}
(cdr '((a) b c d))      \ev  (b c d)
(cdr '(1 . 2))          \ev  2
(cdr '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{set-car!}{ pair obj}{procedure}}

\var{pair}のcarフィールドに\var{obj}を格納します。
\begin{scheme}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             \ev  \unspecified
(set-car! (g) 3)             \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{set-cdr!}{ pair obj}{procedure}}

\var{pair}のcdrフィールドに\var{obj}を格納します。
\end{entry}

\setbox0\hbox{\tt(cadr \var{pair})}
\setbox1\hbox{procedure}


\begin{entry}{%
\proto{caar}{ pair}{procedure}
\proto{cadr}{ pair}{procedure}
\proto{cdar}{ pair}{procedure}
\proto{cddr}{ pair}{procedure}}

これらの手続きは以下のような{\cf car}および{\cf cdr}の合成関数です。

\begin{scheme}
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{caaar}{ pair}{cxr library procedure}%
\proto{caadr}{ pair}{cxr library procedure}%
\pproto{\hbox to 1\wd0 {\hfil$\vdots$\hfil}}{\hbox to 1\wd1 {\hfil$\vdots$\hfil}}%
\mainschindex{cadar}\mainschindex{caddr}%
\mainschindex{cdaar}\mainschindex{cdadr}\mainschindex{cddar}\mainschindex{cdddr}%
\mainschindex{caaaar}\mainschindex{caaadr}\mainschindex{caadar}\mainschindex{caaddr}%
\mainschindex{cadaar}\mainschindex{cadadr}\mainschindex{caddar}\mainschindex{cadddr}%
\mainschindex{cdaaar}\mainschindex{cdaadr}\mainschindex{cdadar}\mainschindex{cdaddr}%
\mainschindex{cddaar}\mainschindex{cddadr}%
\proto{cdddar}{ pair}{cxr library procedure}%
\proto{cddddr}{ pair}{cxr library procedure}}

これら24個の手続きは同じ考え方に基づいた{\cf car}および{\cf cdr}のさらなる合成関数です。
例えば、{\cf caddr}は以下のように定義できます。

\begin{scheme}
(define caddr (lambda (x) (car (cdr (cdr x))))){\rm.}%
\end{scheme}

深さ4までのすべての組み合わせが用意されています。

\end{entry}


\begin{entry}{%
\proto{null?}{ obj}{procedure}}

\var{obj}が空リスト\index{empty list}であれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。

\end{entry}

\begin{entry}{%
\proto{list?}{ obj}{procedure}}

\var{obj}がリストであれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。
定義により、リストはすべて有限の長さを持ち、空リストで終端します。

\begin{scheme}
        (list? '(a b c))     \ev  \schtrue
        (list? '())          \ev  \schtrue
        (list? '(a . b))     \ev  \schfalse
        (let ((x (list 'a)))
          (set-cdr! x x)
          (list? x))         \ev  \schfalse%
\end{scheme}


\end{entry}

\begin{entry}{%
\proto{make-list}{ k}{procedure}
\rproto{make-list}{ k fill}{procedure}}

\var{k}要素の新しく割り当てられたリストを返します。
第2引数が指定された場合は、その各要素が\var{fill}に初期化されます。
そうでなければ、各要素の初期内容は規定されていません。

\begin{scheme}
(make-list 2 3)   \ev   (3 3)%
\end{scheme}

\end{entry}



\begin{entry}{%
\proto{list}{ \var{obj} \dotsfoo}{procedure}}

その引数から成る新しく割り当てられたリストを返します。

\begin{scheme}
(list 'a (+ 3 4) 'c)            \ev  (a 7 c)
(list)                          \ev  ()%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{length}{ list}{procedure}}

\var{list}の長さを返します。

\begin{scheme}
(length '(a b c))               \ev  3
(length '(a (b) (c d e)))       \ev  3
(length '())                    \ev  0%
\end{scheme}


\end{entry}


\begin{entry}{%
\proto{append}{ list \dotsfoo}{procedure}}

\domain{最後の引数(もしあれば)は任意の型を指定できます。}
最初の\var{list}の要素に他の\var{list}の要素を続けたものを要素とするリストを返します。
引数が無ければ、空リストが返されます。
引数がひとつだけの場合は、それが返されます。
それ以外の場合は、結果のリストは常に新しく割り当てられますが、最後の引数の構造は共有します。
最後の引数が真正リストでなければ、結果は非真正リストです。

\begin{scheme}
(append '(x) '(y))              \ev  (x y)
(append '(a) '(b c d))          \ev  (a b c d)
(append '(a (b)) '((c)))        \ev  (a (b) (c))%
\end{scheme}


\begin{scheme}
(append '(a b) '(c . d))        \ev  (a b c . d)
(append '() 'a)                 \ev  a%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{reverse}{ list}{procedure}}

\var{list}の要素から成る逆順の新しく割り当てられたリストを返します。

\begin{scheme}
(reverse '(a b c))              \ev  (c b a)
(reverse '(a (b c) d (e (f))))  \lev  ((e (f)) d (b c) a)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list-tail}{ list \vr{k}}{procedure}}

\domain{\var{list}の要素が\vr{k}個より少ない場合はエラーです。}
最初の\vr{k}個の要素を除いて得られる\var{list}の部分リストを返します。
The {\cf list-tail} procedure could be defined by

\begin{scheme}
(define list-tail
  (lambda (x k)
    (if (zero? k)
        x
        (list-tail (cdr x) (- k 1)))))%
\end{scheme} 
\end{entry}


\begin{entry}{%
\proto{list-ref}{ list \vr{k}}{procedure}}

\domain{\var{list}引数は循環構造でも構いません。
\var{list}の要素が\vr{k}個より少ない場合はエラーです。}
\var{list}の\vr{k}番目の要素を返します。
(これは {\tt(list-tail \var{list} \vr{k})} のcarと同じです。)

\begin{scheme}
(list-ref '(a b c d) 2)                 \ev  c
(list-ref '(a b c d)
          (exact (round 1.8))) \lev  c%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{list-set!}{ list k obj}{procedure}}

\domain{\vr{k}が\var{list}の有効なインデックスでない場合はエラーです。}
{\cf list-set!}手続きは\var{list}の\vr{k}番目の要素に\var{obj}を格納します。
\begin{scheme}
(let ((ls (list 'one 'two 'five!)))
  (list-set! ls 2 'three)
  ls)      \lev  (one two three)

(list-set! '(0 1 2) 1 "oops")  \lev  \scherror  ; constant list%
\end{scheme}
\end{entry}




\begin{entry}{%
\proto{memq}{ obj list}{procedure}
\proto{memv}{ obj list}{procedure}
\proto{member}{ obj list}{procedure}
\rproto{member}{ obj list compare}{procedure}}

これらの手続きはcarが\var{obj}である最初の\var{list}の部分リストを返します。
\var{list}の部分リストは
{\tt (list-tail \var{list} \var{k})}によって返される空でないリストです
(\var{k}は\var{list}の長さより小さいものとします)。
\var{list}内に\var{obj}が現れない場合は、
\schfalse{}が返されます(空リストではありません)。
{\cf memq}手続きは\var{obj}と\var{list}の要素との比較に{\cf eq?}を用いるのに対して、
{\cf memv}は{\cf eqv?}を用い、
{\cf member}は\var{compare}が指定された場合はそれを用い、そうでなければ{\cf equal?}を用います。

\begin{scheme}
(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(member "B"
        '("a" "b" "c")
        string-ci=?)            \ev  ("b" "c")
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{assq}{ obj alist}{procedure}
\proto{assv}{ obj alist}{procedure}
\proto{assoc}{ obj alist}{procedure}
\rproto{assoc}{ obj alist compare}{procedure}}

\domain{\var{alist}(``association list''(連想リスト)の略)がペアのリストでなければエラーです。}
これらの手続きはcarフィールドが\var{obj}である\var{alist}内の最初のペアを探し、
そのペアを返します。
carに\var{obj}を持つペアが\var{alist}内に無ければ、
\schfalse{}が返されます(空リストではありません)。
{\cf assq}手続きは\var{obj}と\var{alist}内のペアのcarフィールドとの比較に{\cf eq?}を用いるのに対して、
{\cf assv}は{\cf eqv?}を用い、
{\cf assoc}は\var{compare}が指定された場合はそれを用い、そうでなければ{\cf equal?}を用います。

\begin{scheme}
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assoc 2.0 '((1 1) (2 4) (3 9)) =)
                           \ev (2 4)
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}


\begin{rationale}
{\cf memq}、{\cf memv}、{\cf member}、{\cf assq}、{\cf assv}および{\cf assoc}は、
よく述語として用いられはしますが、名前に疑問符は付いていません。
これは、単なる\schtrue{}または\schfalse{}でなく、
場合によっては有用な値を返すためです。
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{list-copy}{ obj}{procedure}}

\var{obj}がリストの場合、その新しく割り当てられたコピーを返します。
コピーされるのはペア自身だけです。
結果のcarは\var{list}のcarと({\cf eqv?}の意味で)同じになります。
\var{obj}が非真正リストの場合、結果も非真正リストとなり、
最後のcdrは{\cf eqv?}の意味で同じになります。
\var{obj}がリストでない場合はそのまま返されます。
\var{obj}が循環リストの場合はエラーです。

\begin{scheme}
(define a '(1 8 2 8)) ; a may be immutable
(define b (list-copy a))
(set-car! b 3)        ; b is mutable
b \ev (3 8 2 8)
a \ev (1 8 2 8)%
\end{scheme}

\end{entry}


\section{Symbols}
\label{symbolsection}

Symbols are objects whose usefulness rests on the fact that two
symbols are identical (in the sense of {\cf eqv?}) if and only if their
names are spelled the same way.  For instance, they can be used
the way enumerated values are used in other languages.

\vest The rules for writing a symbol are exactly the same as the rules for
writing an identifier; see sections~\ref{syntaxsection}
and~\ref{identifiersyntax}.

\vest It is guaranteed that any symbol that has been returned as part of
a literal expression, or read using the {\cf read} procedure, and
subsequently written out using the {\cf write} procedure, will read back
in as the identical symbol (in the sense of {\cf eqv?}).

\begin{note}
Some implementations have values known as ``uninterned symbols,''
which defeat write/read invariance, and also violate the rule that two
symbols are the same if and only if their names are spelled the same.
This report does not specify the behavior of
implementation-dependent extensions.
\end{note}


\begin{entry}{%
\proto{symbol?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a symbol, otherwise returns \schfalse.

\begin{scheme}
(symbol? 'foo)          \ev  \schtrue
(symbol? (car '(a b)))  \ev  \schtrue
(symbol? "bar")         \ev  \schfalse
(symbol? 'nil)          \ev  \schtrue
(symbol? '())           \ev  \schfalse
(symbol? \schfalse)     \ev  \schfalse%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{symbol=?}{ \vari{symbol} \varii{symbol} \variii{symbol} \dotsfoo}{procedure}}

Returns \schtrue{} if all the arguments are symbols and all have the same
names in the sense of {\cf string=?}.

\begin{note}
The definition above assumes that none of the arguments
are uninterned symbols.
\end{note}

\end{entry}

\begin{entry}{%
\proto{symbol->string}{ symbol}{procedure}}

Returns the name of \var{symbol} as a string, but without adding escapes.
It is an error
to apply mutation procedures like \ide{string-set!} to strings returned
by this procedure.

\begin{scheme}
(symbol->string 'flying-fish)     
                                  \ev  "flying-fish"
(symbol->string 'Martin)          \ev  "Martin"
(symbol->string
   (string->symbol "Malvina"))     
                                  \ev  "Malvina"%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{string->symbol}{ string}{procedure}}

Returns the symbol whose name is \var{string}.  This procedure can
create symbols with names containing special characters that would
require escaping when written, but does not interpret escapes in its input.

\begin{scheme}
(string->symbol "mISSISSIppi")  \lev%
  mISSISSIppi
(eqv? 'bitBlt (string->symbol "bitBlt"))     \lev  \schtrue
(eqv? 'LollyPop
     (string->symbol
       (symbol->string 'LollyPop)))  \lev  \schtrue
(string=? "K. Harper, M.D."
          (symbol->string
            (string->symbol "K. Harper, M.D.")))  \lev  \schtrue%
\end{scheme}

\end{entry}


\section{Characters}
\label{charactersection}

Characters are objects that represent printed characters such as
letters and digits.  
All Scheme implementations must support at least the ASCII character
repertoire: that is, Unicode characters U+0000 through U+007F.
Implementations may support any other Unicode characters they see fit,
and may also support non-Unicode characters as well.
Except as otherwise specified, the result of applying any of the
following procedures to a non-Unicode character is implementation-dependent.

Characters are written using the notation \sharpsign\backwhack\hyper{character}
or \sharpsign\backwhack\hyper{character name} or
\sharpsign\backwhack{}x\meta{hex scalar value}.

The following character names must be supported
by all implementations with the given values.  
Implementations may add other names
provided they cannot be interpreted as hex scalar values preceded by {\cf x}.

$$
\begin{tabular}{ll}
{\tt \#\backwhack{}alarm}&; \textrm{U+0007}\\
{\tt \#\backwhack{}backspace}&; \textrm{U+0008}\\
{\tt \#\backwhack{}delete}&; \textrm{U+007F}\\
{\tt \#\backwhack{}escape}&; \textrm{U+001B}\\
{\tt \#\backwhack{}newline}&; the linefeed character, \textrm{U+000A}\\
{\tt \#\backwhack{}null}&; the null character, \textrm{U+0000}\\
{\tt \#\backwhack{}return}&; the return character, \textrm{U+000D}\\
{\tt \#\backwhack{}space}&; the preferred way to write a space\\
{\tt \#\backwhack{}tab}&; the tab character, \textrm{U+0009}\\
\end{tabular}
$$

Here are some additional examples:

$$
\begin{tabular}{ll}
{\tt \#\backwhack{}a}&; lower case letter\\
{\tt \#\backwhack{}A}&; upper case letter\\
{\tt \#\backwhack{}(}&; left parenthesis\\
{\tt \#\backwhack{} }&; the space character\\
{\tt \#\backwhack{}x03BB}&; $\lambda$ (if character is supported)\\
{\tt \#\backwhack{}iota}&; $\iota$ (if character and name are supported)\\
\end{tabular}
$$

Case is significant in \sharpsign\backwhack\hyper{character}, and in
\sharpsign\backwhack{\rm$\langle$character name$\rangle$},
but not in {\cf\sharpsign\backwhack{}x}\meta{hex scalar value}.  
If \hyper{character} in
\sharpsign\backwhack\hyper{character} is alphabetic, then any character
immediately following \hyper{character} cannot be one that can appear in an identifier.
This rule resolves the ambiguous case where, for
example, the sequence of characters ``{\tt\sharpsign\backwhack space}''
could be taken to be either a representation of the space character or a
representation of the character ``{\tt\sharpsign\backwhack s}'' followed
by a representation of the symbol ``{\tt pace}.''

\todo{Fix}
Characters written in the \sharpsign\backwhack{} notation are self-evaluating.
That is, they do not have to be quoted in programs.  

\vest Some of the procedures that operate on characters ignore the
difference between upper case and lower case.  The procedures that
ignore case have \hbox{``{\tt -ci}''} (for ``case
insensitive'') embedded in their names.


\begin{entry}{%
\proto{char?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a character, otherwise returns \schfalse.

\end{entry}


\begin{entry}{%
\proto{char=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{procedure}
\proto{char<?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{procedure}
\proto{char>?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{procedure}
\proto{char<=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{procedure}
\proto{char>=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{procedure}}

\label{characterequality}

These procedures return \schtrue{} if 
the results of passing their arguments to {\cf char\coerce{}integer}
are respectively
equal, monotonically increasing, monotonically decreasing,
monotonically non-decreasing, or monotonically non-increasing.

These predicates are required to be transitive.

\end{entry}


\begin{entry}{%
\proto{char-ci=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{char library procedure}
\proto{char-ci<?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{char library procedure}
\proto{char-ci>?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{char library procedure}
\proto{char-ci<=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{char library procedure}
\proto{char-ci>=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{char library procedure}}

These procedures are similar to {\cf char=?}\ et cetera, but they treat
upper case and lower case letters as the same.  For example, {\cf
(char-ci=?\ \#\backwhack{}A \#\backwhack{}a)} returns \schtrue.

Specifically, these procedures behave as if {\cf char-foldcase} were
applied to their arguments before they were compared.

\end{entry}


\begin{entry}{%
\proto{char-alphabetic?}{ char}{char library procedure}
\proto{char-numeric?}{ char}{char library procedure}
\proto{char-whitespace?}{ char}{char library procedure}
\proto{char-upper-case?}{ letter}{char library procedure}
\proto{char-lower-case?}{ letter}{char library procedure}}

These procedures return \schtrue{} if their arguments are alphabetic,
numeric, whitespace, upper case, or lower case characters, respectively,
otherwise they return \schfalse.  

Specifically, they must return \schtrue{} when applied to characters with
the Unicode properties Alphabetic, Numeric\_Digit, White\_Space, Uppercase, and
Lowercase respectively, and \schfalse{} when applied to any other Unicode
characters.  Note that many Unicode characters are alphabetic but neither
upper nor lower case.

\end{entry}


\begin{entry}{%
\proto{digit-value}{ char}{char library procedure}}

This procedure returns the numeric value (0 to 9) of its argument
if it is a numeric digit (that is, if {\cf char-numeric?} returns \schtrue{}),
or \schfalse{} on any other character.

\begin{scheme}
(digit-value \#\backwhack{}3) \ev 3
(digit-value \#\backwhack{}x0664) \ev 4
(digit-value \#\backwhack{}x0AE6) \ev 0
(digit-value \#\backwhack{}x0EA6) \ev \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{char->integer}{ char}{procedure}
\proto{integer->char}{ \vr{n}}{procedure}}

Given a Unicode character, 
{\cf char\coerce{}integer} returns an exact integer 
between 0 and {\tt \#xD7FF} or 
between {\tt \#xE000} and {\tt \#x10FFFF} 
which is equal to the Unicode scalar value of that character.
Given a non-Unicode character, 
it returns an exact integer greater than {\tt \#x10FFFF}.  
This is true independent of whether the implementation uses
the Unicode representation internally.

Given an exact integer that is the value returned by
a character when {\cf char\coerce{}integer} is applied to it, {\cf integer\coerce{}char}
returns that character.
\end{entry}


\begin{entry}{%
\proto{char-upcase}{ char}{char library procedure}
\proto{char-downcase}{ char}{char library procedure}
\proto{char-foldcase}{ char}{char library procedure}}


The {\cf char-upcase} procedure, given an argument that is the
lowercase part of a Unicode casing pair, returns the uppercase member
of the pair, provided that both characters are supported by the Scheme
implementation.  Note that language-sensitive casing pairs are not used.  If the
argument is not the lowercase member of such a pair, it is returned.

The {\cf char-downcase} procedure, given an argument that is the
uppercase part of a Unicode casing pair, returns the lowercase member
of the pair, provided that both characters are supported by the Scheme
implementation.  Note that language-sensitive casing pairs are not used.  If the
argument is not the uppercase member of such a pair, it is returned.

The {\cf char-foldcase} procedure applies the Unicode simple
case-folding algorithm to its argument and returns the result.  Note that
language-sensitive folding is not used.  If the argument is an uppercase
letter, the result will be either a lowercase letter
or the same as the argument if the lowercase letter does not exist or
is not supported by the implementation.
See UAX \#29~\cite{uax29} (part of the Unicode Standard) for details.

Note that many Unicode lowercase characters do not have uppercase
equivalents.

\end{entry}


\section{Strings}
\label{stringsection}

Strings are sequences of characters.  
\vest Strings are written as sequences of characters enclosed within quotation marks
({\cf "}).  Within a string literal, various escape
sequences\mainindex{escape sequence} represent characters other than
themselves.  Escape sequences always start with a backslash (\backwhack{}):

\begin{itemize}
\item{\cf\backwhack{}a} : alarm, U+0007
\item{\cf\backwhack{}b} : backspace, U+0008 
\item{\cf\backwhack{}t} : character tabulation, U+0009 
\item{\cf\backwhack{}n} : linefeed, U+000A 
\item{\cf\backwhack{}r} : return, U+000D 
\item{\cf\backwhack{}}\verb|"| : double quote, U+0022 
\item{\cf\backwhack{}\backwhack{}} : backslash, U+005C 
\item{\cf\backwhack{}|} : vertical line, U+007C
\item{\cf\backwhack{}\arbno{\hyper{intraline whitespace}}\hyper{line ending}
      \arbno{\hyper{intraline whitespace}}} : nothing
\item{\cf\backwhack{}x\meta{hex scalar value};} : specified character (note the
  terminating semi-colon).
\end{itemize}

The result is unspecified if any other character in a string occurs
after a backslash.

\vest Except for a line ending, any character outside of an escape
sequence stands for itself in the string literal.  A line ending which
is preceded by {\cf\backwhack{}\hyper{intraline whitespace}} expands
to nothing (along with any trailing intraline whitespace), and can be
used to indent strings for improved legibility. Any other line ending
has the same effect as inserting a {\cf\backwhack{}n} character into
the string.

Examples:

\begin{scheme}
"The word \backwhack{}"recursion\backwhack{}" has many meanings."
"Another example:\backwhack{}ntwo lines of text"
"Here's text \backwhack{} 
   containing just one line"
"\backwhack{}x03B1; is named GREEK SMALL LETTER ALPHA."%
\end{scheme}

\vest The {\em length} of a string is the number of characters that it
contains.  This number is an exact, non-negative integer that is fixed when the
string is created.  The \defining{valid indexes} of a string are the
exact non-negative integers less than the length of the string.  The first
character of a string has index 0, the second has index 1, and so on.


\vest Some of the procedures that operate on strings ignore the
difference between upper and lower case.  The names of the versions that ignore case
end with \hbox{``{\cf -ci}''} (for ``case insensitive'').

Implementations may forbid certain characters from appearing in strings.
However, with the exception of {\tt \#\backwhack{}null}, ASCII characters must
not be forbidden.
For example, an implementation might support the entire Unicode repertoire,
but only allow characters U+0001 to U+00FF (the Latin-1 repertoire
without {\tt \#\backwhack{}null}) in strings.

It is an error to pass such a forbidden character to
{\cf make-string}, {\cf string}, {\cf string-set!}, or {\cf string-fill!},
as part of the list passed to {\cf list\coerce{}string},
or as part of the vector passed to {\cf vector\coerce{}string}
(see section~\ref{vectortostring}),
or in UTF-8 encoded form within a bytevector passed to
{\cf utf8\coerce{}string} (see section~\ref{utf8tostring}).
It is also an error for a procedure passed to {\cf string-map}
(see section~\ref{stringmap}) to return a forbidden character,
or for {\cf read-string} (see section~\ref{readstring})
to attempt to read one.

\begin{entry}{%
\proto{string?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a string, otherwise returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-string}{ \vr{k}}{procedure}
\rproto{make-string}{ \vr{k} char}{procedure}}

The {\cf make-string} procedure returns a newly allocated string of
length \vr{k}.  If \var{char} is given, then all the characters of the string
are initialized to \var{char}, otherwise the contents of the
string are unspecified.

\end{entry}

\begin{entry}{%
\proto{string}{ char \dotsfoo}{procedure}}

Returns a newly allocated string composed of the arguments.
It is analogous to {\cf list}.

\end{entry}

\begin{entry}{%
\proto{string-length}{ string}{procedure}}

Returns the number of characters in the given \var{string}.
\end{entry}


\begin{entry}{%
\proto{string-ref}{ string \vr{k}}{procedure}}

\domain{It is an error if \vr{k} is not a valid index of \var{string}.}
The {\cf string-ref} procedure returns character \vr{k} of \var{string} using zero-origin indexing.
\end{entry}
There is no requirement for this procedure to execute in constant time.


\begin{entry}{%
\proto{string-set!}{ string k char}{procedure}}

\domain{It is an error if \vr{k} is not a valid index of \var{string}.}
The {\cf string-set!} procedure stores \var{char} in element \vr{k} of \var{string}.
There is no requirement for this procedure to execute in constant time.

\begin{scheme}
(define (f) (make-string 3 \sharpsign\backwhack{}*))
(define (g) "***")
(string-set! (f) 0 \sharpsign\backwhack{}?)  \ev  \unspecified
(string-set! (g) 0 \sharpsign\backwhack{}?)  \ev  \scherror
(string-set! (symbol->string 'immutable)
             0
             \sharpsign\backwhack{}?)  \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{string=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{procedure}}

Returns \schtrue{} if all the strings are the same length and contain
exactly the same characters in the same positions, otherwise returns
\schfalse.

\end{entry}

\begin{entry}{%
\proto{string-ci=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{char library procedure}}

Returns \schtrue{} if, after case-folding, all the strings are the same
length and contain the same characters in the same positions, otherwise
returns \schfalse.  Specifically, these procedures behave as if 
{\cf string-foldcase} were applied to their arguments before comparing them.

\end{entry}


\begin{entry}{%
\proto{string<?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{procedure}
\proto{string-ci<?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{char library procedure}
\proto{string>?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{procedure}
\proto{string-ci>?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{char library procedure}
\proto{string<=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{procedure}
\proto{string-ci<=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{char library procedure}
\proto{string>=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{procedure}
\proto{string-ci>=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{char library procedure}}

These procedures return \schtrue{} if their arguments are (respectively):
monotonically increasing, monotonically decreasing,
monotonically non-decreasing, or monotonically non-increasing.

These predicates are required to be transitive.

These procedures compare strings in an implementation-defined way.
One approach is to make them the lexicographic extensions to strings of
the corresponding orderings on characters.  In that case, {\cf string<?}\
would be the lexicographic ordering on strings induced by the ordering
{\cf char<?}\ on characters, and if the two strings differ in length but
are the same up to the length of the shorter string, the shorter string
would be considered to be lexicographically less than the longer string.
However, it is also permitted to use the natural ordering imposed by the
implementation's internal representation of strings, or a more complex locale-specific
ordering.

In all cases, a pair of strings must satisfy exactly one of
{\cf string<?}, {\cf string=?}, and {\cf string>?}, and must satisfy
{\cf string<=?} if and only if they do not satisfy {\cf string>?} and
{\cf string>=?} if and only if they do not satisfy {\cf string<?}.

The \hbox{``{\tt -ci}''} procedures behave as if they applied
{\cf string-foldcase} to their arguments before invoking the corresponding
procedures without  \hbox{``{\tt -ci}''}.


\end{entry}

\begin{entry}{%
\proto{string-upcase}{ string}{char library procedure}
\proto{string-downcase}{ string}{char library procedure}
\proto{string-foldcase}{ string}{char library procedure}}


These procedures apply the Unicode full string uppercasing, lowercasing,
and case-folding algorithms to their arguments and return the result.
In certain cases, the result differs in length from the argument.
If the result is equal to the argument in the sense of {\cf string=?}, the argument may be returned.
Note that language-sensitive mappings and foldings are not used.  

The Unicode Standard prescribes special treatment of the Greek letter
$\Sigma$, whose normal lower-case form is $\sigma$ but which becomes
$\varsigma$ at the end of a word.  See UAX \#29~\cite{uax29} (part of
the Unicode Standard) for details.  However, implementations of {\cf
string-downcase} are not required to provide this behavior, and may
choose to change $\Sigma$ to $\sigma$ in all cases.

\end{entry}


\begin{entry}{%
\proto{substring}{ string start end}{procedure}}

The {\cf substring} procedure returns a newly allocated string formed from the characters of
\var{string} beginning with index \var{start} and ending with index
\var{end}.
This is equivalent to calling {\cf string-copy} with the same arguments,
but is provided for backward compatibility and
stylistic flexibility.
\end{entry}


\begin{entry}{%
\proto{string-append}{ \var{string} \dotsfoo}{procedure}}

Returns a newly allocated string whose characters are the concatenation of the
characters in the given strings.

\end{entry}


\begin{entry}{%
\proto{string->list}{ string}{procedure}
\rproto{string->list}{ string start}{procedure}
\rproto{string->list}{ string start end}{procedure}
\proto{list->string}{ list}{procedure}}

\domain{It is an error if any element of \var{list} is not a character.}
The {\cf string\coerce{}list} procedure returns a newly allocated list of the
characters of \var{string} between \var{start} and \var{end}.
{\cf list\coerce{}string}
returns a newly allocated string formed from the elements in the list
\var{list}.
In both procedures, order is preserved.
{\cf string\coerce{}list}
and {\cf list\coerce{}string} are
inverses so far as {\cf equal?}\ is concerned.  

\end{entry}


\begin{entry}{%
\proto{string-copy}{ string}{procedure}
\rproto{string-copy}{ string start}{procedure}
\rproto{string-copy}{ string start end}{procedure}}

Returns a newly allocated copy of the part of the given \var{string}
between \var{start} and \var{end}.

\end{entry}


\begin{entry}{%
\proto{string-copy!}{ to at from}{procedure}
\rproto{string-copy!}{ to at from start}{procedure}
\rproto{string-copy!}{ to at from start end}{procedure}}

\domain{It is an error if \var{at} is less than zero or greater than the length of \var{to}.
It is also an error if {\cf (- (string-length \var{to}) \var{at})}
is less than {\cf (- \var{end} \var{start})}.}
Copies the characters of string \var{from} between \var{start} and \var{end}
to string \var{to}, starting at \var{at}.  The order in which characters are
copied is unspecified, except that if the source and destination overlap,
copying takes place as if the source is first copied into a temporary
string and then into the destination.  This can be achieved without
allocating storage by making sure to copy in the correct direction in
such circumstances.

\begin{scheme}
(define a "12345")
(define b (string-copy "abcde"))
(string-copy! b 1 a 0 2)
b \ev "a12de"%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{string-fill!}{ string fill}{procedure}
\rproto{string-fill!}{ string fill start}{procedure}
\rproto{string-fill!}{ string fill start end}{procedure}}

\domain{It is an error if \var{fill} is not a character.}

The {\cf string-fill!} procedure stores \var{fill}
in the elements of \var{string}
between \var{start} and \var{end}.

\end{entry}


\section{Vectors}
\label{vectorsection}

Vectors are heterogeneous structures whose elements are indexed
by integers.  A vector typically occupies less space than a list
of the same length, and the average time needed to access a randomly
chosen element is typically less for the vector than for the list.

\vest The {\em length} of a vector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when the
vector is created.  The {\em valid indexes}\index{valid indexes} of a
vector are the exact non-negative integers less than the length of the
vector.  The first element in a vector is indexed by zero, and the last
element is indexed by one less than the length of the vector.

Vectors are written using the notation {\tt\#(\var{obj} \dotsfoo)}.
For example, a vector of length 3 containing the number zero in element
0, the list {\cf(2 2 2 2)} in element 1, and the string {\cf "Anna"} in
element 2 can be written as follows:

\begin{scheme}
\#(0 (2 2 2 2) "Anna")%
\end{scheme}

Vector constants are self-evaluating, so they do not need to be quoted in programs.

\begin{entry}{%
\proto{vector?}{ obj}{procedure}}
 
Returns \schtrue{} if \var{obj} is a vector; otherwise returns \schfalse.
\end{entry}


\begin{entry}{%
\proto{make-vector}{ k}{procedure}
\rproto{make-vector}{ k fill}{procedure}}

Returns a newly allocated vector of \var{k} elements.  If a second
argument is given, then each element is initialized to \var{fill}.
Otherwise the initial contents of each element is unspecified.

\end{entry}


\begin{entry}{%
\proto{vector}{ obj \dotsfoo}{procedure}}

Returns a newly allocated vector whose elements contain the given
arguments.  It is analogous to {\cf list}.

\begin{scheme}
(vector 'a 'b 'c)               \ev  \#(a b c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-length}{ vector}{procedure}}

Returns the number of elements in \var{vector} as an exact integer.
\end{entry}


\begin{entry}{%
\proto{vector-ref}{ vector k}{procedure}}

\domain{It is an error if \vr{k} is not a valid index of \var{vector}.}
The {\cf vector-ref} procedure returns the contents of element \vr{k} of
\var{vector}.

\begin{scheme}
(vector-ref '\#(1 1 2 3 5 8 13 21)
            5)  \lev  8
(vector-ref '\#(1 1 2 3 5 8 13 21)
            (exact
             (round (* 2 (acos -1))))) \lev 13%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-set!}{ vector k obj}{procedure}}

\domain{It is an error if \vr{k} is not a valid index of \var{vector}.}
The {\cf vector-set!} procedure stores \var{obj} in element \vr{k} of \var{vector}.
\begin{scheme}
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)      \lev  \#(0 ("Sue" "Sue") "Anna")

(vector-set! '\#(0 1 2) 1 "doe")  \lev  \scherror  ; constant vector%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector->list}{ vector}{procedure}
\rproto{vector->list}{ vector start}{procedure}
\rproto{vector->list}{ vector start end}{procedure}
\proto{list->vector}{ list}{procedure}}

The {\cf vector->list} procedure returns a newly allocated list of the objects contained
in the elements of \var{vector} between \var{start} and \var{end}.
The {\cf list->vector} procedure returns a newly
created vector initialized to the elements of the list \var{list}.

In both procedures, order is preserved.

\begin{scheme}
(vector->list '\#(dah dah didah))  \lev  (dah dah didah)
(vector->list '\#(dah dah didah) 1 2) \lev (dah)
(list->vector '(dididit dah))   \lev  \#(dididit dah)%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{vector->string}{ vector}{procedure}
\rproto{vector->string}{ vector start}{procedure}
\rproto{vector->string}{ vector start end}{procedure}
\proto{string->vector}{ string}{procedure}
\rproto{string->vector}{ string start}{procedure}
\rproto{string->vector}{ string start end}{procedure}}
\label{vectortostring}

\domain{It is an error if any element of \var{vector} between \var{start}
and \var{end} is not a character.}
The {\cf vector->string} procedure returns a newly allocated string of the objects contained
in the elements of \var{vector}
between \var{start} and \var{end}.
The {\cf string->vector} procedure returns a newly
created vector initialized to the elements of the string \var{string}
between \var{start} and \var{end}.

In both procedures, order is preserved.


\begin{scheme}
(string->vector "ABC")  \ev   \#(\#\backwhack{}A \#\backwhack{}B \#\backwhack{}C)
(vector->string
  \#(\#\backwhack{}1 \#\backwhack{}2 \#\backwhack{}3) \ev "123"
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{vector-copy}{ vector}{procedure}
\rproto{vector-copy}{ vector start}{procedure}
\rproto{vector-copy}{ vector start end}{procedure}}

Returns a newly allocated copy of the elements of the given \var{vector}
between \var{start} and \var{end}.
The elements of the new vector are the same (in the sense of
{\cf eqv?}) as the elements of the old.


\begin{scheme}
(define a \#(1 8 2 8)) ; a may be immutable
(define b (vector-copy a))
(vector-set! b 0 3)   ; b is mutable
b \ev \#(3 8 2 8)
(define c (vector-copy b 1 3))
c \ev \#(8 2)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-copy!}{ to at from}{procedure}
\rproto{vector-copy!}{ to at from start}{procedure}
\rproto{vector-copy!}{ to at from start end}{procedure}}

\domain{It is an error if \var{at} is less than zero or greater than the length of \var{to}.
It is also an error if {\cf (- (vector-length \var{to}) \var{at})}
is less than {\cf (- \var{end} \var{start})}.}
Copies the elements of vector \var{from} between \var{start} and \var{end}
to vector \var{to}, starting at \var{at}.  The order in which elements are
copied is unspecified, except that if the source and destination overlap,
copying takes place as if the source is first copied into a temporary
vector and then into the destination.  This can be achieved without
allocating storage by making sure to copy in the correct direction in
such circumstances.

\begin{scheme}
(define a (vector 1 2 3 4 5))
(define b (vector 10 20 30 40 50))
(vector-copy! b 1 a 0 2)
b \ev \#(10 1 2 40 50)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-append}{ \var{vector} \dotsfoo}{procedure}}

Returns a newly allocated vector whose elements are the concatenation
of the elements of the given vectors.

\begin{scheme}
(vector-append \#(a b c) \#(d e f)) \lev \#(a b c d e f)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-fill!}{ vector fill}{procedure}
\rproto{vector-fill!}{ vector fill start}{procedure}
\rproto{vector-fill!}{ vector fill start end}{procedure}}

The {\cf vector-fill!} procedure stores \var{fill}
in the elements of \var{vector}
between \var{start} and \var{end}.

\begin{scheme}
(define a (vector 1 2 3 4 5))
(vector-fill! a 'smash 2 4)
a \lev \#(1 2 smash smash 5)%
\end{scheme}

\end{entry}


\section{Bytevectors}
\label{bytevectorsection}

\defining{Bytevectors} represent blocks of binary data.
They are fixed-length sequences of bytes, where
a \defining{byte} is an exact integer in the range from 0 to 255 inclusive.
A bytevector is typically more space-efficient than a vector
containing the same values.

\vest The {\em length} of a bytevector is the number of elements that it
contains.  This number is a non-negative integer that is fixed when
the bytevector is created.  The {\em valid indexes}\index{valid indexes} of
a bytevector are the exact non-negative integers less than the length of the
bytevector, starting at index zero as with vectors.

Bytevectors are written using the notation {\tt\#u8(\var{byte} \dotsfoo)}.
For example, a bytevector of length 3 containing the byte 0 in element
0, the byte 10 in element 1, and the byte 5 in
element 2 can be written as follows:

\begin{scheme}
\#u8(0 10 5)%
\end{scheme}

Bytevector constants are self-evaluating, so they do not need to be quoted in programs.


\begin{entry}{%
\proto{bytevector?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a bytevector.
Otherwise, \schfalse{} is returned.
\end{entry}

\begin{entry}{%
\proto{make-bytevector}{ k}{procedure}
\rproto{make-bytevector}{ k byte}{procedure}}

The {\cf make-bytevector} procedure returns a newly allocated bytevector of
length \vr{k}.  If \var{byte} is given, then all elements of the bytevector
are initialized to \var{byte}, otherwise the contents of each
element are unspecified.

\begin{scheme}
(make-bytevector 2 12) \ev \#u8(12 12)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{bytevector}{ \var{byte} \dotsfoo}{procedure}}

Returns a newly allocated bytevector containing its arguments.

\begin{scheme}
(bytevector 1 3 5 1 3 5)        \ev  \#u8(1 3 5 1 3 5)
(bytevector)                          \ev  \#u8()%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector-length}{ bytevector}{procedure}}

Returns the length of \var{bytevector} in bytes as an exact integer.
\end{entry}

\begin{entry}{%
\proto{bytevector-u8-ref}{ bytevector k}{procedure}}

\domain{It is an error if \vr{k} is not a valid index of \var{bytevector}.}
Returns the \var{k}th byte of \var{bytevector}.

\begin{scheme}
(bytevector-u8-ref '\#u8(1 1 2 3 5 8 13 21)
            5)  \lev  8%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector-u8-set!}{ bytevector k byte}{procedure}}

\domain{It is an error if \vr{k} is not a valid index of \var{bytevector}.}
Stores \var{byte} as the \var{k}th byte of \var{bytevector}.
\begin{scheme}
(let ((bv (bytevector 1 2 3 4)))
  (bytevector-u8-set! bv 1 3)
  bv) \lev \#u8(1 3 3 4)%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector-copy}{ bytevector}{procedure}
\rproto{bytevector-copy}{ bytevector start}{procedure}
\rproto{bytevector-copy}{ bytevector start end}{procedure}}

Returns a newly allocated bytevector containing the bytes in \var{bytevector}
between \var{start} and \var{end}.

\begin{scheme}
(define a \#u8(1 2 3 4 5))
(bytevector-copy a 2 4)) \ev \#u8(3 4)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{bytevector-copy!}{ to at from}{procedure}
\rproto{bytevector-copy!}{ to at from start}{procedure}
\rproto{bytevector-copy!}{ to at from start end}{procedure}}

\domain{It is an error if \var{at} is less than zero or greater than the length of \var{to}.
It is also an error if {\cf (- (bytevector-length \var{to}) \var{at})}
is less than {\cf (- \var{end} \var{start})}.}
Copies the bytes of bytevector \var{from} between \var{start} and \var{end}
to bytevector \var{to}, starting at \var{at}.  The order in which bytes are
copied is unspecified, except that if the source and destination overlap,
copying takes place as if the source is first copied into a temporary
bytevector and then into the destination.  This can be achieved without
allocating storage by making sure to copy in the correct direction in
such circumstances.

\begin{scheme}
(define a (bytevector 1 2 3 4 5))
(define b (bytevector 10 20 30 40 50))
(bytevector-copy! b 1 a 0 2)
b \ev \#u8(10 1 2 40 50)%
\end{scheme}

\begin{note}
This procedure appears in \rsixrs, but places the source before the destination,
contrary to other such procedures in Scheme.
\end{note}

\end{entry}

\begin{entry}{%
\proto{bytevector-append}{ \var{bytevector} \dotsfoo}{procedure}}

Returns a newly allocated bytevector whose elements are the concatenation
of the elements in the given bytevectors.

\begin{scheme}
(bytevector-append \#u8(0 1 2) \#u8(3 4 5)) \lev \#u8(0 1 2 3 4 5)%
\end{scheme}

\end{entry}

\label{utf8tostring}
\begin{entry}{%
\proto{utf8->string}{ bytevector} {procedure}
\rproto{utf8->string}{ bytevector start} {procedure}
\rproto{utf8->string}{ bytevector start end} {procedure}
\proto{string->utf8}{ string} {procedure}
\rproto{string->utf8}{ string start} {procedure}
\rproto{string->utf8}{ string start end} {procedure}}

\domain{It is an error for \var{bytevector} to contain invalid UTF-8 byte sequences.}
These procedures translate between strings and bytevectors
that encode those strings using the UTF-8 encoding.
The {\cf utf8\coerce{}string} procedure decodes the bytes of
a bytevector between \var{start} and \var{end}
and returns the corresponding string;
the {\cf string\coerce{}utf8} procedure encodes the characters of a
string between \var{start} and \var{end}
and returns the corresponding bytevector.

\begin{scheme}
(utf8->string \#u8(\#x41)) \ev "A"
(string->utf8 "$\lambda$") \ev \#u8(\#xCE \#xBB)%
\end{scheme}

\end{entry}

\section{Control features}
\label{proceduresection}
 
This section describes various primitive procedures which control the
flow of program execution in special ways.
Procedures in this section that invoke procedure arguments
always do so in the same dynamic environment as the call of the
original procedure.
The {\cf procedure?}\ predicate is also described here.

\begin{entry}{%
\proto{procedure?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is a procedure, otherwise returns \schfalse.

\begin{scheme}
(procedure? car)            \ev  \schtrue
(procedure? 'car)           \ev  \schfalse
(procedure? (lambda (x) (* x x)))   
                            \ev  \schtrue
(procedure? '(lambda (x) (* x x)))  
                            \ev  \schfalse
(call-with-current-continuation procedure?)
                            \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{apply}{ proc \vari{arg} $\ldots$ args}{procedure}}

The {\cf apply} procedure calls \var{proc} with the elements of the list
{\cf(append (list \vari{arg} \dotsfoo) \var{args})} as the actual
arguments.

\begin{scheme}
(apply + (list 3 4))              \ev  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)              \ev  30%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{map}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{It is an error if \var{proc} does not
accept as many arguments as there are {\it list}s
and return a single value.}
The {\cf map} procedure applies \var{proc} element-wise to the elements of the
\var{list}s and returns a list of the results, in order.
If more than one \var{list} is given and not all lists have the same length,
{\cf map} terminates when the shortest list runs out.
The \var{list}s can be circular, but it is an error if all of them are circular.
It is an error for \var{proc} to mutate any of the lists.
The dynamic order in which \var{proc} is applied to the elements of the
\var{list}s is unspecified.  If multiple returns occur from {\cf map},
the values returned by earlier returns are not mutated.

\begin{scheme}
(map cadr '((a b) (d e) (g h)))   \lev  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                \lev  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6 7))         \ev  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                 \ev  (1 2) \var{or} (2 1)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{string-map}{ proc \vari{string} \varii{string} \dotsfoo}{procedure}}
\label{stringmap}

\domain{It is an error if \var{proc} does not
accept as many arguments as there are {\it string}s
and return a single character.}
The {\cf string-map} procedure applies \var{proc} element-wise to the elements of the
\var{string}s and returns a string of the results, in order.
If more than one \var{string} is given and not all strings have the same length,
{\cf string-map} terminates when the shortest string runs out.
The dynamic order in which \var{proc} is applied to the elements of the
\var{string}s is unspecified.
If multiple returns occur from {\cf string-map},
the values returned by earlier returns are not mutated.

\begin{scheme}
(string-map char-foldcase "AbdEgH") \lev  "abdegh"

(string-map
 (lambda (c)
   (integer->char (+ 1 (char->integer c))))
 "HAL")                \lev  "IBM"

(string-map
 (lambda (c k)
   ((if (eqv? k \sharpsign\backwhack{}u) char-upcase char-downcase)
    c))
 "studlycaps xxx"
 "ululululul")   \lev   "StUdLyCaPs"%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-map}{ proc \vari{vector} \varii{vector} \dotsfoo}{procedure}}

\domain{It is an error if \var{proc} does not
accept as many arguments as there are {\it vector}s
and return a single value.}
The {\cf vector-map} procedure applies \var{proc} element-wise to the elements of the
\var{vector}s and returns a vector of the results, in order.
If more than one \var{vector} is given and not all vectors have the same length,
{\cf vector-map} terminates when the shortest vector runs out.
The dynamic order in which \var{proc} is applied to the elements of the
\var{vector}s is unspecified.
If multiple returns occur from {\cf vector-map},
the values returned by earlier returns are not mutated.

\begin{scheme}
(vector-map cadr '\#((a b) (d e) (g h)))   \lev  \#(b e h)

(vector-map (lambda (n) (expt n n))
            '\#(1 2 3 4 5))                \lev  \#(1 4 27 256 3125)

(vector-map + '\#(1 2 3) '\#(4 5 6 7))       \lev  \#(5 7 9)

(let ((count 0))
  (vector-map
   (lambda (ignored)
     (set! count (+ count 1))
     count)
   '\#(a b)))                     \ev  \#(1 2) \var{or} \#(2 1)%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{for-each}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{It is an error if \var{proc} does not
accept as many arguments as there are {\it list}s.}
The arguments to {\cf for-each} are like the arguments to {\cf map}, but
{\cf for-each} calls \var{proc} for its side effects rather than for its
values.  Unlike {\cf map}, {\cf for-each} is guaranteed to call \var{proc} on
the elements of the \var{list}s in order from the first element(s) to the
last, and the value returned by {\cf for-each} is unspecified.
If more than one \var{list} is given and not all lists have the same length,
{\cf for-each} terminates when the shortest list runs out.
The \var{list}s can be circular, but it is an error if all of them are circular.

It is an error for \var{proc} to mutate any of the lists.

\begin{scheme}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                                \ev  \#(0 1 4 9 16)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{string-for-each}{ proc \vari{string} \varii{string} \dotsfoo}{procedure}}

\domain{It is an error if \var{proc} does not
accept as many arguments as there are {\it string}s.}
The arguments to {\cf string-for-each} are like the arguments to {\cf
string-map}, but {\cf string-for-each} calls \var{proc} for its side
effects rather than for its values.  Unlike {\cf string-map}, {\cf
string-for-each} is guaranteed to call \var{proc} on the elements of
the \var{list}s in order from the first element(s) to the last, and the
value returned by {\cf string-for-each} is unspecified.
If more than one \var{string} is given and not all strings have the same length,
{\cf string-for-each} terminates when the shortest string runs out.
It is an error for \var{proc} to mutate any of the strings.

\begin{scheme}
(let ((v '()))
  (string-for-each
   (lambda (c) (set! v (cons (char->integer c) v)))
   "abcde")
  v)                         \ev  (101 100 99 98 97)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-for-each}{ proc \vari{vector} \varii{vector} \dotsfoo}{procedure}}

\domain{It is an error if \var{proc} does not
accept as many arguments as there are {\it vector}s.}
The arguments to {\cf vector-for-each} are like the arguments to {\cf
vector-map}, but {\cf vector-for-each} calls \var{proc} for its side
effects rather than for its values.  Unlike {\cf vector-map}, {\cf
vector-for-each} is guaranteed to call \var{proc} on the elements of
the \var{vector}s in order from the first element(s) to the last, and
the value returned by {\cf vector-for-each} is unspecified.
If more than one \var{vector} is given and not all vectors have the same length,
{\cf vector-for-each} terminates when the shortest vector runs out.
It is an error for \var{proc} to mutate any of the vectors.

\begin{scheme}
(let ((v (make-list 5)))
  (vector-for-each
   (lambda (i) (list-set! v i (* i i)))
   '\#(0 1 2 3 4))
  v)                                \ev  (0 1 4 9 16)%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{call-with-current-continuation}{ proc}{procedure}
\proto{call/cc}{ proc}{procedure}}

\label{continuations} \domain{It is an error if \var{proc} does not accept one
argument.}
The procedure {\cf call-with-current-continuation} (or its
equivalent abbreviation {\cf call/cc}) packages
the current continuation (see the rationale below) as an ``escape
procedure''\mainindex{escape procedure} and passes it as an argument to
\var{proc}.
The escape procedure is a Scheme procedure that, if it is
later called, will abandon whatever continuation is in effect at that later
time and will instead use the continuation that was in effect
when the escape procedure was created.  Calling the escape procedure
will cause the invocation of \var{before} and \var{after} thunks installed using
\ide{dynamic-wind}.

The escape procedure accepts the same number of arguments as the continuation to
the original call to \callcc.
Most continuations take only one value.
Continuations created by the {\cf call-with-values}
procedure (including the initialization expressions of
{\cf define-values}, {\cf let-values}, and {\cf let*-values} expressions),
take the number of values that the consumer expects.
The continuations of all non-final expressions within a sequence
of expressions, such as in {\cf lambda}, {\cf case-lambda}, {\cf begin},
{\cf let}, {\cf let*}, {\cf letrec}, {\cf letrec*}, {\cf let-values}, 
{\cf let*-values}, {\cf let-syntax}, {\cf letrec-syntax}, {\cf parameterize},
{\cf guard}, {\cf case}, {\cf cond}, {\cf when}, and {\cf unless} expressions,
take an arbitrary number of values because they discard the values passed
to them in any event.
The effect of passing no values or more than one value to continuations
that were not created in one of these ways is unspecified.


\vest The escape procedure that is passed to \var{proc} has
unlimited extent just like any other procedure in Scheme.  It can be stored
in variables or data structures and can be called as many times as desired.
However, like the {\cf raise} and {\cf error} procedures, it never
returns to its caller.

\vest The following examples show only the simplest ways in which
{\cf call-with-current-continuation} is used.  If all real uses were as
simple as these examples, there would be no need for a procedure with
the power of {\cf call-with-current-continuation}.

\begin{scheme}
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    \schtrue))                        \ev  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return \schfalse))))))
          (r obj))))))

(list-length '(1 2 3 4))            \ev  4

(list-length '(a b . c))            \ev  \schfalse%
\end{scheme}

\begin{rationale}

\vest A common use of {\cf call-with-current-continuation} is for
structured, non-local exits from loops or procedure bodies, but in fact
{\cf call-with-current-continuation} is useful for implementing a
wide variety of advanced control structures.
In fact, {\cf raise} and {\cf guard} provide a more structured mechanism
for non-local exits.

\vest Whenever a Scheme expression is evaluated there is a
\defining{continuation} wanting the result of the expression.  The continuation
represents an entire (default) future for the computation.  If the expression is
evaluated at the REPL, for example, then the continuation might take the
result, print it on the screen, prompt for the next input, evaluate it, and
so on forever.  Most of the time the continuation includes actions
specified by user code, as in a continuation that will take the result,
multiply it by the value stored in a local variable, add seven, and give
the answer to the REPL's continuation to be printed.  Normally these
ubiquitous continuations are hidden behind the scenes and programmers do not
think much about them.  On rare occasions, however, a programmer
needs to deal with continuations explicitly.
The {\cf call-with-current-continuation} procedure allows Scheme programmers to do
that by creating a procedure that acts just like the current
continuation.

% \vest Most programming languages incorporate one or more special-purpose
% escape constructs with names like {\tt exit}, \hbox{{\cf return}}, or
% even {\tt goto}.  In 1965, however, Peter Landin~\cite{Landin65}
% invented a general purpose escape operator called the J-operator.  John
% Reynolds~\cite{Reynolds72} described a simpler but equally powerful
% construct in 1972.  The {\cf catch} syntax described by Sussman
% and Steele in the 1975 report on Scheme is exactly the same as
% Reynolds's construct, though its name came from a less general construct
% in MacLisp.  Several Scheme implementers noticed that the full power of
% \ide{catch} could be provided by a procedure instead of by a
% special syntactic construct, and the name
% {\cf call-with-current-continuation} was coined in 1982.  This name is
% descriptive, but opinions differ on the merits of such a long name, and
% some people prefer the name \ide{call/cc} instead.
\todo{Shinn: Expand this history before restoring, possibly relegating to an appendix.}
\end{rationale}

%% \begin{note}
%% The {\cf call/cc} procedure is capable of capturing continuations
%% originating outside of Scheme when Scheme is embedded in some host
%% language. It is not always practical or even meaningful to restore
%% these continuations.
%% \end{note}
\todo{Shinn: I'm not sure we want to say anything about this.}

%% \begin{note}
%% The interactions of \callcc{} with {\cf dynamic-wind} are defined by
%% the formal semantics, but are hard to understand in complex cases.  In
%% addition, in some implementations \callcc{} consumes an amount of
%% memory that depends on the number of active continuations.
%% \end{note}
\end{entry}

\begin{entry}{%
\proto{values}{ obj $\ldots$}{procedure}}

Delivers all of its arguments to its continuation.
The {\tt values} procedure might be defined as follows:
\begin{scheme}
(define (values . things)
  (call-with-current-continuation 
    (lambda (cont) (apply cont things))))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{call-with-values}{ producer consumer}{procedure}}

Calls its \var{producer} argument with no arguments and
a continuation that, when passed some values, calls the
\var{consumer} procedure with those values as arguments.
The continuation for the call to \var{consumer} is the
continuation of the call to {\tt call-with-values}.

\begin{scheme}
(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
                                                   \ev  5

(call-with-values * -)                             \ev  -1%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{dynamic-wind}{ before thunk after}{procedure}}

Calls \var{thunk} without arguments, returning the result(s) of this call.
\var{Before} and \var{after} are called, also without arguments, as required
by the following rules.  Note that, in the absence of calls to continuations
captured using \ide{call-with-current-continuation}, the three arguments are
called once each, in order.  \var{Before} is called whenever execution
enters the dynamic extent of the call to \var{thunk} and \var{after} is called
whenever it exits that dynamic extent.  The dynamic extent of a procedure
call is the period between when the call is initiated and when it
returns.
The \var{before} and \var{after} thunks are called in the same dynamic
environment as the call to {\cf dynamic-wind}.
In Scheme, because of {\cf call-with-current-continuation}, the
dynamic extent of a call is not always a single, connected time period.
It is defined as follows:
\begin{itemize}
\item The dynamic extent is entered when execution of the body of the
called procedure begins.

\item The dynamic extent is also entered when execution is not within
the dynamic extent and a continuation is invoked that was captured
(using {\cf call-with-current-continuation}) during the dynamic extent.

\item It is exited when the called procedure returns.

\item It is also exited when execution is within the dynamic extent and
a continuation is invoked that was captured while not within the
dynamic extent.
\end{itemize}

If a second call to {\cf dynamic-wind} occurs within the dynamic extent of the
call to \var{thunk} and then a continuation is invoked in such a way that the
\var{after}s from these two invocations of {\cf dynamic-wind} are both to be
called, then the \var{after} associated with the second (inner) call to
{\cf dynamic-wind} is called first.

If a second call to {\cf dynamic-wind} occurs within the dynamic extent of the
call to \var{thunk} and then a continuation is invoked in such a way that the
\var{before}s from these two invocations of {\cf dynamic-wind} are both to be
called, then the \var{before} associated with the first (outer) call to
{\cf dynamic-wind} is called first.

If invoking a continuation requires calling the \var{before} from one call
to {\cf dynamic-wind} and the \var{after} from another, then the \var{after}
is called first.

\todo{consider removing unspecified effect}
The effect of using a captured continuation to enter or exit the dynamic
extent of a call to \var{before} or \var{after} is unspecified.

\begin{scheme}
(let ((path '())
      (c \#f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call-with-current-continuation
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
    \lev (connect talk1 disconnect
               connect talk2 disconnect)%
\end{scheme}
\end{entry}

\section{Exceptions}
\label{exceptionsection}

This section describes Scheme's exception-handling and
exception-raising procedures.
For the concept of Scheme exceptions, see section~\ref{errorsituations}.
See also \ref{guard} for the {\cf guard} syntax.

\defining{Exception handler}s are one-argument procedures that determine the
action the program takes when an exceptional situation is signaled.
The system implicitly maintains a current exception handler
in the dynamic environment.

\index{current exception handler}The program raises an exception by
invoking the current exception handler, passing it an object
encapsulating information about the exception.  Any procedure
accepting one argument can serve as an exception handler and any
object can be used to represent an exception.

\begin{entry}{%
\proto{with-exception-handler}{ \var{handler} \var{thunk}}{procedure}}

\domain{It is an error if \var{handler} does not accept one argument.
It is also an error if \var{thunk} does not accept zero arguments.}
The {\cf with-exception-handler} procedure returns the results of invoking
\var{thunk}.  \var{Handler} is installed as the current
exception handler 
in the dynamic environment used for the invocation of \var{thunk}.

\begin{scheme}
(call-with-current-continuation
 (lambda (k)
  (with-exception-handler
   (lambda (x)
    (display "condition: ")
    (write x)
    (newline)
    (k 'exception))
   (lambda ()
    (+ 1 (raise 'an-error))))))
        \ev exception
 \>{\em and prints}  condition: an-error

(with-exception-handler
 (lambda (x)
  (display "something went wrong\backwhack{}n"))
 (lambda ()
  (+ 1 (raise 'an-error))))
 \>{\em prints}  something went wrong%
\end{scheme}

After printing, the second example then raises another exception.
\end{entry}

\begin{entry}{%
\proto{raise}{ \var{obj}}{procedure}}

Raises an exception by invoking the current exception
handler on \var{obj}. The handler is called with the same
dynamic environment as that of the call to {\cf raise}, except that
the current exception handler is the one that was in place when the
handler being called was installed.  If the handler returns, a secondary
exception is raised in the same dynamic environment as the handler.
The relationship between \var{obj} and the object raised by
the secondary exception is unspecified.
\end{entry}

\begin{entry}{%
\proto{raise-continuable}{ \var{obj}}{procedure}}

Raises an exception by invoking the current
exception handler on \var{obj}. The handler is called with
the same dynamic environment as the call to
{\cf raise-continuable}, except that: (1) the current
exception handler is the one that was in place when the handler being
called was installed, and (2) if the handler being called returns,
then it will again become the current exception handler.  If the
handler returns, the values it returns become the values returned by
the call to {\cf raise-continuable}.
\end{entry}

\begin{scheme}
(with-exception-handler
  (lambda (con)
    (cond
      ((string? con)
       (display con))
      (else
       (display "a warning has been issued")))
    42)
  (lambda ()
    (+ (raise-continuable "should be a number")
       23)))
   {\it prints:} should be a number
   \ev 65%
\end{scheme}

\begin{entry}{%
\proto{error}{ \var{message} \var{obj} $\ldots$}{procedure}}

\domain{\var{Message} should be a string.}
Raises an exception as if by calling
{\cf raise} on a newly allocated implementation-defined object which encapsulates
the information provided by \var{message},
as well as any \var{obj}s, known as the \defining{irritants}.
The procedure {\cf error-object?} must return \schtrue{} on such objects.

\begin{scheme}
(define (null-list? l)
  (cond ((pair? l) \#f)
        ((null? l) \#t)
        (else
          (error
            "null-list?: argument out of domain"
            l))))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{error-object?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is an object created by {\cf error} 
or one of an implementation-defined set of objects.  Otherwise, it returns
\schfalse.  
The objects used to signal errors, including those which satisfy the
predicates {\cf file-error?} and {\cf read-error?}, may or may not
satisfy {\cf error-object?}.

\end{entry}

\begin{entry}{%
\proto{error-object-message}{ error-object}{procedure}}

Returns the message encapsulated by \var{error-object}.

\end{entry}

\begin{entry}{%
\proto{error-object-irritants}{ error-object}{procedure}}

Returns a list of the irritants encapsulated by \var{error-object}.

\end{entry}

\begin{entry}{%
\proto{read-error?}{ obj}{procedure}
\proto{file-error?}{ obj}{procedure}}

Error type predicates.  Returns \schtrue{} if \var{obj} is an
object raised by the {\cf read} procedure or by the inability to open
an input or output port on a file, respectively.  Otherwise, it
returns \schfalse.
% Not required to be an error object.

\end{entry}

\section{Environments and evaluation}

\begin{entry}{%
\proto{environment}{ \vri{list} \dotsfoo}{eval library procedure}}
\label{environments}

This procedure returns a specifier for the environment that results by
starting with an empty environment and then importing each \var{list},
considered as an import set, into it.  (See section~\ref{libraries} for
a description of import sets.)  The bindings of the environment
represented by the specifier are immutable, as is the environment itself.

\end{entry}

\begin{entry}{%
\proto{scheme-report-environment}{ version}{r5rs library procedure}}

If \var{version} is equal to {\cf 5},
corresponding to \rfivers,
{\cf scheme-report-environment} returns a specifier for an
environment that contains only the bindings
defined in the \rfivers\ library.
Implementations must support this value of \var{version}.

Implementations may also support other values of \var{version}, in which
case they return a specifier for an environment containing bindings corresponding to the specified version of the report.
If \var{version}
is neither {\cf 5} nor another value supported by
the implementation, an error is signaled.

\todo{consider removing unspecified effect}
The effect of defining or assigning (through the use of {\cf eval})
an identifier bound in a {\cf scheme-report-environment} (for example
{\cf car}) is unspecified.  Thus both the environment and the bindings
it contains may be immutable.

\end{entry}

\begin{entry}{%
\proto{null-environment}{ version}{r5rs library procedure}}

If \var{version} is equal to {\cf 5},
corresponding to \rfivers,
the {\cf null-environment} procedure returns
a specifier for an environment that contains only the
bindings for all syntactic keywords
defined in the \rfivers\ library.
Implementations must support this value of \var{version}.

Implementations may also support other values of \var{version}, in which
case they return a specifier for an environment containing appropriate bindings corresponding to the specified version of the report.
If \var{version}
is neither {\cf 5} nor another value supported by
the implementation, an error is signaled.

The effect of defining or assigning (through the use of {\cf eval})
an identifier bound in a {\cf scheme-report-environment} (for example
{\cf car}) is unspecified.  Thus both the environment and the bindings
it contains may be immutable.

\end{entry}

\begin{entry}{%
\proto{interaction-environment}{}{repl library procedure}}

This procedure returns a specifier for a mutable environment that contains an
imple\-men\-ta\-tion-defined set of bindings, typically a superset of
those exported by {\cf(scheme base)}.  The intent is that this procedure
will return the environment in which the implementation would evaluate
expressions entered by the user into a REPL.

\end{entry}

\begin{entry}{%
\proto{eval}{ expr-or-def environment-specifier}{eval library procedure}}

If \var{expr-or-def} is an expression, it is evaluated in the
specified environment and its values are returned.
If it is a definition, the specified identifier(s) are defined in the specified
environment, provided the environment is not immutable.
Implementations may extend {\cf eval} to allow other objects.

\begin{scheme}
(eval '(* 7 3) (environment '(scheme base)))
                                                   \ev  21

(let ((f (eval '(lambda (f x) (f x x))
               (null-environment 5))))
  (f + 10))
                                                   \ev  20
(eval '(define foo 32)
      (environment '(scheme base)))
                                                   \ev {\it{} error is signaled}%
\end{scheme}

\end{entry}

\section{Input and output}

\subsection{Ports}
\label{portsection}

Ports represent input and output devices.  To Scheme, an input port is
a Scheme object that can deliver data upon command, while an output
port is a Scheme object that can accept data.\mainindex{port}
Whether the input and output port types are disjoint is
implementation-dependent.

Different {\em port types} operate on different data.  Scheme
imple\-men\-ta\-tions are required to support {\em textual ports}
and {\em binary ports}, but may also provide other port types.

A textual port supports reading or writing of individual characters
from or to a backing store containing characters
using {\cf read-char} and {\cf write-char} below, and it supports operations
defined in terms of characters, such as {\cf read} and {\cf write}.

A binary port supports reading or writing of individual bytes from
or to a backing store containing bytes using {\cf read-u8} and {\cf
write-u8} below, as well as operations defined in terms of bytes.
Whether the textual and binary port types are disjoint is
implementation-dependent.

Ports can be used to access files, devices, and similar things on the host
system on which the Scheme program is running.

\begin{entry}{%
\proto{call-with-port}{ port proc}{procedure}}

\domain{It is an error if \var{proc} does not accept one argument.}
The {\cf call-with-port}
procedure calls \var{proc} with \var{port} as an argument.  
If \var{proc} returns,
then the port is closed automatically and the values yielded by the
\var{proc} are returned.  If \var{proc} does not return, then 
the port must not be closed automatically unless it is possible to
prove that the port will never again be used for a read or write
operation.

\begin{rationale}
Because Scheme's escape procedures have unlimited extent, it  is
possible to escape from the current continuation but later to resume it. 
If implementations were permitted to close the port on any escape from the
current continuation, then it would be impossible to write portable code using
both {\cf call-with-current-continuation} and {\cf call-with-port}.
\end{rationale} 

\end{entry}

\begin{entry}{%
\proto{call-with-input-file}{ string proc}{file library procedure}
\proto{call-with-output-file}{ string proc}{file library procedure}}

\domain{It is an error if \var{proc} does not accept one argument.}
These procedures obtain a
textual port obtained by opening the named file for input or output
as if by {\cf open-input-file} or {\cf open-output-file}.  
The port and \var{proc} are then passed to a procedure equivalent
to {\cf call-with-port}.
\end{entry}

\begin{entry}{%
\proto{input-port?}{ obj}{procedure}
\proto{output-port?}{ obj}{procedure}
\proto{textual-port?}{ obj}{procedure}
\proto{binary-port?}{ obj}{procedure}
\proto{port?}{ obj}{procedure}}

These procedures return \schtrue{} if \var{obj} is an input port, output port, 
textual port, binary port, or any
kind of port, respectively.  Otherwise they return \schfalse.

\end{entry}


\begin{entry}{%
\proto{input-port-open?}{ port}{procedure}
\proto{output-port-open?}{ port}{procedure}}

Returns \schtrue{} if \var{port} is still open and capable of
performing input or output, respectively, and \schfalse{} otherwise.


\end{entry}


\begin{entry}{%
\proto{current-input-port}{}{procedure}
\proto{current-output-port}{}{procedure}
\proto{current-error-port}{}{procedure}}

Returns the current default input port, output port, or error port (an
output port), respectively.  These procedures are parameter objects, which can be
overridden with {\cf parameterize} (see
section~\ref{make-parameter}).  The initial bindings for these
are implementation-defined textual ports.

\end{entry}


\begin{entry}{%
\proto{with-input-from-file}{ string thunk}{file library procedure}
\proto{with-output-to-file}{ string thunk}{file library procedure}}

The file is opened for input or output
as if by {\cf open-input-file} or {\cf open-output-file}, 
and the new port is made to be the value returned by
{\cf current-input-port} or {\cf current-output-port}
(as used by {\tt (read)}, {\tt (write \var{obj})}, and so forth).
The \var{thunk} is then called with no arguments.  When the \var{thunk} returns,
the port is closed and the previous default is restored.
It is an error if \var{thunk} does not accept zero arguments.
Both procedures return the values yielded by \var{thunk}.
If an escape procedure
is used to escape from the continuation of these procedures, they
behave exactly as if the current input or output port had been bound
dynamically with {\cf parameterize}.


\end{entry}


\begin{entry}{%
\proto{open-input-file}{ string}{file library procedure}
\proto{open-binary-input-file}{ string}{file library procedure}}
 
Takes a \var{string} for an existing file and returns a textual
input port or binary input port that is capable of delivering data from the
file.  If the file does not exist or cannot be opened, an error that satisfies {\cf file-error?} is signaled.

\end{entry}


\begin{entry}{%
\proto{open-output-file}{ string}{file library procedure}
\proto{open-binary-output-file}{ string}{file library procedure}}

Takes a \var{string} naming an output file to be created and returns a
textual output port or binary output port that is capable of writing
data to a new file by that name.
\todo{consider removing unspecified effect}
If a file with the given name already exists,
the effect is unspecified.
If the file cannot be opened,
an error that satisfies {\cf file-error?} is signaled.

\end{entry}


\begin{entry}{%
\proto{close-port}{ port}{procedure}
\proto{close-input-port}{ port}{procedure}
\proto{close-output-port}{ port}{procedure}}

Closes the resource associated with \var{port}, rendering the \var{port}
incapable of delivering or accepting data.  
It is an error
to apply the last two procedures to a port which is not an input
or output port, respectively.
Scheme implementations may provide ports which are simultaneously
input and output ports, such as sockets; the {\cf close-input-port}
and {\cf close-output-port} procedures can then be used to close the
input and output sides of the port independently.

These routines have no effect if the port has already been closed.


\end{entry}

\begin{entry}{%
\proto{open-input-string}{ string}{procedure}}

Takes a string and returns a textual input port that delivers
characters from the string.
If the string is modified, the effect is unspecified.

\end{entry}

\begin{entry}{%
\proto{open-output-string}{}{procedure}}

Returns a textual output port that will accumulate characters for
retrieval by {\cf get-output-string}.

\end{entry}

\begin{entry}{%
\proto{get-output-string}{ port}{procedure}}

\domain{It is an error if \var{port} was not created with
{\cf open-output-string}.}
Returns a string consisting of the
characters that have been output to the port so far in the order they
were output.
If the result string is modified, the effect is unspecified.

\begin{scheme}
(parameterize
    ((current-output-port
      (open-output-string)))
    (display "piece")
    (display " by piece ")
    (display "by piece.")
    (newline)
    (get-output-string (current-output-port)))
\lev "piece by piece by piece.\backwhack{}n"%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{open-input-bytevector}{ bytevector}{procedure}}

Takes a bytevector and returns a binary input port that delivers
bytes from the bytevector.

\end{entry}

\begin{entry}{%
\proto{open-output-bytevector}{}{procedure}}

Returns a binary output port that will accumulate bytes for
retrieval by {\cf get-output-bytevector}.

\end{entry}

\begin{entry}{%
\proto{get-output-bytevector}{ port}{procedure}}

\domain{It is an error if \var{port} was not created with
{\cf open-output-bytevector}.}  Returns a bytevector consisting
of the bytes that have been output to the port so far in the
order they were output.
\end{entry}


\subsection{Input}
\label{inputsection}

If \var{port} is omitted from any input procedure, it defaults to the
value returned by {\cf (current-input-port)}.
It is an error to attempt an input operation on a closed port.

\noindent \hbox{ }  %???
\vspace{-5ex}


\begin{entry}{%
\proto{read}{}{read library procedure}
\rproto{read}{ port}{read library procedure}}

The {\cf read} procedure converts external representations of Scheme objects into the
objects themselves.  That is, it is a parser for the non-terminal
\meta{datum} (see sections~\ref{datum} and
\ref{listsection}).  It returns the next
object parsable from the given textual input \var{port}, updating
\var{port} to point to
the first character past the end of the external representation of the object.

Implementations may support extended syntax to represent record types or
other types that do not have datum representations.

\vest If an end of file is encountered in the input before any
characters are found that can begin an object, then an end-of-file
object is returned.  The port remains open, and further attempts
to read will also return an end-of-file object.  If an end of file is
encountered after the beginning of an object's external representation,
but the external representation is incomplete and therefore not parsable,
an error that satisfies {\cf read-error?} is signaled.

\end{entry}

\begin{entry}{%
\proto{read-char}{}{procedure}
\rproto{read-char}{ port}{procedure}}

Returns the next character available from the textual input \var{port},
updating
the \var{port} to point to the following character.  If no more characters
are available, an end-of-file object is returned.  

\end{entry}


\begin{entry}{%
\proto{peek-char}{}{procedure}
\rproto{peek-char}{ port}{procedure}}

Returns the next character available from the textual input \var{port},
but {\em without} updating
the \var{port} to point to the following character.  If no more characters
are available, an end-of-file object is returned.  

\begin{note}
The value returned by a call to {\cf peek-char} is the same as the
value that would have been returned by a call to {\cf read-char} with the
same \var{port}.  The only difference is that the very next call to
{\cf read-char} or {\cf peek-char} on that \var{port} will return the
value returned by the preceding call to {\cf peek-char}.  In particular, a call
to {\cf peek-char} on an interactive port will hang waiting for input
whenever a call to {\cf read-char} would have hung.
\end{note}

\end{entry}

\begin{entry}{%
\proto{read-line}{}{procedure}
\rproto{read-line}{ port}{procedure}}

Returns the next line of text available from the textual input
\var{port}, updating the \var{port} to point to the following character.
If an end of line is read, a string containing all of the text up to
(but not including) the end of line is returned, and the port is updated
to point just past the end of line. If an end of file is encountered
before any end of line is read, but some characters have been
read, a string containing those characters is returned. If an end of
file is encountered before any characters are read, an end-of-file
object is returned.  For the purpose of this procedure, an end of line
consists of either a linefeed character, a carriage return character, or a
sequence of a carriage return character followed by a linefeed character.
Implementations may also recognize other end of line characters or sequences.

\end{entry}


\begin{entry}{%
\proto{eof-object?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is an end-of-file object, otherwise returns
\schfalse.  The precise set of end-of-file objects will vary among
implementations, but in any case no end-of-file object will ever be an object
that can be read in using {\cf read}.

\end{entry}

\begin{entry}{%
\proto{eof-object}{}{procedure}}

Returns an end-of-file object, not necessarily unique.

\end{entry}


\begin{entry}{%
\proto{char-ready?}{}{procedure}
\rproto{char-ready?}{ port}{procedure}}

Returns \schtrue{} if a character is ready on the textual input \var{port} and
returns \schfalse{} otherwise.  If {\cf char-ready} returns \schtrue{} then
the next {\cf read-char} operation on the given \var{port} is guaranteed
not to hang.  If the \var{port} is at end of file then {\cf char-ready?}\
returns \schtrue.  

\begin{rationale}
The {\cf char-ready?} procedure exists to make it possible for a program to
accept characters from interactive ports without getting stuck waiting for
input.  Any input editors associated with such ports must ensure that
characters whose existence has been asserted by {\cf char-ready?}\ cannot
be removed from the input.  If {\cf char-ready?}\ were to return \schfalse{} at end of
file, a port at end of file would be indistinguishable from an interactive
port that has no ready characters.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{read-string}{ k}{procedure}
\rproto{read-string}{ k port}{procedure}}
\label{readstring}

Reads the next \var{k} characters, or as many as are available before the end of file,
from the textual
input \var{port} into a newly allocated string in left-to-right order
and returns the string.
If no characters are available before the end of file,
an end-of-file object is returned.

\end{entry}


\begin{entry}{%
\proto{read-u8}{}{procedure}
\rproto{read-u8}{ port}{procedure}}

Returns the next byte available from the binary input \var{port},
updating the \var{port} to point to the following byte.  
If no more bytes are
available, an end-of-file object is returned.  

\end{entry}

\begin{entry}{%
\proto{peek-u8}{}{procedure}
\rproto{peek-u8}{ port}{procedure}}

Returns the next byte available from the binary input \var{port},
but {\em without} updating the \var{port} to point to the following
byte.  If no more bytes are available, an end-of-file object is returned.  

\end{entry}

\begin{entry}{%
\proto{u8-ready?}{}{procedure}
\rproto{u8-ready?}{ port}{procedure}}

Returns \schtrue{} if a byte is ready on the binary input \var{port}
and returns \schfalse{} otherwise.  If {\cf u8-ready?} returns
\schtrue{} then the next {\cf read-u8} operation on the given
\var{port} is guaranteed not to hang.  If the \var{port} is at end of
file then {\cf u8-ready?}\ returns \schtrue.  

\end{entry}

\begin{entry}{%
\proto{read-bytevector}{ k}{procedure}
\rproto{read-bytevector}{ k port}{procedure}}

Reads the next \var{k} bytes, or as many as are available before the end of file,
from the binary
input \var{port} into a newly allocated bytevector in left-to-right order
and returns the bytevector.
If no bytes are available before the end of file,
an end-of-file object is returned.

\end{entry}

\begin{entry}{%
\proto{read-bytevector!}{ bytevector}{procedure}
\rproto{read-bytevector!}{ bytevector port}{procedure}
\rproto{read-bytevector!}{ bytevector port start}{procedure}
\rproto{read-bytevector!}{ bytevector port start end}{procedure}}

Reads the next $end - start$ bytes, or as many as are available
before the end of file,
from the binary
input \var{port} into \var{bytevector} in left-to-right order
beginning at the \var{start} position.  If \var{end} is not supplied,
reads until the end of \var{bytevector} has been reached.  If
\var{start} is not supplied, reads beginning at position 0.
Returns the number of bytes read.
If no bytes are available, an end-of-file object is returned.

\end{entry}


\subsection{Output}
\label{outputsection}

If \var{port} is omitted from any output procedure, it defaults to the
value returned by {\cf (current-output-port)}.
It is an error to attempt an output operation on a closed port.

\noindent \hbox{}
\vspace{-5ex}

\begin{entry}{%
\proto{write}{ obj}{write library procedure}
\rproto{write}{ obj port}{write library procedure}}

Writes a representation of \var{obj} to the given textual output
\var{port}.  Strings
that appear in the written representation are enclosed in quotation marks, and
within those strings backslash and quotation mark characters are
escaped by backslashes.  Symbols that contain non-ASCII characters
are escaped with vertical lines.
Character objects are written using the {\cf \#\backwhack} notation.

If \var{obj} contains cycles which would cause an infinite loop using
the normal written representation, then at least the objects that form
part of the cycle must be represented using datum labels as described
in section~\ref{labelsection}.  Datum labels must not be used if there
are no cycles.

Implementations may support extended syntax to represent record types or
other types that do not have datum representations.

The {\cf write} procedure returns an unspecified value.

\end{entry}

\begin{entry}{%
\proto{write-shared}{ obj}{write library procedure}
\rproto{write-shared}{ obj port}{write library procedure}}

The {\cf write-shared} procedure is the same as {\cf write}, except that
shared structure must be represented using datum labels for all pairs
and vectors that appear more than once in the output.

\end{entry}

\begin{entry}{%
\proto{write-simple}{ obj}{write library procedure}
\rproto{write-simple}{ obj port}{write library procedure}}

The {\cf write-simple} procedure is the same as {\cf write}, except that shared structure is
never represented using datum labels.  This can cause {\cf write-simple} not to
terminate if \var{obj} contains circular structure.

\end{entry}


\begin{entry}{%
\proto{display}{ obj}{write library procedure}
\rproto{display}{ obj port}{write library procedure}}

Writes a representation of \var{obj} to the given textual output \var{port}.
Strings that appear in the written representation are output as if by
{\cf write-string} instead of by {\cf write}.
Symbols are not escaped.  Character
objects appear in the representation as if written by {\cf write-char}
instead of by {\cf write}.

The {\cf display} representation of other objects is unspecified.
However, {\cf display} must not loop forever on 
self-referencing pairs, vectors, or records.  Thus if the
normal {\cf write} representation is used, datum labels are needed
to represent cycles as in {\cf write}.

Implementations may support extended syntax to represent record types or
other types that do not have datum representations.

The {\cf display} procedure returns an unspecified value.

\begin{rationale}
The {\cf write} procedure is intended
for producing mach\-ine-readable output and {\cf display} for producing
human-readable output.  
\end{rationale}
\end{entry}


\begin{entry}{%
\proto{newline}{}{procedure}
\rproto{newline}{ port}{procedure}}

Writes an end of line to textual output \var{port}.  Exactly how this
is done differs
from one operating system to another.  Returns an unspecified value.

\end{entry}


\begin{entry}{%
\proto{write-char}{ char}{procedure}
\rproto{write-char}{ char port}{procedure}}

Writes the character \var{char} (not an external representation of the
character) to the given textual output \var{port} and returns an unspecified
value.  

\end{entry}

\begin{entry}{%
\proto{write-string}{ string}{procedure}
\rproto{write-string}{ string port}{procedure}
\rproto{write-string}{ string port start}{procedure}
\rproto{write-string}{ string port start end}{procedure}}

Writes the characters of \var{string}
from \var{start} to \var{end}
in left-to-right order to the
textual output \var{port}.

\end{entry}

\begin{entry}{%
\proto{write-u8}{ byte}{procedure}
\rproto{write-u8}{ byte port}{procedure}}

Writes the \var{byte} to
the given binary output \var{port} and returns an unspecified value.

\end{entry}

\begin{entry}{%
\proto{write-bytevector}{ bytevector}{procedure}
\rproto{write-bytevector}{ bytevector port}{procedure}
\rproto{write-bytevector}{ bytevector port start}{procedure}
\rproto{write-bytevector}{ bytevector port start end}{procedure}}

Writes the bytes of \var{bytevector}
from \var{start} to \var{end}
in left-to-right order to the
binary output \var{port}.

\end{entry}

\begin{entry}{%
\proto{flush-output-port}{}{procedure}
\rproto{flush-output-port}{ port}{procedure}}

Flushes any buffered output from the buffer of output-port to the
underlying file or device and returns an unspecified value.

\end{entry}


\section{System interface}

Questions of system interface generally fall outside of the domain of this
report.  However, the following operations are important enough to
deserve description here.


\begin{entry}{%
\proto{load}{ filename}{load library procedure}
\rproto{load}{ filename environment-specifier}{load library procedure}}

\domain{It is an error if \var{filename} is not a string.}
An implementation-dependent operation is used to transform
\var{filename} into the name of an existing file
containing Scheme source code.  The {\cf load} procedure reads
expressions and definitions from the file and evaluates them
sequentially in the environment specified by \var{environment-specifier}.
If \var{environment-specifier} is omitted, {\cf (interaction-environment)}
is assumed.

It is unspecified whether the results of the expressions
are printed.  The {\cf load} procedure does not affect the values
returned by {\cf current-input-port} and {\cf current-output-port}.
It returns an unspecified value.


\begin{rationale}
For portability, {\cf load} must operate on source files.
Its operation on other kinds of files necessarily varies among
implementations.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{file-exists?}{ filename}{file library procedure}}

\domain{It is an error if \var{filename} is not a string.}
The {\cf file-exists?} procedure returns
\schtrue{} if the named file exists at the time the procedure is called,
and \schfalse{} otherwise.

\end{entry}

\begin{entry}{%
\proto{delete-file}{ filename}{file library procedure}}

\domain{It is an error if \var{filename} is not a string.}
The {\cf delete-file} procedure deletes the
named file if it exists and can be deleted, and returns an unspecified
value.  If the file does not exist or cannot be deleted, an error
that satisfies {\cf file-error?} is signaled.

\end{entry}

\begin{entry}{%
\proto{command-line}{}{process-context library procedure}}

Returns the command line passed to the process as a list of
strings.  The first string corresponds to the command name, and is
implementation-dependent.  It is an error to mutate any of these strings.
\end{entry}

\begin{entry}{%
\proto{exit}{}{process-context library procedure}
\rproto{exit}{ obj}{process-context library procedure}}

Runs all outstanding dynamic-wind \var{after} procedures, terminates the
running program, and communicates an exit value to the operating system.
If no argument is supplied, or if \var{obj} is \schtrue{}, the {\cf
exit} procedure should communicate to the operating system that the
program exited normally.  If \var{obj} is \schfalse{}, the {\cf exit}
procedure should communicate to the operating system that the program
exited abnormally.  Otherwise, {\cf exit} should translate \var{obj} into
an appropriate exit value for the operating system, if possible.

The {\cf exit} procedure
must not signal an exception or return to its continuation.

\begin{note}
Because of the requirement to run handlers, this procedure is not just the
operating system's exit procedure.
\end{note}

\end{entry}

\begin{entry}{%
\proto{emergency-exit}{}{process-context library procedure}
\rproto{emergency-exit}{ obj}{process-context library procedure}}

Terminates the program without running any
outstanding dynamic-wind \var{after} procedures
and communicates an exit value to the operating system
in the same manner as {\cf exit}.

\begin{note}
The {\cf emergency-exit} procedure corresponds to the {\cf \_exit} procedure
in Windows and Posix.
\end{note}

\end{entry}


\todo{Shinn: Do we need any description of what an environment variable is?}

\begin{entry}{%
\proto{get-environment-variable}{ name}{process-context library procedure}}

Many operating systems provide each running process with an
\defining{environment} consisting of \defining{environment variables}.
(This environment is not to be confused with the Scheme environments that
can be passed to {\cf eval}: see section~\ref{environments}.)
Both the name and value of an environment variable are strings.
The procedure {\cf get-environment-variable} returns the value 
of the environment variable \var{name},
or \schfalse{} if the named
environment variable is not found.  It may
use locale information to encode the name and decode the value
of the environment variable.  It is an error if \\
{\cf get-environment-variable} can't decode the value.
It is also an error to mutate the resulting string.

\begin{scheme}
(get-environment-variable "PATH") \lev "/usr/local/bin:/usr/bin:/bin"%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{get-environment-variables}{}{process-context library procedure}}

Returns the names and values of all the environment variables as an
alist, where the car of each entry is the name of an environment
variable and the cdr is its value, both as strings.  The order of the list is unspecified.
It is an error to mutate any of these strings or the alist itself.

\begin{scheme}
(get-environment-variables) \lev (("USER" . "root") ("HOME" . "/"))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{current-second}{}{time library procedure}}

Returns an inexact number representing the current time on the International Atomic
Time (TAI) scale.  The value 0.0 represents midnight
on January 1, 1970 TAI (equivalent to ten seconds before midnight Universal Time)
and the value 1.0 represents one TAI
second later.  Neither high accuracy nor high precision are required; in particular,
returning Coordinated Universal Time plus a suitable constant might be
the best an implementation can do.
\end{entry}

\begin{entry}{%
\proto{current-jiffy}{}{time library procedure}}

Returns the number of \defining{jiffies} as an exact integer that have elapsed since an arbitrary,
implementation-defined epoch. A jiffy is an implementation-defined
fraction of a second which is defined by the return value of the
{\cf jiffies-per-second} procedure. The starting epoch is guaranteed to be
constant during a run of the program, but may vary between runs.

\begin{rationale}
Jiffies are allowed to be implementation-dependent so that
{\cf current-jiffy} can execute with minimum overhead. It
should be very likely that a compactly represented integer will suffice
as the returned value.  Any particular jiffy size will be inappropriate
for some implementations: a microsecond is too long for a very fast
machine, while a much smaller unit would force many implementations to
return integers which have to be allocated for most calls, rendering 
{\cf current-jiffy} less useful for accurate timing measurements.
\end{rationale}

\end{entry}

\begin{entry}{%
\proto{jiffies-per-second}{}{time library procedure}}

Returns an exact integer representing the number of jiffies per SI
second. This value is an implementation-specified constant.

\begin{scheme}
(define (time-length)
  (let ((list (make-list 100000))
        (start (current-jiffy)))
    (length list)
    (/ (- (current-jiffy) start)
       (jiffies-per-second))))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{features}{}{procedure}}

Returns a list of the feature identifiers which {\cf cond-expand}
treats as true.  It is an error to modify this list.  Here is an
example of what {\cf features} might return:

\begin{scheme}
(features) \ev
  (r7rs ratios exact-complex full-unicode
   gnu-linux little-endian 
   fantastic-scheme
   fantastic-scheme-1.0
   space-ship-control-system)%
\end{scheme}
\end{entry}

