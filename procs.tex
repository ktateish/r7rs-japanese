% Initial environment

%\vfill\eject
\chapter{標準手続き}
\label{initialenv}
\label{builtinchapter}

\mainindex{initial environment}
\mainindex{global environment}
\mainindex{procedure}

この章ではSchemeの組み込み手続きを説明します。

{\cf force}、{\cf promise?}および{\cf make-promise}は
式型{\cf delay}および{\cf delay-force}と密接に関連しているため、\ref{force}~節で説明しています。
同様に、手続き{\cf make-parameter}は式型{\cf parameterize}と密接に関連しているため、
\ref{make-parameter}~節で説明しています。

\todo{consider removing unspecified effect}
プログラムは大域変数定義を用いて任意の変数を束縛出来ます。
それらの束縛は後に代入によって変更される場合があります(\ref{assignment}~節を参照)。
これらの操作がこの報告書で定義されている手続きの動作を変更することはありません。
また、ライブラリ(\ref{libraries}~節を参照)からインポートされた手続きの動作を変更することもありません。
定義によって導入されたものでない大域変数を変更した場合、
この章で定義されている手続きの動作に与える効果は規定されていません。

手続きが\defining{新しく割り当てられた}オブジェクトを返すと言うとき、
それはそのオブジェクトの場所が新しいという意味です。

\section{等値述語}
\label{equivalencesection}

常にブーリアン値(\schtrue{}または\schfalse)を返す手続きを\defining{述語}と呼びます。
\defining{等値述語}は数学の等値関係をコンピュータ的に真似たものです。
つまり、対称性を持ち、反射性を持ち、推移的です。
この節で説明している等値述語は、
{\cf eq?}が最も細く(最も識別性が高く)、
{\cf equal?}が最も粗く、
{\cf eqv?}がその中間です。


\begin{entry}{%
\proto{eqv?}{ \vari{obj} \varii{obj}}{procedure}}

{\cf eqv?}手続きはオブジェクトに対する有用な等値関係を定義します。
大まかに言うと、{\cf eqv?}は
\vari{obj}と\varii{obj}が普通に考えて同じオブジェクトである場合に
\schtrue{}を返します。
この関係は若干解釈の余地が残されていますが、
以下に述べる{\cf eqv?}の部分的仕様はすべてのScheme処理系において維持されています。


{\cf eqv?}は以下の場合に\schtrue{}を返します。

\begin{itemize}
\item \vari{obj}と\varii{obj}が共に\schtrue{}であるか、共に\schfalse{}である。

\item \vari{obj}と\varii{obj}が共にシンボルであり、
{\cf symbol=?}手続きによれば等しい(\ref{symbolsection}~節)。

\item \vari{obj}と\varii{obj}が共に正確な数値であり、
({\cf =}の意味で)数値的に等しい。

\item \vari{obj}と\varii{obj}が共に不正確な数値であり、
({\cf =}の意味で)数値的に等しく、
そしてScheme標準の数値計算手続き(ただしNaN値を返さない場合に限る)
の有限個の合成関数として定義することの出来る任意の他の手続きに
引数として渡したときに({\cf eqv?}の意味で)同じ結果を生成する。

\item \vari{obj}と\varii{obj}が共に文字であり、
{\cf char=?}手続きによれば同じ文字である(\ref{charactersection}~節)。

\item \vari{obj}と\varii{obj}が共に空リストである。

\item \vari{obj}と\varii{obj}がペア、ベクタ、バイトベクタ、レコードまたは文字列であり、
同じ格納場所を指し示す(\ref{storagemodel}~節)。

\item \vari{obj}と\varii{obj}が手続きであり、
同じ場所に紐付けられている(\ref{lambda}~節)。
\end{itemize}

{\cf eqv?}手続きは以下の場合に\schfalse{}を返します。

\begin{itemize}
\item \vari{obj}と\varii{obj}が異なる型である
(\ref{disjointness}~節)。

\item \vari{obj}または\varii{obj}の一方が\schtrue{}であり、
他方が\schfalse{}である。

\item \vari{obj}および\varii{obj}がシンボルであるが、
{\cf symbol=?}手続きによれば同じシンボルではない
(\ref{symbolsection}~節)。

\item \vari{obj}または\varii{obj}の一方が正確な整数であり、
他方が不正確な整数である。

\item \vari{obj}と\varii{obj}が共に正確な数値であるが、
({\cf =}の意味で)数値的に等しくない。

\item \vari{obj}と\varii{obj}が共に不正確な数値であり、
({\cf =}の意味で)数値的に等しくないか、
またはScheme標準の数値計算手続き(ただしNaN値を返さない場合に限る)
の有限個の合成関数として定義することの出来る任意の他の手続きに
引数として渡したときに({\cf eqv?}の意味で)同じ結果を生成しない。
例外として、\vari{obj}と\varii{obj}が共にNaNであるとき、
{\cf eqv?}の動作は規定されていません。

\item \vari{obj}および\varii{obj}が文字であり、
{\cf char=?}手続きが\schfalse{}を返す。

\item \vari{obj}または\varii{obj}の一方が空リストであり、他方がそうではない。

\item \vari{obj}および\varii{obj}がペア、ベクタ、バイトベクタ、レコードまたは文字列であり、
その指し示す場所が異なる。

\item \vari{obj}および\varii{obj}が手続きであり、
何らかの引数に対して異なる動作をする(異なる値を返すか、異なる副作用を持つ)。

\end{itemize}

\begin{scheme}
(eqv? 'a 'a)                     \ev  \schtrue
(eqv? 'a 'b)                     \ev  \schfalse
(eqv? 2 2)                       \ev  \schtrue
(eqv? 2 2.0)                     \ev  \schfalse
(eqv? '() '())                   \ev  \schtrue
(eqv? 100000000 100000000)       \ev  \schtrue
(eqv? 0.0 +nan.0)                \ev  \schfalse
(eqv? (cons 1 2) (cons 1 2))     \ev  \schfalse
(eqv? (lambda () 1)
      (lambda () 2))             \ev  \schfalse
(let ((p (lambda (x) x)))
  (eqv? p p))                    \ev  \schtrue
(eqv? \#f 'nil)                  \ev  \schfalse%
\end{scheme}

前述のルールで{\cf eqv?}の動作が完全には規定されていない状況を以下の例に示します。
そのような場合において言えることは、
{\cf eqv?}の返す値がブーリアンでなければならない、ということのみです。

\begin{scheme}
(eqv? "" "")             \ev  \unspecified
(eqv? '\#() '\#())         \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (x) x))    \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (y) y))    \ev  \unspecified
(eqv? 1.0e0 1.0f0)       \ev  \unspecified
(eqv? +nan.0 +nan.0)     \ev  \unspecified%
\end{scheme}

負のゼロが区別されている場合、{\cf (eqv? 0.0 -0.0)}は\schfalse{}を返し、
負のゼロが区別されていない場合は\schtrue{}を返します。

次の一連の例は、局所的な状態を持つ手続きに対する{\cf eqv?}の使用を示します。
{\cf gen-counter}手続きは、毎回別々の手続きを返さなければなりません。
なぜなら、それぞれ別個の内部カウンタが必要であるためです。
しかし{\cf gen-loser}手続きは、毎回操作的に同等な手続きを返します。
なぜなら、局所状態がその手続きの値にも副作用にも影響しないためです。
しかし{\cf eqv?}は、この等しさを検出できる場合もあれば、できない場合もあります。

\begin{scheme}
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-counter) (gen-counter))
                        \ev  \schfalse
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-loser) (gen-loser))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g))))
  (eqv? f g))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both))))
  (eqv? f g))
                        \ev  \schfalse%
\end{scheme}

定数オブジェクト(リテラル式によって返される)を変更することはエラーであるので、
処理系は適切な状況においては定数間で構造を共有する場合があります。
そのため定数に対する{\cf eqv?}の値は処理系依存になる場合があります。

\begin{scheme}
(eqv? '(a) '(a))                 \ev  \unspecified
(eqv? "a" "a")                   \ev  \unspecified
(eqv? '(b) (cdr '(a b)))	 \ev  \unspecified
(let ((x '(a)))
  (eqv? x x))                    \ev  \schtrue%
\end{scheme}

上で述べた{\cf eqv?}の定義は手続きおよびリテラルの扱いについて処理系に自由を与えます。
処理系は、
2つの手続きや2つのリテラルがお互いに同等であるか検出できてもできなくてもよく、
2つの同等なオブジェクトの表現を同じビットパターンやポインタを用いて
マージするかしないかを選ぶことが出来ます。

\begin{note}
不正確な数値がIEEE二進浮動小数点数値で表現している場合、
同じサイズの不正確な数値を単純にビットごとの比較で行う{\cf eqv?}の実装は、
上記の定義によれば、正しいものです。
\end{note}

\end{entry}


\begin{entry}{%
\proto{eq?}{ \vari{obj} \varii{obj}}{procedure}}

{\cf eq?}手続きは{\cf eqv?}手続きに似ています。
ただし、いくつかの場合において{\cf eqv?}で検出可能なよりも細かい差異を識別する能力があります。
{\cf eqv?}が\schfalse{}を返す状況では同様に\schfalse{}を返さなければなりませんが、
{\cf eqv?}が\schfalse{}を返す状況でも\schtrue{}を返す場合があります。

\vest シンボル、ブーリアン、空リスト、ペア、レコード、
および空でない文字列、ベクタ、バイトベクタにおいて、
{\cf eq?}と{\cf eqv?}は同じ動作をすることが保証されています。
手続きにおいては、引数の場所の紐付けが同じ場合{\cf eq?}を返します。
数値および文字においては、{\cf eq?}の動作は処理系依存です。
ただし、必ず真または偽のどちらかを返します。
空文字列、空ベクタ、空バイトベクタにおいても、{\cf eq?}と{\cf eqv?}は異なる動作をする場合があります。

\begin{scheme}
(eq? 'a 'a)                     \ev  \schtrue
(eq? '(a) '(a))                 \ev  \unspecified
(eq? (list 'a) (list 'a))       \ev  \schfalse
(eq? "a" "a")                   \ev  \unspecified
(eq? "" "")                     \ev  \unspecified
(eq? '() '())                   \ev  \schtrue
(eq? 2 2)                       \ev  \unspecified
(eq? \#\backwhack{}A \#\backwhack{}A) \ev  \unspecified
(eq? car car)                   \ev  \schtrue
(let ((n (+ 2 3)))
  (eq? n n))      \ev  \unspecified
(let ((x '(a)))
  (eq? x x))      \ev  \schtrue
(let ((x '\#()))
  (eq? x x))      \ev  \schtrue
(let ((p (lambda (x) x)))
  (eq? p p))      \ev  \schtrue%
\end{scheme}


\begin{rationale}
通常{\cf eq?}は{\cf eqv?}よりも非常に効率的に実装することが出来ます。
例えば、{\cf eqv?}がいくらか複雑な操作をする代わりに、{\cf eq?}は単なるポインタの比較で済みます。
その理由のひとつは、
2つの数値の{\cf eqv?}を計算することが常に定数時間で出来るわけではないということです。
それに対してポインタ比較で実装された{\cf eq?}は常に定数時間で処理できます。
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{equal?}{ \vari{obj} \varii{obj}}{procedure}}

{\cf equal?}手続きは、ペア、ベクタ、文字列、バイトベクタに適用された場合、それらを再帰的に比較します。
それらを(無限長の可能性もある)木構造に展開したとき、
順序付きの木構造として({\cf equal?}の意味で)等しければ\schtrue{}を返し、
そうでなければ\schfalse{}を返します。
ブーリアン、シンボル、数値、文字、ポート、手続きおよび空リストに適用されたときは
{\cf eqv?}と同じです。
それ以外のすべての状況では、
{\cf equal?}は\schtrue{}を返す場合も\schfalse{}を返す場合もあります。
%% Note that records are {\cf equal?} if their record types are the same
%% and their correspondingly named fields are {\cf equal?}.

引数が循環データ構造であっても、{\cf equal?}は必ず終了しなければなりません。

\begin{scheme}
(equal? 'a 'a)                  \ev  \schtrue
(equal? '(a) '(a))              \ev  \schtrue
(equal? '(a (b) c)
        '(a (b) c))             \ev  \schtrue
(equal? "abc" "abc")            \ev  \schtrue
(equal? 2 2)                    \ev  \schtrue
(equal? (make-vector 5 'a)
        (make-vector 5 'a))     \ev  \schtrue
(equal? '\#1=(a b . \#1\#)
        '\#2=(a b a b . \#2\#))    \ev  \schtrue
(equal? (lambda (x) x)
        (lambda (y) y))  \ev  \unspecified%
\end{scheme}

\begin{note}
大まかに言って、2つのオブジェクトが同じようにプリントされる場合、
一般的にそれらは{\cf equal?}です。
\end{note}



\end{entry}


\section{数値}
\label{numbersection}
\index{number}

\newcommand{\type}[1]{{\it#1}}
\newcommand{\tupe}[1]{{#1}}

数学の数値と、
それをモデル化したSchemeの数値と、
それを表現するために使われる機械表現と、
数値を書くために使われる記法を、区別することは重要です。
この報告書では、
\type{数値},\type{複素数},\type{実数},\type{有理数},\type{整数}
といった型を、数学の数値とSchemeの数値の両方を示すために用います。

\subsection{数値の型}
\label{numericaltypes}
\index{numerical types}

\vest 数学的には、各階がそれより上の階の部分型であるような塔に、数値を編成することが出来ます。
\begin{tabbing}
\ \ \ \ \ \ \ \ \ \=\tupe{数値} \\
\> \tupe{複素数} \\
\> \tupe{実数} \\
\> \tupe{有理数} \\
\> \tupe{整数} 
\end{tabbing}

例えば、3は整数です。
またそれゆえ、3は有理数でもあり、実数でもあり、複素数でもあります。
これは3をモデル化したSchemeの数値においても同様です。
Schemeの数値では、述語
\ide{number?}、\ide{complex?}、\ide{real?}、\ide{rational?}および\ide{integer?}
により、これらの型が定義されます。

数値の型とそのコンピュータ内における表現の間には、単純な関係はありません。
ほとんどのScheme処理系では、3の表現が少なくとも2種類は用意されていますが、
これらの異なる表現は同じ整数を表しています。

Schemeの数値計算では、
数値を可能な限りその表現と独立した抽象的なデータとして扱います。
Scheme処理系は数値の内部表現を複数用いても構いませんが、
単純なプログラムを書くカジュアルプログラマーには判らないようにするべきです。

\subsection{正確性}

\mainindex{exactness} \label{exactly}

正確に表現された数値と、そうでない可能性のある数値の区別は、有用です。
例えば、データ構造へのインデックスは、
記号代数系における多項式の係数と同様に、
正確に判明している必要があります。
他方、計測の結果などは本質的に不正確であったり、
無理数などは有理数によって近似された不正確な近似値であったりします。
正確な数値が必要なところでの不正確な数値の使用を捕えるために、
Schemeでは正確な数値と不正確な数値を区別しています。
この区別は型の次元とは直交しています。

Schemeでは、正確な定数として書かれたか、
\tupe{正確}な演算のみを用いて\tupe{正確}な数値から得られた場合、
その数値は\type{正確}です。
不正確な数値として書かれたか、
\tupe{不正確}な発生源から得られたか、
\tupe{不正確}な演算を用いて得られた場合、
その数値は\type{不正確}です。
従って数値の\tupe{不正確}性は伝染する性質を持ちます。
特に、\defining{正確な複素数}は正確な実部と正確な虚部を持ち、
そうでないすべての複素数は\defining{不正確な複素数}です。

\vest 2つの処理系がある計算に対して
\tupe{不正確}な中間結果を生じずに\tupe{正確}な結果を生成する場合、
その2つの最終結果は数学的に等しくなります。
このことは\tupe{不正確}な数値を生成する計算では一般に真ではありません。
浮動小数点計算のような近似的な手法が使われる場合があるためです。
しかし各々の処理系は数学上の理想的な結果に実用上十分な程度近い結果を生成する義務があります。

\vest {\cf +}のような有理数の演算は
\tupe{正確}な引数が与えられると必ず\tupe{正確}な結果を生成します。
演算が\tupe{正確}な結果を生成することが出来ない場合は、
処理系の制限の違反を報告するか、
その結果を\tupe{不正確}な値に黙って変換しても構いません。
しかしながら、{\cf (/~3~4)}が数学的に不正確な値である{\cf 0}を返すようなことは許容されません。
\ref{restrictions}~節を参照してください。

\vest \ide{exact}を除き、
この節で説明されている演算は一般に、不正確な引数が与えられた場合、不正確な結果を返さなければなりません。
ただし、その結果の値が引数の不正確性に影響を受けないことが保証できる場合は、
\tupe{正確}な結果を返しても構いません。
例えば、\tupe{正確}なゼロにはどんな数値を掛けても、
たとえそれが\tupe{不正確}な値であっても、
\tupe{正確}なゼロの結果を生成することが出来ます。

具体的な例として、
式 {\cf (* 0 +inf.0)} は
{\cf 0}を返しても構いませんし、
{\cf +nan.0}を返しても構いませんし、
不正確な数値をサポートしていない旨を報告しても構いませんし、
無理数をサポートしていない旨を報告しても構いませんし、
黙って死んでも構いませんし、
あるいは処理系固有の方法で騒がしくエラーを出しても構いません。

\subsection{処理系の制限}

\index{implementation restriction}\label{restrictions}

\vest Scheme処理系は\ref{numericaltypes}~節で述べている部分型の塔の全体を実装することは要求されていません。
しかし、処理系の目的とScheme言語の精神の両方を満たす、一貫性のある部分集合を実装しなければなりません。
例えば、
すべての数値が\tupe{実数}である処理系、
\tupe{実数}以外の数値が常に\tupe{不正確}である処理系、
\tupe{正確}な数値が常に\tupe{整数}である処理系、
などは依然として非常に有用でしょう。

\vest 処理系は、この節の要求を満たす限り、
任意の型の数値の、ある特定の範囲のみをサポートしても構いません。
任意の型の\tupe{正確}な数値のサポートされている範囲が
その型の\tupe{不正確}な数値のサポートされている範囲と異なっていても構いません。
例えば、
すべての\tupe{不正確}な\tupe{実数}を表現するためにIEEE二進倍精度浮動小数点数値を採用している処理系では、
\tupe{不正確}な\tupe{実数}の範囲(ゆえに\tupe{不正確}な\tupe{整数}および\tupe{有理数}の範囲も)が
IEEE二進倍精度形式のダイナミックレンジに制限されていながら、
\tupe{正確}な\tupe{整数}と\tupe{有理数}を事実上無制限の範囲でサポートしていて構いません。
さらに言えば、そのような処理系では、この範囲制限に近づくにつれ、
表現可能な\tupe{不正確}な\tupe{整数}および\tupe{有理数}の隙間が
非常に大きくなる可能性があります。

\vest Scheme処理系は、
リスト、ベクタ、バイトベクタ、文字列のインデックスのために、
およびそれらの長さを計算した結果のために必要な数値の範囲全体に対して、
正確な整数をサポートしなければなりません。
\ide{length}、\ide{vector-length}、\ide{bytevector-length}および\ide{string-length}
手続きは正確な整数を返さなければなりません。
また、インデックスとして正確な整数以外のものを使用することはエラーです。
さらに、インデックス範囲内のあらゆる整数定数は、
この範囲外で適用されるいかなる処理系の制限にも関わらず、
正確な整数の構文で表現されていれば、
正確な整数として読めなればなりません。
最後に、以下の一覧に記載されている手続きは、
すべての引数が正確な整数でかつ数学的に期待される結果が処理系の範囲内の正確な整数で表現可能ならば、
必ず正確な整数の結果を返さなければなりません。

\begin{scheme}
-                     *
+                     abs
ceiling               denominator
exact-integer-sqrt    expt
floor                 floor/
floor-quotient        floor-remainder
gcd                   lcm
max                   min
modulo                numerator
quotient              rationalize
remainder             round
square                truncate
truncate/             truncate-quotient
truncate-remainder
\end{scheme}

\vest 処理系は、
事実上無制限の大きさと精度を持つ\tupe{正確}な\tupe{整数}と\tupe{正確}な\tupe{有理数}とサポートし、
上記の手続きと{\cf /}手続きを\tupe{正確}な引数に対して必ず\tupe{正確}な結果を返すよう実装することが、
推奨されますが、要求はされません。
これらの手続きはいずれも、
\tupe{正確}な引数を与えられたとき\tupe{正確}な結果を返すことが出来なければ、
処理系の制限の違反を報告しても構いませんし、
黙ってその結果を\tupe{不正確}な数値に変換しても構いません。
そのような変換は後のエラーの原因となる可能性があります。
とはいえ、\tupe{正確}な有理数を用意していない処理系は
処理系の制限を報告するよりも\tupe{不正確}な有理数を返す方が良いでしょう。

\vest 処理系は\tupe{不正確}な数値に対して浮動小数点や他の近似表現戦略を用いても構いません。
この報告書では IEEE 754 標準に従った浮動小数点表現を用いること、
他の表現方法を用いる処理系はこの浮動小数点の標準を用いて達成可能な精度と同等かそれを超えることが
推奨されていますが、要求はされません。
特に、そのような実装は IEEE 754-2008 の超越関数の記述に、とりわけ無限大とNaNに関して、従うべきです。

Schemeは数値に対する様々な書き方を用意していますが、
処理系はそれらの一部しかサポートしなくても構いません。
例えば、数値がすべて\tupe{実数}である処理系は、複素数の直交座標表示や極座標表示をサポートする必要はありません。
処理系が\tupe{正確}な数値として表現できない\tupe{正確}な数値定数に出くわした場合、
処理系の制限の違反を報告しても構いませんし、
黙って\tupe{不正確}な数値で表現しても構いません。

\subsection{処理系の拡張}
\index{implementation extension}

\vest 処理系によっては2つ以上の異なる精度の浮動小数点数値表現を用意している場合があります。
そのような処理系では、不正確な結果は少なくともその演算に使われた
どの不正確引数も表現できるだけの精度を持っていなければなりません。
{\cf sqrt}のような潜在的に不正確な演算は、
\tupe{正確}な引数を適用したときは\tupe{正確}な結果を生成することが望ましいものの、
もし\tupe{正確}な数値を演算して\tupe{不正確}な結果を生成する場合は、
利用可能な中で最も精度の高い表現を用いなければなりません。
例えば、 {\cf (sqrt 4)} の値は{\cf 2}となるべきですが、
単精度と倍精度の浮動小数点数値を両方用意している処理系では、
後者を用いても構いませんが、前者を用いてはなりません。

その処理系で表現するには大きすぎる絶対値や仮数部を持つ
不正確な数値オブジェクトの使用を避けるのはプログラマの責任です。

さらに、処理系は\tupe{正の無限大}、\tupe{負の無限大}、\tupe{NaN}、および
\tupe{負のゼロ}といった特別な数値を区別しても構いません。

正の無限大は、
有理数で表現可能ないかなる数値よりも大きな不定の値を表現する、
不正確な実数(しかし有理数ではない)と見なされます。
負の無限大は、不正確な実数
有理数で表現可能ないかなる数値よりも小さな不定の値を表現する、
不正確な実数(しかし有理数ではない)と見なされます。

無限大の値にいかなる有限の実数を加算および乗算しても、
その結果は(適切な符号の)無限大となります。
しかし、正の無限大と負の無限大の和はNaNです。
正の無限大はゼロの逆数で、負の無限大は負のゼロの逆数です。
IEEE 754 に従った超越関数の動作は無限大に対して非常に複雑です。

NaNは、任意の実数を表し得る不定の不正確な実数(しかし有理数ではない)と見なされます。
これには、正負の無限大や、正の無限大より大きな値、負の無限大より小さな値も含まれます。
実数以外の数値をサポートしない処理系では、
{\cf (sqrt -1.0)}や{\cf (asin 2.0)}のような実数でない値を表現するために
NaNを用いても構いません。

NaNはどのような数値と比較しても必ず偽になります。
NaN自身と比較しても同様です。
数値演算は引数のいずれかがNaNであればNaNを返します。
ただしそのNaNをどのような有理数と置き換えても結果は同じであると処理系が保証できる場合を除きます。
ゼロをゼロで除算すると、両方のゼロが正確でなければ、結果はNaNになります。

%% IEEE 754 specifies multiple NaN values.  Scheme generally does
%% not care if there is a single value (bit pattern) for NaN,
%% or if there are multiple values: if there are multiple NaN
%% values, or just one, they are all equivalent in terms of Scheme
%% computation.

負のゼロは、不正確な実数であり、{\cf -0.0}と書かれ、
({\cf eqv?}の意味で){\cf 0.0}と区別されます。
Scheme処理系は負のゼロを区別することは要求されません。
しかし区別する場合は、超越関数の動作は IEEE 754 に従った複雑なものになります。
特に、複素数と負のゼロを両方サポートするScheme処理系は、
複素対数関数の分岐を{\cf (imag-part (log -1.0-0.0i))}が$\pi$でなく$-\pi$となるように処理しなければなりません。

さらに、負のゼロに対する負の値は通常のゼロであり、逆も同様です。
これは、2つ以上の負のゼロの和が負であり、
負のゼロから(正の)ゼロを引いた結果も同様に負であることを暗黙に示しています。
しかし、数値的な比較においては、負のゼロとゼロは等しいものとして扱われます。

ちなみに、複素数の実部と虚部いずれにも
無限大、NaNまたは負のゼロを取ることが出来ます。

\subsection{数値定数の構文}
\label{numbernotations}

数値の表現を書くための構文は\ref{numbersyntax}~節で正式に記述されています。
ちなみに数値定数では大文字小文字は区別されません。

数値は基数接頭辞を使うことで二進数、八進数、十進数または十六進数で書くことが出来ます。
基数接頭辞は
{\cf \#b}\sharpindex{b} (二進数)、
{\cf \#o}\sharpindex{o} (八進数)、
{\cf \#d}\sharpindex{d} (十進数)、および
{\cf \#x}\sharpindex{x} (十六進数) です。
基数接頭辞が無い場合、数値は十進数で表現されているとみなされます。

数値定数は接頭辞によって\tupe{正確}または\tupe{不正確}のいずれかを指定出来ます。
\tupe{正確}の接頭辞は{\cf \#e}\sharpindex{e}で
\tupe{不正確}の接頭辞は{\cf \#i}\sharpindex{i}です。
正確性接頭辞は基数接頭辞の前でも後でも構いません。
正確性接頭辞を付けずに数値の表現を書いた場合、
小数点または指数があればその定数は\tupe{不正確}であり、
そうでなければ\tupe{正確}です。

様々な精度の\tupe{不正確}な数値を持つシステムでは、
定数の精度を指定できると有用です。
このため、処理系は
\tupe{不正確}な表現の希望精度を指定する指数マーカーが書かれた数値定数
を受け付けても構いません。
その場合、文字{\cf e}の場所で、その代わりに
{\cf s}、{\cf f}、{\cf d}または{\cf l}を使うことができ、
それぞれ\var{短精度}、\var{単精度}、\var{倍精度}、\var{長精度}を意味しています。
デフォルトの精度は少なくとも\var{倍精度}以上でなければなりませんが、
処理系はこのデフォルトをユーザーの設定によって変更できても構いません。

\begin{scheme}
3.14159265358979F0
       {\rm Round to single ---} 3.141593
0.6L0
       {\rm Extend to long ---} .600000000000000%
\end{scheme}

正の無限大、負の無限大、NaNは、それぞれ
{\cf +inf.0}、{\cf -inf.0}、{\cf +nan.0}と書かれます。
NaNは{\cf -nan.0}と書かれることもあります。
書かれた表現の符号の使用は、もしNaN値の内部表現に符号があっても、それを反映する必要はありません。
処理系はこれらの数値をサポートすることは要求されていませんが、
サポートする場合は、全般的に IEEE 754 に準拠しなければなりません。
ただし、処理系は Signaling NaN をサポートしたり
異なる NaN を区別する方法を用意したりすることは要求されません。

実数でない複素数を表記するための記法が2つあります。
ひとつは\defining{直交座標表示}で、 \var{a}{\cf +}\var{b}{\cf i} のように表記します。
ただし\var{a}は実部で、\var{b}は虚部です。
もうひとつは\defining{極座標表示}で、 \var{r}{\cf @}$\theta$ のように表記します。
ただし\var{r}は動径、 $\theta$ はラジアンで表した位相(偏角)です。
これらは
$a+b\mathrm{i} = r \cos\theta + (r \sin\theta) \mathrm{i}$
の関係があります。
\var{a}、\var{b}、\var{r}および $\theta$ はすべて実数です。


\subsection{数値演算}

数値ルーチンの引数の型の制限を指定するために使われる命名規約の要約について
\ref{typeconventions}~節を参照してください。
この節の例では\tupe{正確}な表記で書かれた数値定数は常に
実際\tupe{正確}な数値を表しているものとみなしています。
また\tupe{不正確}な表記で書かれた特定の数値定数は
精度を失うことなく表現されているものとみなしています。
そういった\tupe{不正確}な定数は、
不正確な数値の表現に IEEE 二進倍精度を採用している処理系で
その仮定が成立するように選ばれています。

\todo{Scheme provides the usual set of operations for manipulating
numbers, etc.}

\begin{entry}{%
\proto{number?}{ obj}{procedure}
\proto{complex?}{ obj}{procedure}
\proto{real?}{ obj}{procedure}
\proto{rational?}{ obj}{procedure}
\proto{integer?}{ obj}{procedure}}

これらの数値述語は、数値でないものを含むいかなる型の引数にも適用できます。
オブジェクトがその名前の型であれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。
一般的に、ある型の述語がある数値に対して真であれば、
より上位の型の述語もすべて、その数値に対して真となります。
そのため、ある型の述語がある数値に対して偽であれば、
より下位の型の述語もすべて、その数値に対して偽となります。

\vr{z}が複素数の場合、
{\cf (real? \vr{z})} は {\cf (zero? (imag-part \vr{z}))} が真のときに限り真となります。
\vr{x}が不正確な実数である場合、
{\cf (integer? \vr{x})} は {\cf (= \vr{x} (round \vr{x}))} が真のときに限り真となります。

{\cf +inf.0}、{\cf -inf.0}および{\cf +nan.0}は実数ですが有理数ではありません。

\begin{scheme}
(complex? 3+4i)         \ev  \schtrue
(complex? 3)            \ev  \schtrue
(real? 3)               \ev  \schtrue
(real? -2.5+0i)         \ev  \schtrue
(real? -2.5+0.0i)       \ev  \schfalse
(real? \#e1e10)          \ev  \schtrue
(real? +inf.0)           \ev  \schtrue
(real? +nan.0)           \ev  \schtrue
(rational? -inf.0)       \ev  \schfalse
(rational? 3.5)          \ev  \schtrue
(rational? 6/10)        \ev  \schtrue
(rational? 6/3)         \ev  \schtrue
(integer? 3+0i)         \ev  \schtrue
(integer? 3.0)          \ev  \schtrue
(integer? 8/4)          \ev  \schtrue%
\end{scheme}

\begin{note}
\tupe{不正確}な数値に対するこれらの型の述語の動作は信頼できません。
不正確さが結果に影響する場合があるためです。
\end{note}

\begin{note}
多くの処理系では\ide{complex?}手続きは\ide{number?}と同じですが、
ある種の無理数を正確に表現できたり、
数値系を拡張して何らかの複素数でない数値をサポートしたりする、
普通でない処理系があるかもしれません。
\end{note}

\end{entry}

\begin{entry}{%
\proto{exact?}{ \vr{z}}{procedure}
\proto{inexact?}{ \vr{z}}{procedure}}

これらの数値述語は値の正確性を判定します。
あらゆるSchemeの数値は、これらの述語のいずれか一方だけが真になります。

\begin{scheme}
(exact? 3.0)           \ev  \schfalse
(exact? \#e3.0)         \ev  \schtrue
(inexact? 3.)          \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{exact-integer?}{ \vr{z}}{procedure}}

\vr{z}が\tupe{正確}かつ\tupe{整数}であれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。

\begin{scheme}
(exact-integer? 32) \ev \schtrue{}
(exact-integer? 32.0) \ev \schfalse{}
(exact-integer? 32/5) \ev \schfalse{}%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{finite?}{ \vr{z}}{inexact library procedure}}

{\cf finite?}手続きは
{\cf +inf.0}、{\cf -inf.0}、{\cf +nan.0}以外のすべての実数、
および実部と虚部が共に有限である複素数に対して、\schtrue{}を返します。
そうでなければ\schfalse{}を返します。

\begin{scheme}
(finite? 3)         \ev  \schtrue
(finite? +inf.0)       \ev  \schfalse
(finite? 3.0+inf.0i)   \ev  \schfalse%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{infinite?}{ \vr{z}}{inexact library procedure}}

{\cf infinite?}手続きは
{\cf +inf.0}、{\cf -inf.0}、および
実部または虚部または両方が無限大である複素数に対して、\schtrue{}を返します。
そうでなければ\schfalse{}を返します。

\begin{scheme}
(infinite? 3)         \ev  \schfalse
(infinite? +inf.0)       \ev  \schtrue
(infinite? +nan.0)       \ev  \schfalse
(infinite? 3.0+inf.0i)   \ev  \schtrue%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{nan?}{ \vr{z}}{inexact library procedure}}

{\cf nan?}手続きは{\cf +nan.0}、および
実部または虚部または両方が{\cf +nan.0}である複素数に対して、\schtrue{}を返します。
そうでなければ\schfalse{}を返します。

\begin{scheme}
(nan? +nan.0)          \ev  \schtrue
(nan? 32)              \ev  \schfalse
(nan? +nan.0+5.0i)     \ev  \schtrue
(nan? 1+2i)            \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{=}{ \vri{z} \vrii{z} \vriii{z} \dotsfoo}{procedure}
\proto{<}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{>}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{<=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}
\proto{>=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{procedure}}

これらの手続きは引数が(それぞれ)
等しい、単調に増加している、単調に減少している、
単調に減少していない、または単調に増加していない場合に、
\schtrue{}を返し、そうでなければ\schfalse{}を返します。
引数のいずれかが{\cf +nan.0}の場合は、どの手続きも\schfalse{}を返します。
これらは不正確なゼロと不正確な負のゼロを区別しません。

これらの手続きは推移的であることが要求されます。

\begin{note}
いずれかの引数が不正確であればすべての引数を不正確な数値に変換する、
というような実装手法は推移的ではありません。
例えば、{\cf big}を{\cf (expt 2 1000)}として、
その{\cf big}が正確であり、
不正確な数値は64ビットのIEEE二進浮動小数点数で表現されているとしましょう。
その場合、この実装手法では、大きな整数のIEEE表現の制限のため、
{\cf (= (- big 1) (inexact big))} と {\cf (= (inexact big) (+ big 1))} が共に真でありながら
{\cf (= (- big 1) (+ big 1))} は偽となってしまうでしょう。
不正確な数値を、それと({\cf =}の意味で)同じ正確な数値に変換すれば、この問題を回避できますが、
無限大に対して特別な配慮が必要となります。
\end{note}

\begin{note}
これらの述語を用いて\tupe{不正確}な数値を比較することはエラーではありませんが、
わずかな不正確さが結果に影響を及ぼす可能性があるため、その結果は信頼できません。
\ide{=}や\ide{zero?}の場合、特にそうです。
嘘だと思うなら数値解析の専門家に聞いてみてください。

\end{note}

\end{entry}

\begin{entry}{%
\proto{zero?}{ \vr{z}}{procedure}
\proto{positive?}{ \vr{x}}{procedure}
\proto{negative?}{ \vr{x}}{procedure}
\proto{odd?}{ \vr{n}}{procedure}
\proto{even?}{ \vr{n}}{procedure}}

これらの数値述語は特定の性質を判定し、\schtrue{} または \schfalse を返します。
上記の注意点も参照してください。

\end{entry}

\begin{entry}{%
\proto{max}{ \vri{x} \vrii{x} \dotsfoo}{procedure}
\proto{min}{ \vri{x} \vrii{x} \dotsfoo}{procedure}}

これらの手続きは引数の最大値または最小値を返します。

\begin{scheme}
(max 3 4)              \ev  4    ; exact
(max 3.9 4)            \ev  4.0  ; inexact%
\end{scheme}

\begin{note}
いずれかの引数が不正確であれば、結果も不正確になります
(その不正確性が結果に影響を与えないくらい大きいことが保証できる場合は除きますが、
そのようなことは普通でない処理系にのみ可能なことです)。
{\cf min}または{\cf max}は正確性が混在した数値を比較するために使うことができ、
その結果の数値を正確さを犠牲にすることなく不正確な数値で表現することが出来ない場合、
これらの手続きは処理系の制限の違反を報告する場合があります。
\end{note}

\end{entry}


\begin{entry}{%
\proto{+}{ \vri{z} \dotsfoo}{procedure}
\proto{*}{ \vri{z} \dotsfoo}{procedure}}

これらの手続きは引数の和または積を返します。

\begin{scheme}
(+ 3 4)                 \ev  7
(+ 3)                   \ev  3
(+)                     \ev  0
(* 4)                   \ev  4
(*)                     \ev  1%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{-}{ \vr{z}}{procedure}
\rproto{-}{ \vri{z} \vrii{z} \dotsfoo}{procedure}
\proto{/}{ \vr{z}}{procedure}
\rproto{/}{ \vri{z} \vrii{z} \dotsfoo}{procedure}}

引数がふたつ以上の場合、
これらの手続きは左結合で引数の差または商を返します。
しかし引数がひとつの場合は、
その引数の反数または逆数を返します。

{\cf /}の第2引数以降のいずれかが正確なゼロの場合はエラーです。
第1引数が正確なゼロであり、他の引数がいずれもNaNでなければ、
正確なゼロを返す場合があります。

\begin{scheme}
(- 3 4)                 \ev  -1
(- 3 4 5)               \ev  -6
(- 3)                   \ev  -3
(/ 3 4 5)               \ev  3/20
(/ 3)                   \ev  1/3%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{abs}{ x}{procedure}}

{\cf abs}手続きは引数の絶対値を返します。
\begin{scheme}
(abs -7)                \ev  7%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{floor/}{ \vri{n} \vrii{n}}{procedure}
\proto{floor-quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{floor-remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{truncate/}{ \vri{n} \vrii{n}}{procedure}
\proto{truncate-quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{truncate-remainder}{ \vri{n} \vrii{n}}{procedure}}

これらの手続きは数論的な(整数)除算を実装します。
\vrii{n}がゼロの場合はエラーです。
{\cf /}で終わる手続きはふたつの整数を返し、それ以外の手続きはひとつの整数を返します。
どの手続きも
$\vri{n} = \vrii{n} \vr{n_q} + \vr{n_r}$
が成り立つような商\vr{n_q}と剰余\vr{n_r}を計算します。
それぞれの除算演算子に対して、3つの手続きが以下のように定義されます。

\begin{scheme}
(\hyper{operator}/ \vri{n} \vrii{n})             \ev \vr{n_q} \vr{n_r}
(\hyper{operator}-quotient \vri{n} \vrii{n})     \ev \vr{n_q}
(\hyper{operator}-remainder \vri{n} \vrii{n})    \ev \vr{n_r}%
\end{scheme}

剰余\vr{n_r}は整数\vr{n_q}が決まると自動的に
$\vr{n_r} = \vri{n} - \vrii{n} \vr{n_q}$
のように決定されます。
\vr{n_q}の決め方は各演算子によって異なります。

\begin{tabular}{l l}
\texttt{floor}     & $\vr{n_q} = \lfloor\vri{n} / \vrii{n}\rfloor$ \\
\texttt{truncate}  & $\vr{n_q} = \text{truncate}(\vri{n} / \vrii{n})$ \\
\end{tabular}

いずれの演算子も、またいずれの整数\vri{n}および\vrii{n}(ただし\vrii{n}がゼロでない場合)においても、
以下が成り立ちます。
\begin{scheme}
     (= \vri{n} (+ (* \vrii{n} (\hyper{operator}-quotient \vri{n} \vrii{n}))
           (\hyper{operator}-remainder \vri{n} \vrii{n})))
                                 \ev  \schtrue%
\end{scheme}
ただしすべての数値が正確な計算によって得られる場合の話です。

例:

\begin{scheme}
(floor/ 5 2)         \ev 2 1
(floor/ -5 2)        \ev -3 1
(floor/ 5 -2)        \ev -3 -1
(floor/ -5 -2)       \ev 2 -1
(truncate/ 5 2)      \ev 2 1
(truncate/ -5 2)     \ev -2 -1
(truncate/ 5 -2)     \ev -2 1
(truncate/ -5 -2)    \ev 2 -1
(truncate/ -5.0 -2)  \ev 2.0 -1.0%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{quotient}{ \vri{n} \vrii{n}}{procedure}
\proto{remainder}{ \vri{n} \vrii{n}}{procedure}
\proto{modulo}{ \vri{n} \vrii{n}}{procedure}}

{\cf quotient}および{\cf remainder}手続きはそれぞれ
{\cf truncate-quotient}および{\cf truncate-remainder}と同等であり、
{\cf modulo}は{\cf floor-remainder}と同等です。

\begin{note}
これらの手続きは以前のバージョンの報告書との後方互換性のために用意されています。
\end{note}
\end{entry}

\begin{entry}{%
\proto{gcd}{ \vri{n} \dotsfoo}{procedure}
\proto{lcm}{ \vri{n} \dotsfoo}{procedure}}

これらの手続きは引数の最大公約数または最小公倍数を返します。
結果は必ず非負です。

\begin{scheme}
(gcd 32 -36)            \ev  4
(gcd)                   \ev  0
(lcm 32 -36)            \ev  288
(lcm 32.0 -36)          \ev  288.0  ; inexact
(lcm)                   \ev  1%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{numerator}{ \vr{q}}{procedure}
\proto{denominator}{ \vr{q}}{procedure}}

これらの手続きは引数の分子または分母を返します。
結果は引数が既約分数として表現されているかのように計算されます。
分母は必ず正です。
ゼロの分母は1であると定義されます。
\todo{More description and examples needed.}
\begin{scheme}
(numerator (/ 6 4))  \ev  3
(denominator (/ 6 4))  \ev  2
(denominator
  (inexact (/ 6 4))) \ev 2.0%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{floor}{ x}{procedure}
\proto{ceiling}{ x}{procedure}
\proto{truncate}{ x}{procedure}
\proto{round}{ x}{procedure}
}

これらの手続きは整数を返します。
\vest {\cf floor}手続きは\vr{x}より大きくない最も大きな整数を返します。
{\cf ceiling}手続きは\vr{x}より小さくない最も小さな整数を返します。
{\cf truncate}手続きは絶対値が\vr{x}の絶対値より大きくない\vr{x}に最も近い整数を返します。
{\cf round}手続きは\vr{x}に最も近い整数を返しますが、
\vr{x}がふたつの整数の中央のときは偶数側に丸めます。

\begin{rationale}
{\cf round}手続きの偶数丸めは IEEE 754 IEEE浮動小数点標準で規定されている
デフォルトの丸めモードとの一貫性のためです。
\end{rationale}

\begin{note}
これらの手続きの引数が不正確な場合、結果も不正確になります。
正確な値が必要であれば結果を{\cf exact}手続きに渡しても構いません。
引数が無限大またはNaNの場合は、そのまま返されます。
\end{note}

\begin{scheme}
(floor -4.3)          \ev  -5.0
(ceiling -4.3)        \ev  -4.0
(truncate -4.3)       \ev  -4.0
(round -4.3)          \ev  -4.0

(floor 3.5)           \ev  3.0
(ceiling 3.5)         \ev  4.0
(truncate 3.5)        \ev  3.0
(round 3.5)           \ev  4.0  ; inexact

(round 7/2)           \ev  4    ; exact
(round 7)             \ev  7%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{rationalize}{ x y}{procedure}
}

{\cf rationalize}手続きは\vr{x}から±\vr{y}以内の{\em 最も簡単}な有理数を返します。
ある有理数 $r_1$ が別の有理数 $r_2$ より{\em 簡単}であるとは、\mainindex{simplest rational}
$r_1 = p_1/q_1$ および $r_2 = p_2/q_2$ (いずれも既約) としたとき、
$|p_1| \leq |p_2|$ かつ $|q_1| \leq |q_2|$ である場合のことを言います。
つまり $3/5$ は $4/7$ より簡単です。
すべての有理数がこの順序付けで比較できるわけではありませんが
($2/7$ と $3/5$ を考えてみてください)、
どのような区間においても他のすべての有理数より簡単な有理数というものがひとつ存在しています
($2/7$ と $3/5$ の間には、より簡単な $2/5$ があります)。
ちなみにすべての有理数のうち最も簡単なものは $0 = 0/1$ です。

\begin{scheme}
(rationalize
  (exact .3) 1/10)  \ev 1/3    ; exact
(rationalize .3 1/10)        \ev \#i1/3  ; inexact%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{exp}{ \vr{z}}{inexact library procedure}
\proto{log}{ \vr{z}}{inexact library procedure}
\rproto{log}{ \vri{z} \vrii{z}}{inexact library procedure}
\proto{sin}{ \vr{z}}{inexact library procedure}
\proto{cos}{ \vr{z}}{inexact library procedure}
\proto{tan}{ \vr{z}}{inexact library procedure}
\proto{asin}{ \vr{z}}{inexact library procedure}
\proto{acos}{ \vr{z}}{inexact library procedure}
\proto{atan}{ \vr{z}}{inexact library procedure}
\rproto{atan}{ \vr{y} \vr{x}}{inexact library procedure}}

これらの手続きは通常の超越関数を計算します。
{\cf log}手続きは引数がひとつの場合は\vr{z}の自然対数を計算し(底を10とする対数ではありません)、
引数がふたつの場合は底を\vrii{z}とする\vri{z}の対数を計算します。
{\cf asin}、{\cf acos}、{\cf atan}手続きはそれぞれ
逆正弦($\sin^{-1}$)、逆余弦($\cos^{-1}$)、逆正接($\tan^{-1}$)を計算します。
{\cf atan}の2引数版は
{\tt (angle (make-rectangular \vr{x} \vr{y}))}
(後述)を計算します(処理系が複素数をサポートしていない場合でも)。

一般的に、対数、逆正弦、逆余弦、逆正接といった数学関数は多重定義されます。
$\log z$ の値はその虚部が $-\pi$ ({\cf -0.0}が区別されている場合は含まれず、そうでなければ含まれる)
から $\pi$ (常に含まれる) の範囲にある場合は1に定義されます。
$\log 0$の値は数学的に未定義です。
$\log$をこのように定義すると、
$\sin^{-1} z$、$\cos^{-1} z$、$\tan^{-1} z$は以下の式に従います。
$$\sin^{-1} z = -i \log (i z + \sqrt{1 - z^2})$$
$$\cos^{-1} z = \pi / 2 - \sin^{-1} z$$
$$\tan^{-1} z = (\log (1 + i z) - \log (1 - i z)) / (2 i)$$

しかし、処理系が無限大 (および {\cf -0.0}) をサポートしている場合、
{\cf (log 0.0)} は {\cf -inf.0} を返します
(また {\cf (log -0.0)} は {\cf -inf.0+$\pi$i} を返します)。

\texttt{({\cf atan} \var{y} \var{x})} の範囲は以下の表のようになります。
星印 (*) はマイナスゼロを区別する処理系に適用される項目であることを示しています。

\begin{center}
\begin{tabular}{clll}
& $y$の条件 & $x$の条件 & 結果$r$の範囲\\\hline
& $y = 0.0$ & $x > 0.0$ & $0.0$\\
$\ast$ & $y = +0.0$  & $x > 0.0$ & $+0.0$\\
$\ast$ & $y = -0.0$ & $x > 0.0$ & $-0.0$\\
& $y > 0.0$ & $x > 0.0$ & $0.0 < r < \frac{\pi}{2}$\\
& $y > 0.0$ & $x = 0.0$ & $\frac{\pi}{2}$\\
& $y > 0.0$ & $x < 0.0$ & $\frac{\pi}{2} < r < \pi$\\
& $y = 0.0$ & $x < 0$ & $\pi$\\
$\ast$ & $y = +0.0$ & $x < 0.0$ & $\pi$\\
$\ast$ & $y = -0.0$ & $x < 0.0$ & $-\pi$\\
&$y < 0.0$ & $x < 0.0$ & $-\pi< r< -\frac{\pi}{2}$\\
&$y < 0.0$ & $x = 0.0$ & $-\frac{\pi}{2}$\\
&$y < 0.0$ & $x > 0.0$ & $-\frac{\pi}{2} < r< 0.0$\\
&$y = 0.0$ & $x = 0.0$ & undefined\\
$\ast$& $y = +0.0$ & $x = +0.0$ & $+0.0$\\
$\ast$& $y = -0.0$ & $x = +0.0$& $-0.0$\\
$\ast$& $y = +0.0$ & $x = -0.0$ & $\pi$\\
$\ast$& $y = -0.0$ & $x = -0.0$ & $-\pi$\\
$\ast$& $y = +0.0$ & $x = 0$ & $\frac{\pi}{2}$\\
$\ast$& $y = -0.0$ & $x = 0$    & $-\frac{\pi}{2}$
\end{tabular}
\end{center}

上記の仕様は\cite{CLtL}に従ったもので、それは\cite{Penfield81}から引用されたものです。
分岐条件や境界条件、およびこれらの関数の実装についてのより詳細な議論は、
これらの情報源を参照してください。
可能であれば、これらの手続きは実数の引数から実数の結果を生成します。


\end{entry}

\begin{entry}{%
\proto{square}{ \vr{z}}{procedure}}

\vr{z}の平方を返します。
これは \texttt{({\cf *} \var{z} \var{z})} と同等です。
\begin{scheme}
(square 42)       \ev 1764
(square 2.0)     \ev 4.0%
\end{scheme}

%% Removing this since it's inaccurate and not reflective of the
%% real rationale most members listed.  We need a proper rationale
%% document to go into detail.
%% \begin{rationale}
%% Taking the square of a large integer is more efficient than
%% multiplying arbitrary integers, and floating-point processors often
%% have a primitive square operator.
%% \end{rationale}

\end{entry}

\begin{entry}{%
\proto{sqrt}{ \vr{z}}{inexact library procedure}}

\vr{z}の正の平方根を返します。
結果は正の実部を持つか、ゼロの実部と非負の虚部を持つかのいずれかです。

\begin{scheme}
(sqrt 9)  \ev 3
(sqrt -1) \ev +i%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{exact-integer-sqrt}{ k}{procedure}}

$\var{k} = s^2 + r$ および $\var{k} < (s+1)^2$ が成り立つ
ふたつの非負の正確な整数$s$および$r$を返します。

\begin{scheme}
(exact-integer-sqrt 4) \ev 2 0
(exact-integer-sqrt 5) \ev 2 1%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{expt}{ \vri{z} \vrii{z}}{procedure}}

\vri{z}の\vrii{z}乗を返します。
\vri{z}がゼロでなければ、これは $${z_1}^{z_2} = e^{z_2 \log {z_1}}$$ です。
$0^z$ の値は{\cf (zero? z)}の場合$1$、
{\cf (real-part z)}が正の場合$0$で、
それ以外はエラーです。
$0.0^z$の場合も同様ですが、不正確な結果になります。
\end{entry}




\begin{entry}{%
\proto{make-rectangular}{ \vri{x} \vrii{x}}{complex library procedure}
\proto{make-polar}{ \vriii{x} \vriv{x}}{complex library procedure}
\proto{real-part}{ \vr{z}}{complex library procedure}
\proto{imag-part}{ \vr{z}}{complex library procedure}
\proto{magnitude}{ \vr{z}}{complex library procedure}
\proto{angle}{ \vr{z}}{complex library procedure}}

実数\vri{x}、\vrii{x}、\vriii{x}、\vriv{x}および
複素数\vr{z}について
 $$ \vr{z} = \vri{x} + \vrii{x}\hbox{$i$}
 = \vriii{x} \cdot e^{i x_4}$$
が成り立つ場合、以下がすべて成り立ちます。
\begin{scheme}
(make-rectangular \vri{x} \vrii{x}) \ev \vr{z}
(make-polar \vriii{x} \vriv{x})     \ev \vr{z}
(real-part \vr{z})                  \ev \vri{x}
(imag-part \vr{z})                  \ev \vrii{x}
(magnitude \vr{z})                  \ev $|\vriii{x}|$
(angle \vr{z})                      \ev $x_{angle}$%
\end{scheme}
ただし $-\pi \le x_{angle} \le \pi$ かつ $x_{angle} = \vriv{x} + 2\pi n$
($n$は整数)とします。

{\cf make-polar}は引数が正確であっても不正確な複素数を返す場合があります。
{\cf real-part}および{\cf imag-part}手続きは、不正確な複素数に適用した場合でも、
{\cf make-rectangular}に渡された対応する引数が正確であったならば、正確な実数を返す場合があります。


\begin{rationale}
{\cf magnitude}手続きは実数の引数に対しては\ide{abs}と同じですが、
{\cf abs}はbaseライブラリの手続きであるのに対し、
{\cf magnitude}はオプションのcomplexライブラリの手続きとなっています。
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{inexact}{ \vr{z}}{procedure}
\proto{exact}{ \vr{z}}{procedure}}

手続き{\cf inexact}は\vr{z}の\tupe{不正確}な表現を返します。
戻り値は数値的に引数に最も近い\tupe{不正確}な数値です。
不正確な引数に対しては、その引数と同じ値を返します。
正確な複素数に対しては、引数の実部と虚部をそれぞれ{\cf inexact}に適用した結果を
実部と虚部に持つ複素数を返します。
\tupe{正確}な引数に十分近い({\cf =}の意味で)同等な\tupe{不正確}な値がない場合、
処理系の制限の違反が報告される場合があります。

手続き{\cf exact}は\vr{z}の\tupe{正確}な表現を返します。
戻り値は数値的に引数に近い\tupe{正確}な値です。
正確な引数に対しては、その引数と同じ値を返します。
不正確な整数でない実数の引数に対しては、有理数による近似値を返す場合もあれば、
処理系の制限の違反が報告される場合もあります。
不正確な複素数の引数に対しては、引数の実部と虚部をそれぞれ{\cf exact}に適用した結果を
実部と虚部に持つ複素数を返します。
\tupe{不正確}な引数に十分近い({\cf =}の意味で)同等な\tupe{正確}な値がない場合、
処理系の制限の違反が報告される場合があります。

これらの手続きは処理系依存の範囲内の\tupe{正確}な整数と\tupe{不正確}な整数に対して
自然な1対1の対応関係を実装しています。
\ref{restrictions}~節を参照してください。

\begin{note}
これらの手続きは \rfivers\ ではそれぞれ
{\cf exact->inexact}および{\cf inexact->exact}として知られていました。
しかしこれらは常にどちらの正確性の引数も受け付けていました。
新しい名前は \rsixrs と互換性があるのと同様に明確で短いものです。
\end{note}

\end{entry}

\medskip

\subsection{数値の入出力}

\begin{entry}{%
\proto{number->string}{ z}{procedure}
\rproto{number->string}{ z radix}{procedure}}

\domain{\vr{radix}が2、8、10、16のいずれでもなければエラーです。}
手続き{\cf number\coerce{}string}は数値と基数を取り、
以下の式を満たすような指定した基数における指定した数値の外部表現を、
文字列として返します。
\begin{scheme}
(let ((number \vr{number})
      (radix \vr{radix}))
  (eqv? number
        (string->number (number->string number
                                        radix)
                        radix)))%
\end{scheme}
この式を満たせる結果が存在しない場合はエラーです。
\vr{radix}を省略した場合のデフォルト値は10です。

\vr{z}が不正確で、基数が10で、かつ小数点を含む結果によって上記の式が満たせる場合、
その結果は小数点を含み、
上記の式を満たすために必要な最小限の桁数(指数と末尾のゼロを除く)
で表現されます~\cite{howtoprint,howtoread}。
そうでない場合、結果の書式は規定されていません。

{\cf number\coerce{}string}の戻り値が明示的な基数接頭辞を持つことはありません。

\begin{note}
エラーの状況は、\vr{z}が複素数でないか、
実部または虚部が有理数でない複素数の場合にのみ、発生する可能性があります。
\end{note}

\begin{rationale}
\vr{z}が不正確な数値かつ基数が10の場合、
上記の式は通常、小数点を含む結果によって満たすことが出来ます。
規定されていない結果は
無限大、NaN、あるいは普通でない表現の場合に許容されます。
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{string->number}{ string}{procedure}
\rproto{string->number}{ string radix}{procedure}}


\vr{string}によって表現された最大限に正確な表現の数値を返します。
\domain{\vr{radix}が2、8、10、16のいずれでもなければエラーです。}
\vr{radix}が指定された場合、それがデフォルトの基数となります。
これは\vr{string}に明示的な基数接頭辞 (例えば {\tt "\#o177"})
があればオーバーライドされます。
\vr{radix}が指定されなかった場合、デフォルトの基数は10です。
\vr{string}が構文的に有効な数値の表記でない場合、
または結果の数値を処理系が表現できない場合、
{\cf string->number}は\schfalse{}を返します。
\vr{string}の中身を理由にエラーが通知されることはありません。

\begin{scheme}
(string->number "100")        \ev  100
(string->number "100" 16)     \ev  256
(string->number "1e2")        \ev  100.0%
\end{scheme}

\begin{note}
{\cf string->number}の定義域は以下のように処理系によって制限される場合があります。
処理系のサポートする数値が実数のみの場合、
\vr{string}が極座標表示または直交座標表示の複素数を用いたら
{\cf string->number}は\schfalse{}を返すことが許容されます。
数値が整数のみの場合、
分数表記が使われたら\schfalse{}を返しても構いません。
正確な数値のみの場合、
指数マーカーや明示的な正確性接頭辞が使われたら\schfalse{}を返しても構いません。
不正確な数値が整数のみの場合、
小数点が使われたら\schfalse{}を返しても構いません。

内部の数値処理、I/O、プログラム処理の間で一貫性を維持するため、
ある特定の処理系が{\cf string->number}に対して用いるルールは、
{\cf read}やプログラムの読み込みルーチンにも適用されなければなりません。
それにより、-\var{string}が明示的な基数接頭辞を持っている場合は
\schfalse{}を返しても良いという \rfivers\ の記述は廃止されました。
\end{note}

\end{entry}

\section{ブーリアン}
\label{booleansection}

真および偽に対する標準のブーリアンオブジェクトは
\schtrue{}および\schfalse のように書きます。\sharpindex{t}\sharpindex{f}  
代わりに、それぞれ\sharptrue および \sharpfalse と書くことも出来ます。
これらの重要な点はSchemeの条件式
({\cf if}, {\cf cond}, {\cf and}, {\cf or}, {\cf when}, {\cf unless}, {\cf do})
が真\index{true}または偽\index{false}として扱うオブジェクトであるということです。
用語``真の値''\index{true}(または単に``真'')は
条件式において真として扱われるあらゆるオブジェクトを意味し、
用語``偽の値''\index{false}(または``偽'')は
条件式において偽として扱われるあらゆるオブジェクトを意味します。

\vest すべてのSchemeの値のうち、
\schfalse{}のみが条件式において偽とみなされます。
\schtrue{}を含め、
それ以外のすべてのSchemeの値は真とみなされます。

\begin{note}
他のLisp方言と異なり、
Schemeでは\schfalse{}と空リスト\index{empty list}はお互いに区別され、
またシンボル\ide{nil}とも区別されます。
\end{note}

\vest ブーリアン定数はそれ自身に評価されるため、プログラム中で引用する必要はありません。

\begin{scheme}
\schtrue         \ev  \schtrue
\schfalse        \ev  \schfalse
'\schfalse       \ev  \schfalse%
\end{scheme}


\begin{entry}{%
\proto{not}{ obj}{procedure}}

{\cf not}手続きは
\var{obj}が偽の場合\schtrue{}を返し、
そうでなければ\schfalse{}を返します。

\begin{scheme}
(not \schtrue)   \ev  \schfalse
(not 3)          \ev  \schfalse
(not (list 3))   \ev  \schfalse
(not \schfalse)  \ev  \schtrue
(not '())        \ev  \schfalse
(not (list))     \ev  \schfalse
(not 'nil)       \ev  \schfalse%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{boolean?}{ obj}{procedure}}

{\cf boolean?}述語は\var{obj}が\schtrue{}または\schfalse{}の場合
\schtrue{}を返し、そうでなければ\schfalse{}を返します。

\begin{scheme}
(boolean? \schfalse)  \ev  \schtrue
(boolean? 0)          \ev  \schfalse
(boolean? '())        \ev  \schfalse%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{boolean=?}{ \vari{boolean} \varii{boolean} \variii{boolean} \dotsfoo}{procedure}}

引数がすべてブーリアンで、
すべて\schtrue{}であるかすべて\schfalse{}であれば、
\schtrue{}を返します。

\end{entry}
 
\section{ペアとリスト}
\label{listsection}

\defining{ペア} (\defining{ドット対}と呼ばれることもあります)
は、(歴史的理由により) carおよびcdrという名前で呼ばれるふたつのフィールドを持つレコード構造です。
ペアは手続き{\cf cons}で作ることが出来ます。
手続き{\cf car}および{\cf cdr}でcarおよびcdrフィールドにアクセス出来ます。
手続き{\cf set-car!}および{\cf set-cdr!}でcarおよびcdrフィールドに代入出来ます。

ペアは主にリストを表現するために使われます。
\defining{リスト}は、
空リスト\index{empty list}またはcdrがリストであるペアとして、
再帰的に定義できます。
より正確に言うと、リストの集合は以下を満たす最小の集合\var{X}として定義されます。

\begin{itemize}
\item 空リストは\var{X}の要素です。
\item \var{リスト}が\var{X}の要素であれば、
      cdrフィールドに\var{リスト}を持つペアもすべて\var{X}の要素です。
\end{itemize}

リストを構成するペアのcarフィールドのオブジェクトは、そのリストの要素です。
例えば2要素のリストとは、ペアであって、そのペアのcarが最初の要素、そのペアのcdrがまたペアであって、
そのペアのcarが2番目の要素、そのペアのcdrが空リストであるようなものを言います。
リストの長さは要素の長さ、つまりペアの数と同じです。

空リスト\mainindex{empty list}は独立した型を持つ特殊なオブジェクトです。
それはペアではなく、要素を持たず、その長さはゼロです。

\begin{note}
上記の定義は、すべてのリストが有限の長さを持ち、空リストで終端することを暗黙に示しています。
\end{note}

Schemeのペアの最も汎用的な表記 (外部表現) は
\hbox{\cf (\vari{c} .\ \varii{c})}
のような``ドット''記法です。
ただし\vari{c}はcarフィールドの値で、\varii{c}はcdrフィールドの値です。
例えば {\cf (4 .\ 5)} はcarが4でありcdrが5であるペアです。
{\cf (4 .\ 5)} はペアの外部表現であって、ペアに評価される式ではないことに注意してください。

リストに対してはより流線的な記法が使われます。
単純にリストの要素をスペースで区切って括弧で囲みます。
空リスト\index{empty list}は{\tt()}と書きます。
例を挙げます。

\begin{scheme}
(a b c d e)%
\end{scheme}

これはシンボルのリストの表記で、以下と同等です。

\begin{scheme}
(a . (b . (c . (d . (e . ())))))%
\end{scheme}

空リストで終端しないペアのチェーンは\defining{非真正リスト}と呼ばれます。
非真正リストはリストではないことに注意してください。
リストとドット記法を組み合わせて非真正リストを表現することが出来ます。

\begin{scheme}
(a b c . d)%
\end{scheme}

これは以下と同等です。

\begin{scheme}
(a . (b . (c . d)))%
\end{scheme}

与えられたペアがリストであるかどうかは、cdrフィールドに何が格納されているかに依ります。
\ide{set-cdr!}手続きを使うと、
ある瞬間にはリストであったオブジェクトが次の瞬間にはそうでなくなる場合があります。

\begin{scheme}
(define x (list 'a 'b 'c))
(define y x)
y                       \ev  (a b c)
(list? y)               \ev  \schtrue
(set-cdr! x 4)          \ev  \unspecified
x                       \ev  (a . 4)
(eqv? x y)              \ev  \schtrue
y                       \ev  (a . 4)
(list? y)               \ev  \schfalse
(set-cdr! x x)          \ev  \unspecified
(list? x)               \ev  \schfalse%
\end{scheme}

リテラル式や\ide{read}手続きによって読み込んだオブジェクトの表現の中では、
\singlequote\hyper{datum}\schindex{'}、
\backquote\hyper{datum}、
{\tt,}\hyper{datum}\schindex{,}、
{\tt,@}\hyper{datum}
といった形は、最初の要素がそれぞれシンボル
\ide{quote}、\ide{quasiquote}、\hbox{\ide{unquote}}、\ide{unquote-splicing}
である2要素のリストを表します。
この規約により任意のSchemeプログラムをリストとして表現出来ます。
つまり、Schemeの文法によれば、
すべての\meta{expression}は\meta{datum}でもある、
ということです(\ref{datum}~節を参照)。
特に、これにより、{\cf read}手続きでSchemeのプログラムを解析出来るようになっています。
\ref{externalreps}~節も参照してください。
 

\begin{entry}{%
\proto{pair?}{ obj}{procedure}}

{\cf pair?}手続きは、\var{obj}がペアであれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。

\begin{scheme}
(pair? '(a . b))        \ev  \schtrue
(pair? '(a b c))        \ev  \schtrue
(pair? '())             \ev  \schfalse
(pair? '\#(a b))         \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{cons}{ \vari{obj} \varii{obj}}{procedure}}

carが\vari{obj}でありcdrが\varii{obj}である新しく割り当てられたペアを返します。
このペアは既存のいかなるオブジェクトとも({\cf eqv?}の意味で)異なることが保証されています。

\begin{scheme}
(cons 'a '())           \ev  (a)
(cons '(a) '(b c d))    \ev  ((a) b c d)
(cons "a" '(b c))       \ev  ("a" b c)
(cons 'a 3)             \ev  (a . 3)
(cons '(a b) 'c)        \ev  ((a b) . c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{car}{ pair}{procedure}}

\var{pair}のcarフィールドの内容を返します。
空リスト\index{empty list}のcarを取ることはエラーであることに注意してください。

\begin{scheme}
(car '(a b c))          \ev  a
(car '((a) b c d))      \ev  (a)
(car '(1 . 2))          \ev  1
(car '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{cdr}{ pair}{procedure}}

\var{pair}のcdrフィールドの内容を返します。
空リストのcdrを取ることはエラーであることに注意してください。

\begin{scheme}
(cdr '((a) b c d))      \ev  (b c d)
(cdr '(1 . 2))          \ev  2
(cdr '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{set-car!}{ pair obj}{procedure}}

\var{pair}のcarフィールドに\var{obj}を格納します。
\begin{scheme}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             \ev  \unspecified
(set-car! (g) 3)             \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{set-cdr!}{ pair obj}{procedure}}

\var{pair}のcdrフィールドに\var{obj}を格納します。
\end{entry}

\setbox0\hbox{\tt(cadr \var{pair})}
\setbox1\hbox{procedure}


\begin{entry}{%
\proto{caar}{ pair}{procedure}
\proto{cadr}{ pair}{procedure}
\proto{cdar}{ pair}{procedure}
\proto{cddr}{ pair}{procedure}}

これらの手続きは以下のような{\cf car}および{\cf cdr}の合成関数です。

\begin{scheme}
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{caaar}{ pair}{cxr library procedure}%
\proto{caadr}{ pair}{cxr library procedure}%
\pproto{\hbox to 1\wd0 {\hfil$\vdots$\hfil}}{\hbox to 1\wd1 {\hfil$\vdots$\hfil}}%
\mainschindex{cadar}\mainschindex{caddr}%
\mainschindex{cdaar}\mainschindex{cdadr}\mainschindex{cddar}\mainschindex{cdddr}%
\mainschindex{caaaar}\mainschindex{caaadr}\mainschindex{caadar}\mainschindex{caaddr}%
\mainschindex{cadaar}\mainschindex{cadadr}\mainschindex{caddar}\mainschindex{cadddr}%
\mainschindex{cdaaar}\mainschindex{cdaadr}\mainschindex{cdadar}\mainschindex{cdaddr}%
\mainschindex{cddaar}\mainschindex{cddadr}%
\proto{cdddar}{ pair}{cxr library procedure}%
\proto{cddddr}{ pair}{cxr library procedure}}

これら24個の手続きは同じ考え方に基づいた{\cf car}および{\cf cdr}のさらなる合成関数です。
例えば、{\cf caddr}は以下のように定義できます。

\begin{scheme}
(define caddr (lambda (x) (car (cdr (cdr x))))){\rm.}%
\end{scheme}

深さ4までのすべての組み合わせが用意されています。

\end{entry}


\begin{entry}{%
\proto{null?}{ obj}{procedure}}

\var{obj}が空リスト\index{empty list}であれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。

\end{entry}

\begin{entry}{%
\proto{list?}{ obj}{procedure}}

\var{obj}がリストであれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。
定義により、リストはすべて有限の長さを持ち、空リストで終端します。

\begin{scheme}
        (list? '(a b c))     \ev  \schtrue
        (list? '())          \ev  \schtrue
        (list? '(a . b))     \ev  \schfalse
        (let ((x (list 'a)))
          (set-cdr! x x)
          (list? x))         \ev  \schfalse%
\end{scheme}


\end{entry}

\begin{entry}{%
\proto{make-list}{ k}{procedure}
\rproto{make-list}{ k fill}{procedure}}

\var{k}要素の新しく割り当てられたリストを返します。
第2引数が指定された場合は、その各要素が\var{fill}に初期化されます。
そうでなければ、各要素の初期内容は規定されていません。

\begin{scheme}
(make-list 2 3)   \ev   (3 3)%
\end{scheme}

\end{entry}



\begin{entry}{%
\proto{list}{ \var{obj} \dotsfoo}{procedure}}

その引数から成る新しく割り当てられたリストを返します。

\begin{scheme}
(list 'a (+ 3 4) 'c)            \ev  (a 7 c)
(list)                          \ev  ()%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{length}{ list}{procedure}}

\var{list}の長さを返します。

\begin{scheme}
(length '(a b c))               \ev  3
(length '(a (b) (c d e)))       \ev  3
(length '())                    \ev  0%
\end{scheme}


\end{entry}


\begin{entry}{%
\proto{append}{ list \dotsfoo}{procedure}}

\domain{最後の引数(もしあれば)は任意の型を指定できます。}
最初の\var{list}の要素に他の\var{list}の要素を続けたものを要素とするリストを返します。
引数が無ければ、空リストが返されます。
引数がひとつだけの場合は、それが返されます。
それ以外の場合は、結果のリストは常に新しく割り当てられますが、最後の引数の構造は共有します。
最後の引数が真正リストでなければ、結果は非真正リストです。

\begin{scheme}
(append '(x) '(y))              \ev  (x y)
(append '(a) '(b c d))          \ev  (a b c d)
(append '(a (b)) '((c)))        \ev  (a (b) (c))%
\end{scheme}


\begin{scheme}
(append '(a b) '(c . d))        \ev  (a b c . d)
(append '() 'a)                 \ev  a%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{reverse}{ list}{procedure}}

\var{list}の要素から成る逆順の新しく割り当てられたリストを返します。

\begin{scheme}
(reverse '(a b c))              \ev  (c b a)
(reverse '(a (b c) d (e (f))))  \lev  ((e (f)) d (b c) a)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list-tail}{ list \vr{k}}{procedure}}

\domain{\var{list}の要素が\vr{k}個より少ない場合はエラーです。}
最初の\vr{k}個の要素を除いて得られる\var{list}の部分リストを返します。

\begin{scheme}
(define list-tail
  (lambda (x k)
    (if (zero? k)
        x
        (list-tail (cdr x) (- k 1)))))%
\end{scheme} 
\end{entry}


\begin{entry}{%
\proto{list-ref}{ list \vr{k}}{procedure}}

\domain{\var{list}引数は循環構造でも構いません。
\var{list}の要素が\vr{k}個より少ない場合はエラーです。}
\var{list}の\vr{k}番目の要素を返します。
(これは {\tt(list-tail \var{list} \vr{k})} のcarと同じです。)

\begin{scheme}
(list-ref '(a b c d) 2)                 \ev  c
(list-ref '(a b c d)
          (exact (round 1.8))) \lev  c%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{list-set!}{ list k obj}{procedure}}

\domain{\vr{k}が\var{list}の有効なインデックスでない場合はエラーです。}
{\cf list-set!}手続きは\var{list}の\vr{k}番目の要素に\var{obj}を格納します。
\begin{scheme}
(let ((ls (list 'one 'two 'five!)))
  (list-set! ls 2 'three)
  ls)      \lev  (one two three)

(list-set! '(0 1 2) 1 "oops")  \lev  \scherror  ; constant list%
\end{scheme}
\end{entry}




\begin{entry}{%
\proto{memq}{ obj list}{procedure}
\proto{memv}{ obj list}{procedure}
\proto{member}{ obj list}{procedure}
\rproto{member}{ obj list compare}{procedure}}

これらの手続きはcarが\var{obj}である最初の\var{list}の部分リストを返します。
\var{list}の部分リストは
{\tt (list-tail \var{list} \var{k})}によって返される空でないリストです
(\var{k}は\var{list}の長さより小さいものとします)。
\var{list}内に\var{obj}が現れない場合は、
\schfalse{}が返されます(空リストではありません)。
{\cf memq}手続きは\var{obj}と\var{list}の要素との比較に{\cf eq?}を用いるのに対して、
{\cf memv}は{\cf eqv?}を用い、
{\cf member}は\var{compare}が指定された場合はそれを用い、そうでなければ{\cf equal?}を用います。

\begin{scheme}
(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(member "B"
        '("a" "b" "c")
        string-ci=?)            \ev  ("b" "c")
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{assq}{ obj alist}{procedure}
\proto{assv}{ obj alist}{procedure}
\proto{assoc}{ obj alist}{procedure}
\rproto{assoc}{ obj alist compare}{procedure}}

\domain{\var{alist}(``association list''(連想リスト)の略)がペアのリストでなければエラーです。}
これらの手続きはcarフィールドが\var{obj}である\var{alist}内の最初のペアを探し、
そのペアを返します。
carに\var{obj}を持つペアが\var{alist}内に無ければ、
\schfalse{}が返されます(空リストではありません)。
{\cf assq}手続きは\var{obj}と\var{alist}内のペアのcarフィールドとの比較に{\cf eq?}を用いるのに対して、
{\cf assv}は{\cf eqv?}を用い、
{\cf assoc}は\var{compare}が指定された場合はそれを用い、そうでなければ{\cf equal?}を用います。

\begin{scheme}
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assoc 2.0 '((1 1) (2 4) (3 9)) =)
                           \ev (2 4)
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}


\begin{rationale}
{\cf memq}、{\cf memv}、{\cf member}、{\cf assq}、{\cf assv}および{\cf assoc}は、
よく述語として用いられはしますが、名前に疑問符は付いていません。
これは、単なる\schtrue{}または\schfalse{}でなく、
場合によっては有用な値を返すためです。
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{list-copy}{ obj}{procedure}}

\var{obj}がリストの場合、その新しく割り当てられたコピーを返します。
コピーされるのはペア自身だけです。
結果のcarは\var{list}のcarと({\cf eqv?}の意味で)同じになります。
\var{obj}が非真正リストの場合、結果も非真正リストとなり、
最後のcdrは{\cf eqv?}の意味で同じになります。
\var{obj}がリストでない場合はそのまま返されます。
\var{obj}が循環リストの場合はエラーです。

\begin{scheme}
(define a '(1 8 2 8)) ; a may be immutable
(define b (list-copy a))
(set-car! b 3)        ; b is mutable
b \ev (3 8 2 8)
a \ev (1 8 2 8)%
\end{scheme}

\end{entry}


\section{シンボル}
\label{symbolsection}

シンボルは、その名前が同じ綴りである場合に限り({\cf eqv?}の意味で)等しい
という事実に有用性があるオブジェクトです。
例えば、他の言語では列挙型を使うような場面で使うことが出来ます。

\vest シンボルの書き方の規則は識別子の書き方の規則とまったく同じです。
\ref{syntaxsection}~節および\ref{identifiersyntax}~節を参照してください。

\vest リテラル式の一部として返され、または{\cf read}手続きを用いて読み込まれ、
その後{\cf write}手続きを用いて書き出されたシンボルはすべて、
({\cf eqv?}の意味で)同一のシンボルとして読み戻されます。

\begin{note}
``インターン化されていないシンボル''として知られている、
write/read不変則を破る値を持つ処理系もあります。
またこれは、2つのシンボルの名前が同じ綴りの場合に限り同じであるという規則にも違反するものです。
この報告書ではそのような処理系依存の拡張の動作は規定されていません。
\end{note}


\begin{entry}{%
\proto{symbol?}{ obj}{procedure}}

\var{obj}がシンボルであれば\schtrue{}を返し、そうでなければ\schfalse{}を返します。

\begin{scheme}
(symbol? 'foo)          \ev  \schtrue
(symbol? (car '(a b)))  \ev  \schtrue
(symbol? "bar")         \ev  \schfalse
(symbol? 'nil)          \ev  \schtrue
(symbol? '())           \ev  \schfalse
(symbol? \schfalse)     \ev  \schfalse%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{symbol=?}{ \vari{symbol} \varii{symbol} \variii{symbol} \dotsfoo}{procedure}}

引数がすべてシンボルであり、その名前がすべて({\cf string=?}の意味で)同じであれば、
\schtrue{}を返します。

\begin{note}
上記の定義は、どの引数もインターン化されていないシンボルではないという想定に基づいています。
\end{note}

\end{entry}

\begin{entry}{%
\proto{symbol->string}{ symbol}{procedure}}

\var{symbol}の名前を文字列として返します。
ただしエスケープは行われていません。
この手続きが返した文字列に\ide{string-set!}のような変更手続きを適用するのはエラーです。

\begin{scheme}
(symbol->string 'flying-fish)     
                                  \ev  "flying-fish"
(symbol->string 'Martin)          \ev  "Martin"
(symbol->string
   (string->symbol "Malvina"))     
                                  \ev  "Malvina"%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{string->symbol}{ string}{procedure}}

名前が\var{string}であるシンボルを返します。
この手続きにより、書き出すときにエスケープが必要な特殊な文字を含む名前のシンボルを
作ることが出来ますが、入力中のエスケープは解釈されません。

\begin{scheme}
(string->symbol "mISSISSIppi")  \lev%
  mISSISSIppi
(eqv? 'bitBlt (string->symbol "bitBlt"))     \lev  \schtrue
(eqv? 'LollyPop
     (string->symbol
       (symbol->string 'LollyPop)))  \lev  \schtrue
(string=? "K. Harper, M.D."
          (symbol->string
            (string->symbol "K. Harper, M.D.")))  \lev  \schtrue%
\end{scheme}

\end{entry}


\section{文字}
\label{charactersection}

文字はアルファベットや数字のような印刷文字を表現するオブジェクトです。
Schemeの処理系はすべて、少なくともASCII文字のレパートリーをサポートしていなければなりません。
つまり、Unicode文字の U+0000 から U+007F までです。
処理系は、他の好きなUnicode文字をサポートしていても構いませんし、
同様に非Unicode文字をサポートしていても構いません。
特に規定のない限り、
以下の手続きに非Unicode文字を適用した結果は処理系依存です。

文字は \sharpsign\backwhack\hyper{character} または
\sharpsign\backwhack\hyper{character name} または
\sharpsign\backwhack{}x\meta{hex scalar value} の記法を用いて書かれます。

以下の文字名は記載された値と共にすべての処理系でサポートされていなければなりません。
処理系は他の名前を追加しても構いませんが、
{\cf x}を前置した hex scalar value として解釈可能でない場合に限ります。

$$
\begin{tabular}{ll}
{\tt \#\backwhack{}alarm}&; \textrm{U+0007}\\
{\tt \#\backwhack{}backspace}&; \textrm{U+0008}\\
{\tt \#\backwhack{}delete}&; \textrm{U+007F}\\
{\tt \#\backwhack{}escape}&; \textrm{U+001B}\\
{\tt \#\backwhack{}newline}&; 改行文字, \textrm{U+000A}\\
{\tt \#\backwhack{}null}&; 空文字, \textrm{U+0000}\\
{\tt \#\backwhack{}return}&; 復帰文字, \textrm{U+000D}\\
{\tt \#\backwhack{}space}&; 空白を書く望ましい方法\\
{\tt \#\backwhack{}tab}&; タブ文字, \textrm{U+0009}\\
\end{tabular}
$$

以下に追加の例を示します。

$$
\begin{tabular}{ll}
{\tt \#\backwhack{}a}&; 小文字\\
{\tt \#\backwhack{}A}&; 大文字\\
{\tt \#\backwhack{}(}&; 開き括弧\\
{\tt \#\backwhack{} }&; 空白文字\\
{\tt \#\backwhack{}x03BB}&; $\lambda$ (その文字がサポートされている場合)\\
{\tt \#\backwhack{}iota}&; $\iota$ (その文字および名前がサポートされている場合)\\
\end{tabular}
$$

\sharpsign\backwhack\hyper{character}
および
\sharpsign\backwhack{\rm$\langle$character name$\rangle$}
では大文字小文字は区別されますが、
{\cf\sharpsign\backwhack{}x}\meta{hex scalar value}
では区別されません。
\sharpsign\backwhack\hyper{character} 内の
\hyper{character} がアルファベットの場合、
\hyper{character} の直後の文字が識別子に使われるものであってはなりません。
この規則は曖昧なケースを解決するためのものです。
曖昧なケースというのは、例えば
``{\tt\sharpsign\backwhack space}'' という文字の並びは、
空白文字の表現とも、
文字表現 ``{\tt\sharpsign\backwhack s}'' に
シンボルの表現 ``{\tt pace}'' が続いたものとも取れます。

\todo{Fix}
\sharpsign\backwhack{} 記法で書かれた文字はそれ自身に評価されます。
つまり、プログラム中で引用する必要はありません。

\vest 文字を操作する手続きには大文字と小文字の違いを無視するものがあります。
大文字小文字を無視する手続きは名前に
\hbox{``{\tt -ci}''} (``case insensitive''の略) が入っています。


\begin{entry}{%
\proto{char?}{ obj}{procedure}}

\var{obj}が文字であれば\schtrue{}を返し、そうでなければ\schfalse{}を返します。

\end{entry}


\begin{entry}{%
\proto{char=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{procedure}
\proto{char<?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{procedure}
\proto{char>?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{procedure}
\proto{char<=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{procedure}
\proto{char>=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{procedure}}

\label{characterequality}

これらの手続きは引数を{\cf char\coerce{}integer}に渡した結果がそれぞれ
等しい、単調に増加している、単調に減少している、
単調に減少していない、または単調に増加していない場合に
\schtrue{}を返します。

これらの述語は推移的であることが要求されます。

\end{entry}


\begin{entry}{%
\proto{char-ci=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{char library procedure}
\proto{char-ci<?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{char library procedure}
\proto{char-ci>?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{char library procedure}
\proto{char-ci<=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{char library procedure}
\proto{char-ci>=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{char library procedure}}

これらの手続きは{\cf char=?}等に似ていますが、大文字と小文字を同じとみなす点が異なります。
例えば、 {\cf (char-ci=?\ \#\backwhack{}A \#\backwhack{}a)} は\schtrue{}を返します。

具体的には、これらの手続きは比較前に引数に{\cf char-foldcase}を適用したかのように動作します。

\end{entry}


\begin{entry}{%
\proto{char-alphabetic?}{ char}{char library procedure}
\proto{char-numeric?}{ char}{char library procedure}
\proto{char-whitespace?}{ char}{char library procedure}
\proto{char-upper-case?}{ letter}{char library procedure}
\proto{char-lower-case?}{ letter}{char library procedure}}

これらの手続きは、引数がそれぞれアルファベットである、数字である、ホワイトスペースである、
大文字である、または小文字である場合に\schtrue{}を返し、
そうでなければ\schfalse{}を返します。

具体的には、これらはそれぞれUnicodeのプロパティである
Alphabetic, Numeric\_Digit, White\_Space, Uppercase, Lowercase
を持つ文字に適用すると\schtrue{}を返し、
そうでないUnicode文字に適用すると\schfalse{}を返します。
アルファベットでありながら大文字でも小文字でもない文字が
Unicodeにはたくさんあることに注意してください。

\end{entry}


\begin{entry}{%
\proto{digit-value}{ char}{char library procedure}}

この手続きは引数が数字(つまり{\cf char-numeric?}が\schtrue{}を返す)の場合、
その引数の数値(0から9)を返し、それ以外の文字に対しては\schfalse{}を返します。

\begin{scheme}
(digit-value \#\backwhack{}3) \ev 3
(digit-value \#\backwhack{}x0664) \ev 4
(digit-value \#\backwhack{}x0AE6) \ev 0
(digit-value \#\backwhack{}x0EA6) \ev \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{char->integer}{ char}{procedure}
\proto{integer->char}{ \vr{n}}{procedure}}

{\cf char\coerce{}integer}にUnicode文字を与えると、
その文字のUnicodeスカラー値と等しい
0〜{\tt \#xD7FF}または{\tt \#xE000}〜{\tt \#x10FFFF}の
正確な整数を返します。
非Unicode文字を与えると、
{\tt \#x10FFFF}より大きい正確な整数を返します。
処理系が内部的にUnicode表現を用いているか否かに関係なく、このように動作します。

ある文字を{\cf char\coerce{}integer}に適用して返された正確な整数を
{\cf integer\coerce{}char}に与えると、その文字を返します。
\end{entry}


\begin{entry}{%
\proto{char-upcase}{ char}{char library procedure}
\proto{char-downcase}{ char}{char library procedure}
\proto{char-foldcase}{ char}{char library procedure}}


{\cf char-upcase}手続きは、
Unicode大文字小文字ペアの小文字を引数に与えると、その大文字を返します。
ただしそのScheme処理系がその両方の文字をサポートしている場合に限ります。
言語固有の大文字小文字ペアは用いられないことに注意してください。
引数がそのようなペアの小文字でなかった場合は、引数がそのまま返されます。

Unicode大文字小文字ペアの大文字を引数に与えると、その小文字を返します。
ただしそのScheme処理系がその両方の文字をサポートしている場合に限ります。
言語固有の大文字小文字ペアは用いられないことに注意してください。
引数がそのようなペアの大文字でなかった場合は、引数がそのまま返されます。

{\cf char-foldcase}は引数に対して
Unicodeの単純な大文字小文字畳み込みアルゴリズム
を適用し、その結果を返します。
言語固有の畳み込みは用いられないことに注意してください。
引数が大文字の場合、結果は小文字であるか、
その小文字が存在しないまたは処理系がサポートしていない場合は引数がそのまま返されます。
詳細は UAX \#29~\cite{uax29} (Unicode標準の一部) を参照してください。

対応する大文字がない小文字がUnicodeにはたくさんあることに注意してください。

\end{entry}


\section{文字列}
\label{stringsection}

文字列は文字の並びです。
\vest 文字列はダブルクォート({\cf "})で囲まれた文字の並びとして書かれます。
文字列リテラル内では、
様々なエスケープシーケンス\mainindex{escape sequence}が特別に解釈されます。
エスケープシーケンスは必ず(\backwhack{})で始まります。

\begin{itemize}
\item{\cf\backwhack{}a} : アラーム, U+0007
\item{\cf\backwhack{}b} : バックペース, U+0008 
\item{\cf\backwhack{}t} : タブ, U+0009 
\item{\cf\backwhack{}n} : 改行, U+000A 
\item{\cf\backwhack{}r} : 復帰, U+000D 
\item{\cf\backwhack{}}\verb|"| : ダブルクォート, U+0022 
\item{\cf\backwhack{}\backwhack{}} : バックスラッシュ, U+005C 
\item{\cf\backwhack{}|} : 垂直線, U+007C
\item{\cf\backwhack{}\arbno{\hyper{intraline whitespace}}\hyper{line ending}
      \arbno{\hyper{intraline whitespace}}} : 何も無し
\item{\cf\backwhack{}x\meta{hex scalar value};} : 指定された文字
(最後にセミコロンが付いていることに注意)
\end{itemize}

文字列中でバックスラッシュの後にこれ以外の文字が続いた場合の結果は規定されていません。

\vest 文字列リテラル中のエスケープシーケンス外の任意の文字は、改行を除き、
それ自身を表します。
{\cf\backwhack{}\hyper{intraline whitespace}} に改行が続いたものは
(後続の intraline whitespace も含めて) 何も無しに展開されるので、
可読性向上のため文字列をインデントするのに使うことが出来ます。
それ以外の改行はすべて文字列中に {\cf\backwhack{}n} 文字を入れるのと
同じ効果を持ちます。

例を挙げます。

\begin{scheme}
"The word \backwhack{}"recursion\backwhack{}" has many meanings."
"Another example:\backwhack{}ntwo lines of text"
"Here's text \backwhack{} 
   containing just one line"
"\backwhack{}x03B1; is named GREEK SMALL LETTER ALPHA."%
\end{scheme}

\vest 文字列に含まれる文字の数を、その文字列の{\em 長さ}と言います。
この数値は正確な非負の整数で、文字列の作成時に固定されます。
文字列の長さ未満の正確な非負の整数を、その文字列の\defining{有効なインデックス}と言います。
文字列の最初の文字のインデックスは0で、二番目の文字のインデックスは1で、以下同様です。


\vest 文字列を操作する手続きには大文字と小文字の違いを無視するものがあります。
大文字小文字を無視するバージョンは名前の最後に
\hbox{``{\cf -ci}''} (``case insensitive''の略)が付いています。

処理系によっては文字列中に特定の文字が現れることを禁止している場合があります。
ただし、{\tt \#\backwhack{}null}以外のASCII文字が禁止されることはありません。
例えば、Unicodeのレパートリー全体をサポートするけれども
文字列中では U+0001〜U+00FF ({\tt \#\backwhack{}null} を除く Latin-1 のレパートリー)
しか使えない処理系などが有り得ます。

そのような禁止文字を
{\cf make-string}、{\cf string}、{\cf string-set!}、{\cf string-fill!}
に渡したり、リストの一部として{\cf list\coerce{}string}に渡したり、
ベクタの一部として{\cf vector\coerce{}string} (\ref{vectortostring}~節を参照)
に渡したり、バイトベクタ内にUTF-8エンコードされた形で
{\cf utf8\coerce{}string} (\ref{utf8tostring}~節を参照)に渡すことはエラーです。
また{\cf string-map} (\ref{stringmap}~節を参照) に渡した手続きが禁止文字を返したり、
{\cf read-string} (\ref{readstring}~節を参照) に禁止文字を読ませようと
試みることもエラーです。

\begin{entry}{%
\proto{string?}{ obj}{procedure}}

\var{obj}が文字列であれば\schtrue{}を返し、そうでなければ\schfalse{}を返します。
\end{entry}


\begin{entry}{%
\proto{make-string}{ \vr{k}}{procedure}
\rproto{make-string}{ \vr{k} char}{procedure}}

{\cf make-string}手続きは新しく割り当てられた長さ\vr{k}の文字列を返します。
\var{char}が与えられた場合は、その文字列のすべての文字が\var{char}で初期化されます。
そうでなければ、文字列の内容は規定されていません。

\end{entry}

\begin{entry}{%
\proto{string}{ char \dotsfoo}{procedure}}

引数から成る新しく割り当てられた文字列を返します。
これは{\cf list}の類似品です。

\end{entry}

\begin{entry}{%
\proto{string-length}{ string}{procedure}}

与えられた\var{string}の文字数を返します。
\end{entry}


\begin{entry}{%
\proto{string-ref}{ string \vr{k}}{procedure}}

\domain{\vr{k}が\var{string}の有効なインデックスでなければエラーです。}
{\cf string-ref}手続きは\var{string}の\vr{k}番目の文字を返します。
インデックスはゼロオリジンです。
\end{entry}
この手続きを定数時間で実行することは要求されていません。


\begin{entry}{%
\proto{string-set!}{ string k char}{procedure}}

\domain{\vr{k}が\var{string}の有効なインデックスでなければエラーです。}
{\cf string-set!}手続きは\var{string}の\vr{k}番目の要素に\var{char}を格納します。
この手続きを定数時間で実行することは要求されていません。

\begin{scheme}
(define (f) (make-string 3 \sharpsign\backwhack{}*))
(define (g) "***")
(string-set! (f) 0 \sharpsign\backwhack{}?)  \ev  \unspecified
(string-set! (g) 0 \sharpsign\backwhack{}?)  \ev  \scherror
(string-set! (symbol->string 'immutable)
             0
             \sharpsign\backwhack{}?)  \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{string=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{procedure}}

すべての文字列が同じ長さで、正確に同じ文字を同じ位置に持つ場合、\schtrue{}を返し、
そうでなければ\schfalse{}を返します。

\end{entry}

\begin{entry}{%
\proto{string-ci=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{char library procedure}}

大文字小文字畳み込みの後、
すべての文字列が同じ長さで、同じ位置に同じ文字を持つ場合、\schtrue{}を返し、
そうでなければ\schfalse{}を返します。
具体的には、これらの手続きは比較前に引数に{\cf string-foldcase}を適用したかのように動作します。

\end{entry}


\begin{entry}{%
\proto{string<?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{procedure}
\proto{string-ci<?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{char library procedure}
\proto{string>?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{procedure}
\proto{string-ci>?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{char library procedure}
\proto{string<=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{procedure}
\proto{string-ci<=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{char library procedure}
\proto{string>=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{procedure}
\proto{string-ci>=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{char library procedure}}

これらの手続きは引数がそれぞれ単調に増加している、単調に減少している、
単調に増加していない、または単調に減少していない場合に\schtrue{}を返します。

これらの手続きは推移的であることが要求されます。

これらの手続きは処理系定義の方法で文字列を比較します。
ひとつの方法として、
文字に対する順序付けを文字列に辞書的に拡張することが考えられます。
その場合{\cf string<?}は、文字に対する{\cf char<?}の順序付けによって
文字列に対する辞書的な順序付けを行うことになるでしょう。
また、2つの文字列の長さが異なるものの短い方の文字列の長さまでは同じ内容の場合、
短い方の文字列は長い方の文字列よりも辞書的に小さいと考えられます。
しかし、処理系の文字列の内部表現による自然な順序付けや、
より複雑なロケール固有の順序付けを用いることも許容されます。

いずれの場合でも、ある一組の文字列に対しては
{\cf string<?}、{\cf string=?}、{\cf string>?}
のうちひとつだけが満たされなければならず、
{\cf string>?}が満たされない場合に限り{\cf string<=?}が満たされなければならず、
{\cf string<?}が満たされない場合に限り{\cf string>=?}が満たされなければなりません。

\hbox{``{\tt -ci}''}付き手続きは、
対応する\hbox{``{\tt -ci}''}無しの手続きを呼ぶ前に
引数に{\cf string-foldcase}を適用したかのように動作します。


\end{entry}

\begin{entry}{%
\proto{string-upcase}{ string}{char library procedure}
\proto{string-downcase}{ string}{char library procedure}
\proto{string-foldcase}{ string}{char library procedure}}


これらの手続きは、引数に対して
Unicodeの完全な大文字小文字変換アルゴリズム
を適用し、その結果を返します。
場合によっては、結果の長さが引数と異なることもあります。
結果が引数と{\cf string=?}の意味で同じ場合、その引数が返される場合があります。
ちなみに、言語固有のマッピングおよび畳み込みは用いられません。

Unicode標準ではギリシア文字の $\Sigma$ に特別な扱いが規定されており、
通常の小文字形は $\sigma$ ですが、
単語の終わりに来た場合は $\varsigma$ になります。
詳細は UAX \#29~\cite{uax29} (Unicode標準の一部) を参照してください。
しかし、{\cf string-downcase}の実装にこの動作を行うことは要求されません。
すべての場合において $\Sigma$ を $\sigma$ に変換しても構いません。

\end{entry}


\begin{entry}{%
\proto{substring}{ string start end}{procedure}}

{\cf substring}手続きは
\var{string}内のインデックス\var{start}で始まりインデックス\var{end}で終わる文字から成る
新しく割り当てられた文字列を返します。
これは同じ引数で{\cf string-copy}を呼ぶのと同等ですが、
後方互換性およびスタイル上の柔軟性のために用意されています。
\end{entry}


\begin{entry}{%
\proto{string-append}{ \var{string} \dotsfoo}{procedure}}

与えられた文字列の文字を連結した文字を持つ新しく割り当てられた文字列を返します。

\end{entry}


\begin{entry}{%
\proto{string->list}{ string}{procedure}
\rproto{string->list}{ string start}{procedure}
\rproto{string->list}{ string start end}{procedure}
\proto{list->string}{ list}{procedure}}

\domain{\var{list}の要素のいずれかが文字でなければエラーです。}
{\cf string\coerce{}list}手続きは\var{string}内の\var{start}〜\var{end}間の文字の
新しく割り当てられたリストを返します。
{\cf list\coerce{}string}はリスト\var{list}内の要素から成る
新しく割り当てられた文字列を返します。
どちらの手続きでも順番は維持されます。
{\cf equal?}の意味において
{\cf string\coerce{}list}および{\cf list\coerce{}string}はお互い逆関数です。

\end{entry}


\begin{entry}{%
\proto{string-copy}{ string}{procedure}
\rproto{string-copy}{ string start}{procedure}
\rproto{string-copy}{ string start end}{procedure}}

与えられた\var{string}の\var{start}〜\var{end}の部分の
新しく割り当てられたコピーを返します。

\end{entry}


\begin{entry}{%
\proto{string-copy!}{ to at from}{procedure}
\rproto{string-copy!}{ to at from start}{procedure}
\rproto{string-copy!}{ to at from start end}{procedure}}

\domain{\var{at}がゼロより小さいか\var{to}の長さより大きい場合はエラーです。
{\cf (- (string-length \var{to}) \var{at})} が
{\cf (- \var{end} \var{start})} より小さい場合もエラーです。}
文字列\var{from}の\var{start}〜\var{end}間の文字を、
文字列\var{to}の\var{at}から始まる位置にコピーします。
文字がコピーされる順番は規定されていません。
ただし転送元と転送先が重なっている場合は、
転送元がいったん一時的な文字列にコピーされ、
それから転送先にコピーされたかのように動作します。
正しい方向でコピーを行うように気を付ければ、
そのような状況でも領域を割り当てることなくこれを行うことが出来ます。

\begin{scheme}
(define a "12345")
(define b (string-copy "abcde"))
(string-copy! b 1 a 0 2)
b \ev "a12de"%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{string-fill!}{ string fill}{procedure}
\rproto{string-fill!}{ string fill start}{procedure}
\rproto{string-fill!}{ string fill start end}{procedure}}

\domain{\var{fill}が文字でなければエラーです。}

{\cf string-fill!}手続きは\var{string}の\var{start}〜\var{end}の要素に
\var{fill}を格納します。

\end{entry}


\section{ベクタ}
\label{vectorsection}

ベクタは要素を整数でインデックスする異種混合の構造体です。
ベクタは一般的に同じ長さのリストよりも小さな空間しか使用せず、
一般的にランダムに選んだ要素のアクセスに必要な平均時間が
リストよりもベクタの方が小さくて済みます。

\vest ベクタが持つ要素の数をそのベクタの{\em 長さ}と言います。
この数は非負の整数で、ベクタの作成時に固定されます。
ベクタの長さよりも小さい正確な非負の整数を、そのベクタの
{\em 有効なインデックス}\index{valid indexes}と言います。
ベクタの最初の要素のインデックスは0で、
最後の要素のインデックスはベクタの長さよりも1小さい値です。

ベクタは {\tt\#(\var{obj} \dotsfoo)} という表記を用いて書きます。
例えば、0番目の要素に数値のゼロ、1番目の要素にリスト {\cf(2 2 2 2)}、
2番目の要素に文字列 {\cf "Anna"} を持つ長さ3のベクタは、
以下のように書くことが出来ます。

\begin{scheme}
\#(0 (2 2 2 2) "Anna")%
\end{scheme}

ベクタ定数はそれ自身に評価されます。
そのため、プログラム中で引用する必要はありません。

\begin{entry}{%
\proto{vector?}{ obj}{procedure}}
 
\var{obj}がベクタであれば\schtrue{}を返し、そうでなければ\schfalse{}を返します。
\end{entry}


\begin{entry}{%
\proto{make-vector}{ k}{procedure}
\rproto{make-vector}{ k fill}{procedure}}

\var{k}個の要素を持つ新しく割り当てられたベクタを返します。
第2引数が与えられた場合、各要素は\var{fill}に初期化されます。
そうでなければ、各要素の初期内容は規定されていません。

\end{entry}


\begin{entry}{%
\proto{vector}{ obj \dotsfoo}{procedure}}

与えられた引数を要素に持つ新しく割り当てられたベクタを返します。
これは{\cf list}の類似品です。

\begin{scheme}
(vector 'a 'b 'c)               \ev  \#(a b c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-length}{ vector}{procedure}}

\var{vector}の要素の数を正確な整数として返します。
\end{entry}


\begin{entry}{%
\proto{vector-ref}{ vector k}{procedure}}

\domain{\vr{k}が\var{vector}の有効なインデックスでなければエラーです。}
{\cf vector-ref}手続きは\var{vector}の\vr{k}番目の要素の内容を返します。

\begin{scheme}
(vector-ref '\#(1 1 2 3 5 8 13 21)
            5)  \lev  8
(vector-ref '\#(1 1 2 3 5 8 13 21)
            (exact
             (round (* 2 (acos -1))))) \lev 13%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-set!}{ vector k obj}{procedure}}

\domain{\vr{k}が\var{vector}の有効なインデックスでなければエラーです。}
{\cf vector-set!}手続きは\var{vector}の\vr{k}番目の要素に\var{obj}を格納します。
\begin{scheme}
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)      \lev  \#(0 ("Sue" "Sue") "Anna")

(vector-set! '\#(0 1 2) 1 "doe")  \lev  \scherror  ; constant vector%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector->list}{ vector}{procedure}
\rproto{vector->list}{ vector start}{procedure}
\rproto{vector->list}{ vector start end}{procedure}
\proto{list->vector}{ list}{procedure}}

{\cf vector->list}手続きは\var{vector}の\var{start}〜\var{end}の要素に
格納されているオブジェクトから成る新しく割り当てられたリストを返します。
{\cf list->vector}手続きはリスト\var{list}の要素に初期化されている
新しく割り当てられたベクタを返します。

どちらの手続きでも順番は維持されます。

\begin{scheme}
(vector->list '\#(dah dah didah))  \lev  (dah dah didah)
(vector->list '\#(dah dah didah) 1 2) \lev (dah)
(list->vector '(dididit dah))   \lev  \#(dididit dah)%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{vector->string}{ vector}{procedure}
\rproto{vector->string}{ vector start}{procedure}
\rproto{vector->string}{ vector start end}{procedure}
\proto{string->vector}{ string}{procedure}
\rproto{string->vector}{ string start}{procedure}
\rproto{string->vector}{ string start end}{procedure}}
\label{vectortostring}

\domain{\var{vector}の\var{start}〜\var{end}の要素の
いずれかが文字でなければエラーです。}
{\cf vector->string}手続きは\var{vector}の\var{start}〜\var{end}の要素に
格納されているオブジェクトから成る新しく割り当てられた文字列を返します。
{\cf string->vector}手続きは文字列\var{string}の\var{start}〜\var{end}の要素に
初期化されている新しく割り当てられたベクタを返します。

どちらの手続きでも順番は維持されます。


\begin{scheme}
(string->vector "ABC")  \ev   \#(\#\backwhack{}A \#\backwhack{}B \#\backwhack{}C)
(vector->string
  \#(\#\backwhack{}1 \#\backwhack{}2 \#\backwhack{}3) \ev "123"
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{vector-copy}{ vector}{procedure}
\rproto{vector-copy}{ vector start}{procedure}
\rproto{vector-copy}{ vector start end}{procedure}}

与えられた\var{vector}の\var{start}〜\var{end}の要素の
新しく割り当てられたコピーを返します。
新しいベクタの要素は古いベクタの要素と
({\cf eqv?}の意味で)同じです。


\begin{scheme}
(define a \#(1 8 2 8)) ; a may be immutable
(define b (vector-copy a))
(vector-set! b 0 3)   ; b is mutable
b \ev \#(3 8 2 8)
(define c (vector-copy b 1 3))
c \ev \#(8 2)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-copy!}{ to at from}{procedure}
\rproto{vector-copy!}{ to at from start}{procedure}
\rproto{vector-copy!}{ to at from start end}{procedure}}

\domain{\var{at}がゼロより小さいか\var{to}の長さよりも大きい場合はエラーです。
{\cf (- (vector-length \var{to}) \var{at})} が
{\cf (- \var{end} \var{start})} より小さい場合もエラーです。}
ベクタ\var{from}の\var{start}〜\var{end}の要素を
ベクタ\var{to}の\var{at}から始まる位置にコピーします。
要素がコピーされる順番は規定されていません。
ただし転送元と転送先が重なっている場合は、
転送元がいったん一時的なベクタにコピーされ、
それから転送先にコピーされたかのように動作します。
正しい方向でコピーを行うように気を付ければ、
そのような状況でも領域を割り当てることなくこれを行うことが出来ます。

\begin{scheme}
(define a (vector 1 2 3 4 5))
(define b (vector 10 20 30 40 50))
(vector-copy! b 1 a 0 2)
b \ev \#(10 1 2 40 50)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-append}{ \var{vector} \dotsfoo}{procedure}}

与えられたベクタの要素を連結した要素を持つ新しく割り当てられたベクタを返します。

\begin{scheme}
(vector-append \#(a b c) \#(d e f)) \lev \#(a b c d e f)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-fill!}{ vector fill}{procedure}
\rproto{vector-fill!}{ vector fill start}{procedure}
\rproto{vector-fill!}{ vector fill start end}{procedure}}

{\cf vector-fill!}手続きは\var{vector}の\var{start}〜\var{end}の要素に
\var{fill}を格納します。

\begin{scheme}
(define a (vector 1 2 3 4 5))
(vector-fill! a 'smash 2 4)
a \lev \#(1 2 smash smash 5)%
\end{scheme}

\end{entry}


\section{バイトベクタ}
\label{bytevectorsection}

\defining{バイトベクタ}はバイナリデータの塊を表します。
これは固定サイズのバイトの並びです。
\defining{バイト}とは、0〜255(両端を含む)の範囲の正確な整数です。
バイトベクタは一般的に同じ値を持つベクタよりも高い空間効率を持ちます。

\vest バイトベクタが持つ要素の数をそのバイトベクタの{\em 長さ}と言います。
この数は非負の整数で、バイトベクタ作成時に固定されます。
バイトベクタの長さより小さい正確な非負の整数を、そのバイトベクタの
{\em 有効なインデックス}\index{valid indexes}と言います。
ベクタ同様にインデックスはゼロから始まります。

バイトベクタは{\tt\#u8(\var{byte} \dotsfoo)}という表記を用いて書きます。
例えば、0番目の要素にバイト0、1番目の要素にバイト10、2番目の要素にバイト5を持つ
長さ3のバイトベクタは、以下のように書くことが出来ます。

\begin{scheme}
\#u8(0 10 5)%
\end{scheme}

バイトベクタ定数はそれ自身に評価されます。
そのため、プログラム中で引用する必要はありません。


\begin{entry}{%
\proto{bytevector?}{ obj}{procedure}}

\var{obj}がバイトベクタであれば\schtrue{}を返します。
そうでなければ\schfalse{}を返します。
\end{entry}

\begin{entry}{%
\proto{make-bytevector}{ k}{procedure}
\rproto{make-bytevector}{ k byte}{procedure}}

{\cf make-bytevector}手続きは長さ\vr{k}の
新しく割り当てられたバイトベクタを返します。
\var{byte}が与えられた場合は、
そのバイトベクタのすべての要素が\var{byte}に初期化されます。
そうでなければ、各要素の内容は規定されていません。

\begin{scheme}
(make-bytevector 2 12) \ev \#u8(12 12)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{bytevector}{ \var{byte} \dotsfoo}{procedure}}

引数を持つ新しく割り当てられたバイトベクタを返します。

\begin{scheme}
(bytevector 1 3 5 1 3 5)        \ev  \#u8(1 3 5 1 3 5)
(bytevector)                          \ev  \#u8()%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector-length}{ bytevector}{procedure}}

\var{bytevector}のバイト単位の長さを正確な整数として返します。
\end{entry}

\begin{entry}{%
\proto{bytevector-u8-ref}{ bytevector k}{procedure}}

\domain{\vr{k}が\var{bytevector}の有効なインデックスでなければエラーです。}
\var{bytevector}の\var{k}番目のバイトを返します。

\begin{scheme}
(bytevector-u8-ref '\#u8(1 1 2 3 5 8 13 21)
            5)  \lev  8%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector-u8-set!}{ bytevector k byte}{procedure}}

\domain{\vr{k}が\var{bytevector}の有効なインデックスでなければエラーです。}
\var{bytevector}の\var{k}番目のバイトとして\var{byte}を格納します。
\begin{scheme}
(let ((bv (bytevector 1 2 3 4)))
  (bytevector-u8-set! bv 1 3)
  bv) \lev \#u8(1 3 3 4)%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector-copy}{ bytevector}{procedure}
\rproto{bytevector-copy}{ bytevector start}{procedure}
\rproto{bytevector-copy}{ bytevector start end}{procedure}}

\var{bytevector}の\var{start}〜\var{end}のバイトを持つ
新しく割り当てられたバイトベクタを返します。

\begin{scheme}
(define a \#u8(1 2 3 4 5))
(bytevector-copy a 2 4)) \ev \#u8(3 4)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{bytevector-copy!}{ to at from}{procedure}
\rproto{bytevector-copy!}{ to at from start}{procedure}
\rproto{bytevector-copy!}{ to at from start end}{procedure}}

\domain{\var{at}がゼロより小さいか\var{to}の長さよりも大きい場合はエラーです。
{\cf (- (bytevector-length \var{to}) \var{at})} が
{\cf (- \var{end} \var{start})} より小さい場合もエラーです。}
バイトベクタ\var{from}の\var{start}〜\var{end}のバイトを
バイトベクタ\var{to}の\var{at}から始まる位置にコピーします。
バイトがコピーされる順番は規定されていません。
ただし転送元と転送先が重なっている場合は、
転送元がいったん一時的なバイトベクタにコピーされ、
それから転送先にコピーされたかのように動作します。
正しい方向でコピーを行うように気を付ければ、
そのような状況でも領域を割り当てることなくこれを行うことが出来ます。

\begin{scheme}
(define a (bytevector 1 2 3 4 5))
(define b (bytevector 10 20 30 40 50))
(bytevector-copy! b 1 a 0 2)
b \ev \#u8(10 1 2 40 50)%
\end{scheme}

\begin{note}
この手続きは \rsixrs にもありましたが、
Schemeの他の同様の手続きとは逆に、
転送元を転送先より先に指定するようになっていました。
\end{note}

\end{entry}

\begin{entry}{%
\proto{bytevector-append}{ \var{bytevector} \dotsfoo}{procedure}}

与えられたバイトベクタの要素を連結した要素を持つ
新しく割り当てられたバイトベクタを返します。

\begin{scheme}
(bytevector-append \#u8(0 1 2) \#u8(3 4 5)) \lev \#u8(0 1 2 3 4 5)%
\end{scheme}

\end{entry}

\label{utf8tostring}
\begin{entry}{%
\proto{utf8->string}{ bytevector} {procedure}
\rproto{utf8->string}{ bytevector start} {procedure}
\rproto{utf8->string}{ bytevector start end} {procedure}
\proto{string->utf8}{ string} {procedure}
\rproto{string->utf8}{ string start} {procedure}
\rproto{string->utf8}{ string start end} {procedure}}

\domain{\var{bytevector}が無効なUTF-8バイトシーケンスを含んでいる場合はエラーです。}
これらの手続きは、文字列と、
その文字列をUTF-8エンコーディングでエンコードしたバイトベクタとの間で、
変換を行います。
{\cf utf8\coerce{}string}手続きはバイトベクタの\var{start}〜\var{end}のバイトを
デコードし、対応する文字列を返します。
{\cf string\coerce{}utf8}悦付きは文字列の\var{start}〜\var{end}の文字を
エンコードし、対応するバイトベクタを返します。

\begin{scheme}
(utf8->string \#u8(\#x41)) \ev "A"
(string->utf8 "$\lambda$") \ev \#u8(\#xCE \#xBB)%
\end{scheme}

\end{entry}

\section{制御機能}
\label{proceduresection}

この節では様々なプログラム実行の流れを特殊な方法で制御する
プリミティブ手続きについて述べます。
手続き引数を呼び出すこの節の手続きは、
必ず元の手続き呼び出しと同じ動的環境でそれを呼び出します。
{\cf procedure?}述語もここで述べます。

\begin{entry}{%
\proto{procedure?}{ obj}{procedure}}

\var{obj}が手続きであれば\schtrue{}を返し、そうでなければ\schfalse{}を返します。

\begin{scheme}
(procedure? car)            \ev  \schtrue
(procedure? 'car)           \ev  \schfalse
(procedure? (lambda (x) (* x x)))   
                            \ev  \schtrue
(procedure? '(lambda (x) (* x x)))  
                            \ev  \schfalse
(call-with-current-continuation procedure?)
                            \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{apply}{ proc \vari{arg} $\ldots$ args}{procedure}}

{\cf apply}手続きはリスト
{\cf(append (list \vari{arg} \dotsfoo) \var{args})}
の要素を実引数として\var{proc}を呼び出します。

\begin{scheme}
(apply + (list 3 4))              \ev  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)              \ev  30%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{map}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{\var{proc}が{\it list}の数と同じ数の引数を取らない場合、
および単一の値を返さない場合はエラーです。}
{\cf map}手続きは\var{list}の要素ごとに\var{proc}を適用し、
その結果の順番通りのリストを返します。
\var{list}が2つ以上与えられ、長さの異なるリストがある場合、
{\cf map}は最も短いリストを使い切った時点で終了します。
\var{list}には循環リストも使えますが、すべてのリストが循環リストであった場合はエラーです。
\var{proc}がリストのいずれかを変更した場合はエラーです。
\var{list}の要素に\var{proc}が適用される動的な順番は規定されていません。
{\cf map}からの戻りが複数回発生した場合、
先に返された値が変更されることはありません。

\begin{scheme}
(map cadr '((a b) (d e) (g h)))   \lev  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                \lev  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6 7))         \ev  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                 \ev  (1 2) \var{or} (2 1)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{string-map}{ proc \vari{string} \varii{string} \dotsfoo}{procedure}}
\label{stringmap}

\domain{\var{proc}が{\it string}の数と同じ数の引数を取らない場合、
および単一の値を返さない場合はエラーです。}
{\cf string-map}手続きは\var{string}の要素ごとに\var{proc}を適用し、
その結果の順番通りの文字列を返します。
\var{string}が2つ以上与えられ、長さの異なる文字列がある場合、
{\cf string-map}は最も短い文字列を使い切った時点で終了します。
\var{string}の要素に\var{proc}が適用される動的な順番は規定されていません。
{\cf string-map}からの戻りが複数回発生した場合、
先に返された値が変更されることはありません。

\begin{scheme}
(string-map char-foldcase "AbdEgH") \lev  "abdegh"

(string-map
 (lambda (c)
   (integer->char (+ 1 (char->integer c))))
 "HAL")                \lev  "IBM"

(string-map
 (lambda (c k)
   ((if (eqv? k \sharpsign\backwhack{}u) char-upcase char-downcase)
    c))
 "studlycaps xxx"
 "ululululul")   \lev   "StUdLyCaPs"%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-map}{ proc \vari{vector} \varii{vector} \dotsfoo}{procedure}}

\domain{\var{proc}が{\it vector}の数と同じ数の引数を取らない場合、
および単一の値を返さない場合はエラーです。}
{\cf vector-map}手続きは\var{vector}の要素ごとに\var{proc}を適用し、
その結果の順番通りのベクタを返します。
\var{vector}が2つ以上与えられ、長さの異なるベクタがある場合、
{\cf vector-map}は最も短いリストを使い切った時点で終了します。
\var{vector}の要素に\var{proc}が適用される動的な順番は規定されていません。
{\cf vector-map}からの戻りが複数回発生した場合、
先に返された値が変更されることはありません。

\begin{scheme}
(vector-map cadr '\#((a b) (d e) (g h)))   \lev  \#(b e h)

(vector-map (lambda (n) (expt n n))
            '\#(1 2 3 4 5))                \lev  \#(1 4 27 256 3125)

(vector-map + '\#(1 2 3) '\#(4 5 6 7))       \lev  \#(5 7 9)

(let ((count 0))
  (vector-map
   (lambda (ignored)
     (set! count (+ count 1))
     count)
   '\#(a b)))                     \ev  \#(1 2) \var{or} \#(2 1)%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{for-each}{ proc \vari{list} \varii{list} \dotsfoo}{procedure}}

\domain{\var{proc}が{\it list}の数と同じ数の引数を取らない場合はエラーです。}
{\cf for-each}の引数は{\cf map}の引数と同様ですが、
{\cf for-each}では値のためではなく副作用のために\var{proc}が呼ばれます。
{\cf map}と異なり、{\cf for-each}では
最初の要素から最後の要素まで順番通りに
\var{list}の要素に対して\var{proc}が呼ばれることが保証されています。
{\cf for-each}の戻り値は規定されていません。
\var{list}が2つ以上与えられ、長さの異なるリストがある場合、
{\cf for-each}は最も短いリストを使い切った時点で終了します。
\var{list}には循環リストも使えますが、すべてのリストが循環リストであった場合はエラーです。

\var{proc}がリストのいずれかを変更した場合はエラーです。


\begin{scheme}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                                \ev  \#(0 1 4 9 16)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{string-for-each}{ proc \vari{string} \varii{string} \dotsfoo}{procedure}}

\domain{\var{proc}が{\it string}の数と同じ数の引数を取らない場合はエラーです。}
{\cf string-for-each}の引数は{\cf string-map}の引数と同様ですが、
{\cf string-for-each}では値のためではなく副作用のために\var{proc}が呼ばれます。
{\cf string-map}と異なり、{\cf string-for-each}では
最初の要素から最後の要素まで順番通りに
\var{list}の要素に対して\var{proc}が呼ばれることが保証されています。
{\cf string-for-each}の戻り値は規定されていません。
\var{string}が2つ以上与えられ、長さの異なる文字列がある場合、
{\cf string-for-each}は最も短いリストを使い切った時点で終了します。
\var{proc}が文字列のいずれかを変更した場合はエラーです。

\begin{scheme}
(let ((v '()))
  (string-for-each
   (lambda (c) (set! v (cons (char->integer c) v)))
   "abcde")
  v)                         \ev  (101 100 99 98 97)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-for-each}{ proc \vari{vector} \varii{vector} \dotsfoo}{procedure}}

\domain{\var{proc}が{\it vector}の数と同じ数の引数を取らない場合はエラーです。}
{\cf vector-for-each}の引数は{\cf vector-map}の引数と同様ですが、
{\cf vector-for-each}では値のためではなく副作用のために\var{proc}が呼ばれます。
{\cf vector-map}と異なり、{\cf vector-for-each}では
最初の要素から最後の要素まで順番通りに
\var{vector}の要素に対して\var{proc}が呼ばれることが保証されています。
{\cf vector-for-each}の戻り値は規定されていません。
\var{vector}が2つ以上与えられ、長さの異なるベクタがある場合、
{\cf vector-for-each}は最も短いリストを使い切った時点で終了します。
\var{proc}がベクタのいずれかを変更した場合はエラーです。

\begin{scheme}
(let ((v (make-list 5)))
  (vector-for-each
   (lambda (i) (list-set! v i (* i i)))
   '\#(0 1 2 3 4))
  v)                                \ev  (0 1 4 9 16)%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{call-with-current-continuation}{ proc}{procedure}
\proto{call/cc}{ proc}{procedure}}

\label{continuations}
\domain{\var{proc}が引数をひとつ取らない場合はエラーです。}
手続き{\cf call-with-current-continuation} (または同等の省略形{\cf call/cc}) 
は現在の継続(後述の論拠を参照)を``脱出手続き''\mainindex{escape procedure}
としてパッケージ化し、それを引数として\var{proc}に渡します。
脱出手続きはSchemeの手続きで、後ほど呼ばれるとその時点での有効な継続を放棄し、
代わりに脱出手続き作成時点で有効であった継続を使用します。
脱出手続きを呼び出すと\ide{dynamic-wind}を用いてインストールされた
\var{before}サンクおよび\var{after}サンクが呼び出されます。

脱出手続きは\callcc{}の呼び出し元の継続と同じ数の引数を取ります。
ほとんどの継続は値をひとつだけ取ります。
{\cf call-with-values}手続き
({\cf define-values}、{\cf let-values}および{\cf let*-values}式の初期化式も含む)
によって作成された継続は、その消費者が期待している数の値を取ります。
{\cf lambda}、{\cf case-lambda}、{\cf begin}、
{\cf let}、{\cf let*}、{\cf letrec}、{\cf letrec*}、{\cf let-values}、
{\cf let*-values}、{\cf let-syntax}、{\cf letrec-syntax}、{\cf parameterize}、
{\cf guard}、{\cf case}、{\cf cond}、{\cf when}および{\cf unless}
などにおける、式の並びの中にある最後でない式の継続は、任意の数の値を取ります。
渡された値が何であれ破棄するだけだからです。
これらのいずれかによって作成されたものでない継続にゼロ個の値を渡したり
2つ以上の値を渡した場合の効果は規定されていません。


\vest \var{proc}に渡される脱出手続きは
Schemeの他のどんな手続きとも同様に無制限の存続期間を持ちます。
変数やデータ構造に格納することができ、好きな回数だけ呼ぶことが出来ます。
しかし、{\cf raise}や{\cf error}手続き同様、呼び出し元に返ることはありません。

\vest 以下の例は{\cf call-with-current-continuation}の
最も単純な用途のみを示しています。
実際の用途がすべてこの例のように単純であれば、
{\cf call-with-current-continuation}のような強力な手続きは必要ないでしょう。

\begin{scheme}
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    \schtrue))                        \ev  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return \schfalse))))))
          (r obj))))))

(list-length '(1 2 3 4))            \ev  4

(list-length '(a b . c))            \ev  \schfalse%
\end{scheme}

\begin{rationale}

\vest {\cf call-with-current-continuation}の良く有る使い方は、
ループや手続き本体からの構造化された非局所的な脱出です。
しかし{\cf call-with-current-continuation}は
幅広い様々な行動な制御構造を実装する役に立ちます。
実際、{\cf raise}および{\cf guard}は非局所的脱出のための
より構造化された仕組みです。

\vest Schemeの式が評価されるときは必ず
その結果を欲している\defining{継続}が存在しています。
継続はその計算の(デフォルトの)未来全体を表しています。
例えば、式をREPLで評価する場合、その継続は、
結果を受け取り、それを画面に出力し、次の入力のためのプロンプトを表示し、
それを評価し、以下同様に永遠に繰り返すというものです。
ほとんどの場合、継続はユーザーコードによって指定されたアクションを含みます。
結果を受け取り、ある局所変数に格納された値をそれに掛け、7を加え、
そしてその答えを出力するためにREPLの継続に引き渡す、のような感じです。
通常、これらの普遍的な継続は水面下に隠されており、
プログラマーはこれについて深く考えたりしません。
しかし、プログラマーが明示的に継続を扱わなければならない状況も稀にあります。
{\cf call-with-current-continuation}手続きが
現在の継続の同様に動作する手続きを作成することにより、
Schemeのプログラマーにはそれが可能となります。

% \vest Most programming languages incorporate one or more special-purpose
% escape constructs with names like {\tt exit}, \hbox{{\cf return}}, or
% even {\tt goto}.  In 1965, however, Peter Landin~\cite{Landin65}
% invented a general purpose escape operator called the J-operator.  John
% Reynolds~\cite{Reynolds72} described a simpler but equally powerful
% construct in 1972.  The {\cf catch} syntax described by Sussman
% and Steele in the 1975 report on Scheme is exactly the same as
% Reynolds's construct, though its name came from a less general construct
% in MacLisp.  Several Scheme implementers noticed that the full power of
% \ide{catch} could be provided by a procedure instead of by a
% special syntactic construct, and the name
% {\cf call-with-current-continuation} was coined in 1982.  This name is
% descriptive, but opinions differ on the merits of such a long name, and
% some people prefer the name \ide{call/cc} instead.
\todo{Shinn: Expand this history before restoring, possibly relegating to an appendix.}
\end{rationale}

%% \begin{note}
%% The {\cf call/cc} procedure is capable of capturing continuations
%% originating outside of Scheme when Scheme is embedded in some host
%% language. It is not always practical or even meaningful to restore
%% these continuations.
%% \end{note}
\todo{Shinn: I'm not sure we want to say anything about this.}

%% \begin{note}
%% The interactions of \callcc{} with {\cf dynamic-wind} are defined by
%% the formal semantics, but are hard to understand in complex cases.  In
%% addition, in some implementations \callcc{} consumes an amount of
%% memory that depends on the number of active continuations.
%% \end{note}
\end{entry}

\begin{entry}{%
\proto{values}{ obj $\ldots$}{procedure}}

引数をすべて継続に渡します。
{\tt values}手続きは以下のように定義することが出来ます。
\begin{scheme}
(define (values . things)
  (call-with-current-continuation 
    (lambda (cont) (apply cont things))))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{call-with-values}{ producer consumer}{procedure}}

\var{producer}が引数無しで呼ばれます。
ただし、その\var{producer}の呼び出し元の継続に値が渡されると、
その値を引数として\var{consumer}手続きが呼ばれます。
その\var{consumer}の呼び出し元の継続は
{\tt call-with-values}の呼び出し元の継続です。

\begin{scheme}
(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
                                                   \ev  5

(call-with-values * -)                             \ev  -1%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{dynamic-wind}{ before thunk after}{procedure}}

\var{thunk}が引数無しで呼ばれ、その呼び出しの結果を返します。
\var{before}および\var{after}も以下の規則に従って引数無しで呼ばれます。
ちなみに、
\ide{call-with-current-continuation}を用いて捕捉された継続への呼び出しが無ければ、
3つの引数は順番にそれぞれ一度だけ呼ばれます。
\var{thunk}の呼び出しの動的存続期間に入るときは必ず\var{before}が呼ばれ、
その動的存続期間を出るときは必ず\var{after}が呼ばれます。
手続き呼び出しの動的存続期間とは、その呼び出しが開始されてから戻るまでの間の期間です。
\var{before}サンクおよび\var{after}サンクは
{\cf dynamic-wind}の呼び出し元と同じ動的環境で呼ばれます。
Schemeには{\cf call-with-current-continuation}が存在するため、
呼び出しの動的存続期間は連続した単一の時間でない場合があります。
これは以下のように定義されます。
\begin{itemize}
\item 呼ばれた手続きの本体の実行が開始されるとき、その動的存続期間に入ります。

\item 動的存続期間中に({\cf call-with-current-continuation}を用いて)
捕捉された継続をその動的存続期間外で呼んだときも、
その動的存続期間に入ります。

\item 呼ばれた手続きから戻るとき、その動的存続期間から抜けます。

\item 動的存続期間外で捕捉された継続をその動的存続期間中に呼んだときも、
その動的存続期間から抜けます。
\end{itemize}

\var{thunk}の呼び出しの動的存続期間中に
2回目の{\cf dynamic-wind}の呼び出しが発生し、
何らかの継続が呼び出されてこれら2回の{\cf dynamic-wind}呼び出しの\var{after}を
両方とも呼ぶべき状況になった場合は、
2回目の(内側の){\cf dynamic-wind}呼び出しに関連付けられている\var{after}が
先に呼ばれます。

\var{thunk}の呼び出しの動的存続期間中に
2回目の{\cf dynamic-wind}の呼び出しが発生し、
何らかの継続が呼び出されてこれら2回の{\cf dynamic-wind}呼び出しの\var{before}を
両方とも呼ぶべき状況になった場合は、
1回目の(外側の){\cf dynamic-wind}呼び出しに関連付けられている\var{before}が
先に呼ばれます。

何らかの継続が呼び出されることにより、
ある{\cf dynamic-wind}呼び出しの\var{before}と
別の{\cf dynamic-wind}呼び出しの\var{after}を呼ぶ必要が生じた場合、
\var{after}の方が先に呼ばれます。

\todo{consider removing unspecified effect}
捕捉した継続を用いて
\var{before}や\var{after}の呼び出しの動的存続期間を出入りした場合の効果は
規定されていません。

\begin{scheme}
(let ((path '())
      (c \#f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call-with-current-continuation
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
    \lev (connect talk1 disconnect
               connect talk2 disconnect)%
\end{scheme}
\end{entry}

\section{例外}
\label{exceptionsection}

この節ではSchemeの例外処理および例外発生手続きについて述べます。
Schemeの例外の概念については\ref{errorsituations}~節を参照してください。
{\cf guard}構文については\ref{guard}も参照してください。

例外的な状況が通知されたときにプログラムが取るアクションを決める
手続きを\defining{例外ハンドラ}と呼びます。
例外ハンドラは引数をひとつ取ります。
システムは現在の例外ハンドラを動的環境で暗黙的に管理しています。

\index{current exception handler}
例外が発生すると、現在の例外ハンドラが呼ばれ、
その例外に関する情報をカプセル化したオブジェクトが渡されます。
引数をひとつ取る手続きなら何でも例外ハンドラとして用いることが出来ます。
また、どんなオブジェクトでも例外を表すために用いることが出来ます。

\begin{entry}{%
\proto{with-exception-handler}{ \var{handler} \var{thunk}}{procedure}}

\domain{\var{handler}が引数をひとつ取らない場合はエラーです。
また\var{thunk}がゼロ個の引数を取らない場合もエラーです。}
{\cf with-exception-handler}手続きは\var{thunk}を呼び、その結果を返します。
\var{thunk}の呼び出しに対して使われる動的環境に
現在の例外ハンドラとして\var{handler}をインストールします。

\begin{scheme}
(call-with-current-continuation
 (lambda (k)
  (with-exception-handler
   (lambda (x)
    (display "condition: ")
    (write x)
    (newline)
    (k 'exception))
   (lambda ()
    (+ 1 (raise 'an-error))))))
        \ev exception
 \>{\em and prints}  condition: an-error

(with-exception-handler
 (lambda (x)
  (display "something went wrong\backwhack{}n"))
 (lambda ()
  (+ 1 (raise 'an-error))))
 \>{\em prints}  something went wrong%
\end{scheme}

2番目の例では、出力の後、別の例外が発生します。
\end{entry}

\begin{entry}{%
\proto{raise}{ \var{obj}}{procedure}}

例外を発生させ、\var{obj}に対して現在の例外ハンドラを呼び出します。
ハンドラは{\cf raise}の呼び出し元と同じ動的環境で呼ばれます。
ただし、現在の例外ハンドラは、呼ばれるハンドラがインストールされたときのものになります。
ハンドラから戻った場合、そのハンドラと同じ動的環境で第二の例外が発生します。
\var{obj}とその第二の例外の関係は規定されていません。
\end{entry}

\begin{entry}{%
\proto{raise-continuable}{ \var{obj}}{procedure}}

例外を発生させ、\var{obj}に対して現在の例外ハンドラを呼び出します。
ハンドラは{\cf raise-continuable}の呼び出し元と同じ動的環境で呼ばれます。
ただし、
(1)現在の例外ハンドラは、呼ばれるハンドラがインストールされたときのものになり、
(2)呼ばれたハンドラから戻った場合、それが再び現在の例外ハンドラになります。
ハンドラから戻った場合、その戻り値が{\cf raise-continuable}の戻り値になります。
\end{entry}

\begin{scheme}
(with-exception-handler
  (lambda (con)
    (cond
      ((string? con)
       (display con))
      (else
       (display "a warning has been issued")))
    42)
  (lambda ()
    (+ (raise-continuable "should be a number")
       23)))
   {\it prints:} should be a number
   \ev 65%
\end{scheme}

\begin{entry}{%
\proto{error}{ \var{message} \var{obj} $\ldots$}{procedure}}

\domain{\var{message}は文字列であるべきです。}
\var{message}および\defining{刺激物}として知られる\var{obj}
によって与えられた情報をカプセル化した
処理系定義の新しく割り当てられたオブジェクトに対して、
{\cf raise}を呼んだかのように例外を発生させます。
そのオブジェクトに対して手続き{\cf error-object?}を呼ぶと
\schtrue{}を返さなければなりません。

\begin{scheme}
(define (null-list? l)
  (cond ((pair? l) \#f)
        ((null? l) \#t)
        (else
          (error
            "null-list?: argument out of domain"
            l))))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{error-object?}{ obj}{procedure}}

\var{obj}が{\cf error}によって作成されたオブジェクトであれば\schtrue{}を返します。
何らかの処理系定義のオブジェクトに対して\schtrue{}を返す場合もあります。
そうでなければ\schfalse{}を返します。
エラーを通知するオブジェクトは、
述語{\cf file-error?}や{\cf read-error?}を満たすものも含め、
{\cf error-object?}を満たす場合も満たさない場合もあります。

\end{entry}

\begin{entry}{%
\proto{error-object-message}{ error-object}{procedure}}

\var{error-object}にカプセル化されているメッセージを返します。

\end{entry}

\begin{entry}{%
\proto{error-object-irritants}{ error-object}{procedure}}

\var{error-object}にカプセル化されている刺激物のリストを返します。

\end{entry}

\begin{entry}{%
\proto{read-error?}{ obj}{procedure}
\proto{file-error?}{ obj}{procedure}}

エラー型の述語です。
それぞれ、\var{obj}が{\cf read}手続きによって発生した場合、
またはファイルの入出力ポートを開けなかったことによって発生した場合に、
\schtrue{}を返します。
そうでなければ\schfalse{}を返します。
% Not required to be an error object.

\end{entry}

\section{環境と評価}

\begin{entry}{%
\proto{environment}{ \vri{list} \dotsfoo}{eval library procedure}}
\label{environments}

この手続きは、空の環境を用意し、
そこに各\var{list}をインポートセットとみなしてインポートし、
その結果の環境の指定子を返します。
(インポートセットの説明は\ref{libraries}~節を参照。)
この指定子によって表された環境の束縛は、環境自身と同様に、不変です。

\end{entry}

\begin{entry}{%
\proto{scheme-report-environment}{ version}{r5rs library procedure}}

\var{version}が{\cf 5} (\rfivers に対応する) と等しければ、
\rfivers ライブラリで定義されている束縛のみを持つ環境の指定子を返します。
処理系はこの値の\var{version}をサポートしなければなりません。

処理系は他の値の\var{version}をサポートしても構いません。
その場合は指定された版の報告書に対応する束縛を持つ環境の指定子を返します。
\var{version}が{\cf 5}でなく、処理系がサポートしている他の値でもない場合は、
エラーが通知されます。

\todo{consider removing unspecified effect}
{\cf scheme-report-environment}内で束縛されている識別子(例えば{\cf car})を
({\cf eval}の使用を通して)定義または代入した場合の効果は規定されていません。
すなわち環境と、そこに含まれる束縛は、両方とも不変である場合があります。

\end{entry}

\begin{entry}{%
\proto{null-environment}{ version}{r5rs library procedure}}

\var{version}が{\cf 5} (\rfivers に対応する) と等しければ、
\rfivers ライブラリで定義されているすべての構文キーワードの束縛のみを持つ
環境の指定子を返します。
処理系はこの値の\var{version}をサポートしなければなりません。

処理系は他の値の\var{version}をサポートしても構いません。
その場合は指定された版の報告書に対応する適切な束縛を持つ環境の指定子を返します。
\var{version}が{\cf 5}でなく、処理系がサポートしている他の値でもない場合は、
エラーが通知されます。

{\cf scheme-report-environment}内で束縛されている識別子(例えば{\cf car})を
({\cf eval}の使用を通して)定義または代入した場合の効果は規定されていません。
すなわち環境と、そこに含まれる束縛は、両方とも不変であっても構いません。

\end{entry}

\begin{entry}{%
\proto{interaction-environment}{}{repl library procedure}}

この手続きは処理系定義の束縛の集合、
一般的には{\cf(scheme base)}からエクスポートされているもののスーパーセットを持つ
変更可能な環境の指定子を返します。
この手続きはユーザーがREPLに入力した式を評価する環境を返すことを意図しています。

\end{entry}

\begin{entry}{%
\proto{eval}{ expr-or-def environment-specifier}{eval library procedure}}

\var{expr-or-def}が式の場合、指定された環境でそれが評価され、その値が返されます。
定義の場合、指定された識別子が指定された環境で定義されます。
ただしその環境が不変でない場合に限ります。
処理系は{\cf eval}を拡張して他のオブジェクトを受け付けても構いません。

\begin{scheme}
(eval '(* 7 3) (environment '(scheme base)))
                                                   \ev  21

(let ((f (eval '(lambda (f x) (f x x))
               (null-environment 5))))
  (f + 10))
                                                   \ev  20
(eval '(define foo 32)
      (environment '(scheme base)))
                                                   \ev {\it{} error is signaled}%
\end{scheme}

\end{entry}

\section{Input and output}

\subsection{Ports}
\label{portsection}

Ports represent input and output devices.  To Scheme, an input port is
a Scheme object that can deliver data upon command, while an output
port is a Scheme object that can accept data.\mainindex{port}
Whether the input and output port types are disjoint is
implementation-dependent.

Different {\em port types} operate on different data.  Scheme
imple\-men\-ta\-tions are required to support {\em textual ports}
and {\em binary ports}, but may also provide other port types.

A textual port supports reading or writing of individual characters
from or to a backing store containing characters
using {\cf read-char} and {\cf write-char} below, and it supports operations
defined in terms of characters, such as {\cf read} and {\cf write}.

A binary port supports reading or writing of individual bytes from
or to a backing store containing bytes using {\cf read-u8} and {\cf
write-u8} below, as well as operations defined in terms of bytes.
Whether the textual and binary port types are disjoint is
implementation-dependent.

Ports can be used to access files, devices, and similar things on the host
system on which the Scheme program is running.

\begin{entry}{%
\proto{call-with-port}{ port proc}{procedure}}

\domain{It is an error if \var{proc} does not accept one argument.}
The {\cf call-with-port}
procedure calls \var{proc} with \var{port} as an argument.  
If \var{proc} returns,
then the port is closed automatically and the values yielded by the
\var{proc} are returned.  If \var{proc} does not return, then 
the port must not be closed automatically unless it is possible to
prove that the port will never again be used for a read or write
operation.

\begin{rationale}
Because Scheme's escape procedures have unlimited extent, it  is
possible to escape from the current continuation but later to resume it. 
If implementations were permitted to close the port on any escape from the
current continuation, then it would be impossible to write portable code using
both {\cf call-with-current-continuation} and {\cf call-with-port}.
\end{rationale} 

\end{entry}

\begin{entry}{%
\proto{call-with-input-file}{ string proc}{file library procedure}
\proto{call-with-output-file}{ string proc}{file library procedure}}

\domain{It is an error if \var{proc} does not accept one argument.}
These procedures obtain a
textual port obtained by opening the named file for input or output
as if by {\cf open-input-file} or {\cf open-output-file}.  
The port and \var{proc} are then passed to a procedure equivalent
to {\cf call-with-port}.
\end{entry}

\begin{entry}{%
\proto{input-port?}{ obj}{procedure}
\proto{output-port?}{ obj}{procedure}
\proto{textual-port?}{ obj}{procedure}
\proto{binary-port?}{ obj}{procedure}
\proto{port?}{ obj}{procedure}}

These procedures return \schtrue{} if \var{obj} is an input port, output port, 
textual port, binary port, or any
kind of port, respectively.  Otherwise they return \schfalse.

\end{entry}


\begin{entry}{%
\proto{input-port-open?}{ port}{procedure}
\proto{output-port-open?}{ port}{procedure}}

Returns \schtrue{} if \var{port} is still open and capable of
performing input or output, respectively, and \schfalse{} otherwise.


\end{entry}


\begin{entry}{%
\proto{current-input-port}{}{procedure}
\proto{current-output-port}{}{procedure}
\proto{current-error-port}{}{procedure}}

Returns the current default input port, output port, or error port (an
output port), respectively.  These procedures are parameter objects, which can be
overridden with {\cf parameterize} (see
section~\ref{make-parameter}).  The initial bindings for these
are implementation-defined textual ports.

\end{entry}


\begin{entry}{%
\proto{with-input-from-file}{ string thunk}{file library procedure}
\proto{with-output-to-file}{ string thunk}{file library procedure}}

The file is opened for input or output
as if by {\cf open-input-file} or {\cf open-output-file}, 
and the new port is made to be the value returned by
{\cf current-input-port} or {\cf current-output-port}
(as used by {\tt (read)}, {\tt (write \var{obj})}, and so forth).
The \var{thunk} is then called with no arguments.  When the \var{thunk} returns,
the port is closed and the previous default is restored.
It is an error if \var{thunk} does not accept zero arguments.
Both procedures return the values yielded by \var{thunk}.
If an escape procedure
is used to escape from the continuation of these procedures, they
behave exactly as if the current input or output port had been bound
dynamically with {\cf parameterize}.


\end{entry}


\begin{entry}{%
\proto{open-input-file}{ string}{file library procedure}
\proto{open-binary-input-file}{ string}{file library procedure}}
 
Takes a \var{string} for an existing file and returns a textual
input port or binary input port that is capable of delivering data from the
file.  If the file does not exist or cannot be opened, an error that satisfies {\cf file-error?} is signaled.

\end{entry}


\begin{entry}{%
\proto{open-output-file}{ string}{file library procedure}
\proto{open-binary-output-file}{ string}{file library procedure}}

Takes a \var{string} naming an output file to be created and returns a
textual output port or binary output port that is capable of writing
data to a new file by that name.
\todo{consider removing unspecified effect}
If a file with the given name already exists,
the effect is unspecified.
If the file cannot be opened,
an error that satisfies {\cf file-error?} is signaled.

\end{entry}


\begin{entry}{%
\proto{close-port}{ port}{procedure}
\proto{close-input-port}{ port}{procedure}
\proto{close-output-port}{ port}{procedure}}

Closes the resource associated with \var{port}, rendering the \var{port}
incapable of delivering or accepting data.  
It is an error
to apply the last two procedures to a port which is not an input
or output port, respectively.
Scheme implementations may provide ports which are simultaneously
input and output ports, such as sockets; the {\cf close-input-port}
and {\cf close-output-port} procedures can then be used to close the
input and output sides of the port independently.

These routines have no effect if the port has already been closed.


\end{entry}

\begin{entry}{%
\proto{open-input-string}{ string}{procedure}}

Takes a string and returns a textual input port that delivers
characters from the string.
If the string is modified, the effect is unspecified.

\end{entry}

\begin{entry}{%
\proto{open-output-string}{}{procedure}}

Returns a textual output port that will accumulate characters for
retrieval by {\cf get-output-string}.

\end{entry}

\begin{entry}{%
\proto{get-output-string}{ port}{procedure}}

\domain{It is an error if \var{port} was not created with
{\cf open-output-string}.}
Returns a string consisting of the
characters that have been output to the port so far in the order they
were output.
If the result string is modified, the effect is unspecified.

\begin{scheme}
(parameterize
    ((current-output-port
      (open-output-string)))
    (display "piece")
    (display " by piece ")
    (display "by piece.")
    (newline)
    (get-output-string (current-output-port)))
\lev "piece by piece by piece.\backwhack{}n"%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{open-input-bytevector}{ bytevector}{procedure}}

Takes a bytevector and returns a binary input port that delivers
bytes from the bytevector.

\end{entry}

\begin{entry}{%
\proto{open-output-bytevector}{}{procedure}}

Returns a binary output port that will accumulate bytes for
retrieval by {\cf get-output-bytevector}.

\end{entry}

\begin{entry}{%
\proto{get-output-bytevector}{ port}{procedure}}

\domain{It is an error if \var{port} was not created with
{\cf open-output-bytevector}.}  Returns a bytevector consisting
of the bytes that have been output to the port so far in the
order they were output.
\end{entry}


\subsection{Input}
\label{inputsection}

If \var{port} is omitted from any input procedure, it defaults to the
value returned by {\cf (current-input-port)}.
It is an error to attempt an input operation on a closed port.

\noindent \hbox{ }  %???
\vspace{-5ex}


\begin{entry}{%
\proto{read}{}{read library procedure}
\rproto{read}{ port}{read library procedure}}

The {\cf read} procedure converts external representations of Scheme objects into the
objects themselves.  That is, it is a parser for the non-terminal
\meta{datum} (see sections~\ref{datum} and
\ref{listsection}).  It returns the next
object parsable from the given textual input \var{port}, updating
\var{port} to point to
the first character past the end of the external representation of the object.

Implementations may support extended syntax to represent record types or
other types that do not have datum representations.

\vest If an end of file is encountered in the input before any
characters are found that can begin an object, then an end-of-file
object is returned.  The port remains open, and further attempts
to read will also return an end-of-file object.  If an end of file is
encountered after the beginning of an object's external representation,
but the external representation is incomplete and therefore not parsable,
an error that satisfies {\cf read-error?} is signaled.

\end{entry}

\begin{entry}{%
\proto{read-char}{}{procedure}
\rproto{read-char}{ port}{procedure}}

Returns the next character available from the textual input \var{port},
updating
the \var{port} to point to the following character.  If no more characters
are available, an end-of-file object is returned.  

\end{entry}


\begin{entry}{%
\proto{peek-char}{}{procedure}
\rproto{peek-char}{ port}{procedure}}

Returns the next character available from the textual input \var{port},
but {\em without} updating
the \var{port} to point to the following character.  If no more characters
are available, an end-of-file object is returned.  

\begin{note}
The value returned by a call to {\cf peek-char} is the same as the
value that would have been returned by a call to {\cf read-char} with the
same \var{port}.  The only difference is that the very next call to
{\cf read-char} or {\cf peek-char} on that \var{port} will return the
value returned by the preceding call to {\cf peek-char}.  In particular, a call
to {\cf peek-char} on an interactive port will hang waiting for input
whenever a call to {\cf read-char} would have hung.
\end{note}

\end{entry}

\begin{entry}{%
\proto{read-line}{}{procedure}
\rproto{read-line}{ port}{procedure}}

Returns the next line of text available from the textual input
\var{port}, updating the \var{port} to point to the following character.
If an end of line is read, a string containing all of the text up to
(but not including) the end of line is returned, and the port is updated
to point just past the end of line. If an end of file is encountered
before any end of line is read, but some characters have been
read, a string containing those characters is returned. If an end of
file is encountered before any characters are read, an end-of-file
object is returned.  For the purpose of this procedure, an end of line
consists of either a linefeed character, a carriage return character, or a
sequence of a carriage return character followed by a linefeed character.
Implementations may also recognize other end of line characters or sequences.

\end{entry}


\begin{entry}{%
\proto{eof-object?}{ obj}{procedure}}

Returns \schtrue{} if \var{obj} is an end-of-file object, otherwise returns
\schfalse.  The precise set of end-of-file objects will vary among
implementations, but in any case no end-of-file object will ever be an object
that can be read in using {\cf read}.

\end{entry}

\begin{entry}{%
\proto{eof-object}{}{procedure}}

Returns an end-of-file object, not necessarily unique.

\end{entry}


\begin{entry}{%
\proto{char-ready?}{}{procedure}
\rproto{char-ready?}{ port}{procedure}}

Returns \schtrue{} if a character is ready on the textual input \var{port} and
returns \schfalse{} otherwise.  If {\cf char-ready} returns \schtrue{} then
the next {\cf read-char} operation on the given \var{port} is guaranteed
not to hang.  If the \var{port} is at end of file then {\cf char-ready?}\
returns \schtrue.  

\begin{rationale}
The {\cf char-ready?} procedure exists to make it possible for a program to
accept characters from interactive ports without getting stuck waiting for
input.  Any input editors associated with such ports must ensure that
characters whose existence has been asserted by {\cf char-ready?}\ cannot
be removed from the input.  If {\cf char-ready?}\ were to return \schfalse{} at end of
file, a port at end of file would be indistinguishable from an interactive
port that has no ready characters.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{read-string}{ k}{procedure}
\rproto{read-string}{ k port}{procedure}}
\label{readstring}

Reads the next \var{k} characters, or as many as are available before the end of file,
from the textual
input \var{port} into a newly allocated string in left-to-right order
and returns the string.
If no characters are available before the end of file,
an end-of-file object is returned.

\end{entry}


\begin{entry}{%
\proto{read-u8}{}{procedure}
\rproto{read-u8}{ port}{procedure}}

Returns the next byte available from the binary input \var{port},
updating the \var{port} to point to the following byte.  
If no more bytes are
available, an end-of-file object is returned.  

\end{entry}

\begin{entry}{%
\proto{peek-u8}{}{procedure}
\rproto{peek-u8}{ port}{procedure}}

Returns the next byte available from the binary input \var{port},
but {\em without} updating the \var{port} to point to the following
byte.  If no more bytes are available, an end-of-file object is returned.  

\end{entry}

\begin{entry}{%
\proto{u8-ready?}{}{procedure}
\rproto{u8-ready?}{ port}{procedure}}

Returns \schtrue{} if a byte is ready on the binary input \var{port}
and returns \schfalse{} otherwise.  If {\cf u8-ready?} returns
\schtrue{} then the next {\cf read-u8} operation on the given
\var{port} is guaranteed not to hang.  If the \var{port} is at end of
file then {\cf u8-ready?}\ returns \schtrue.  

\end{entry}

\begin{entry}{%
\proto{read-bytevector}{ k}{procedure}
\rproto{read-bytevector}{ k port}{procedure}}

Reads the next \var{k} bytes, or as many as are available before the end of file,
from the binary
input \var{port} into a newly allocated bytevector in left-to-right order
and returns the bytevector.
If no bytes are available before the end of file,
an end-of-file object is returned.

\end{entry}

\begin{entry}{%
\proto{read-bytevector!}{ bytevector}{procedure}
\rproto{read-bytevector!}{ bytevector port}{procedure}
\rproto{read-bytevector!}{ bytevector port start}{procedure}
\rproto{read-bytevector!}{ bytevector port start end}{procedure}}

Reads the next $end - start$ bytes, or as many as are available
before the end of file,
from the binary
input \var{port} into \var{bytevector} in left-to-right order
beginning at the \var{start} position.  If \var{end} is not supplied,
reads until the end of \var{bytevector} has been reached.  If
\var{start} is not supplied, reads beginning at position 0.
Returns the number of bytes read.
If no bytes are available, an end-of-file object is returned.

\end{entry}


\subsection{Output}
\label{outputsection}

If \var{port} is omitted from any output procedure, it defaults to the
value returned by {\cf (current-output-port)}.
It is an error to attempt an output operation on a closed port.

\noindent \hbox{}
\vspace{-5ex}

\begin{entry}{%
\proto{write}{ obj}{write library procedure}
\rproto{write}{ obj port}{write library procedure}}

Writes a representation of \var{obj} to the given textual output
\var{port}.  Strings
that appear in the written representation are enclosed in quotation marks, and
within those strings backslash and quotation mark characters are
escaped by backslashes.  Symbols that contain non-ASCII characters
are escaped with vertical lines.
Character objects are written using the {\cf \#\backwhack} notation.

If \var{obj} contains cycles which would cause an infinite loop using
the normal written representation, then at least the objects that form
part of the cycle must be represented using datum labels as described
in section~\ref{labelsection}.  Datum labels must not be used if there
are no cycles.

Implementations may support extended syntax to represent record types or
other types that do not have datum representations.

The {\cf write} procedure returns an unspecified value.

\end{entry}

\begin{entry}{%
\proto{write-shared}{ obj}{write library procedure}
\rproto{write-shared}{ obj port}{write library procedure}}

The {\cf write-shared} procedure is the same as {\cf write}, except that
shared structure must be represented using datum labels for all pairs
and vectors that appear more than once in the output.

\end{entry}

\begin{entry}{%
\proto{write-simple}{ obj}{write library procedure}
\rproto{write-simple}{ obj port}{write library procedure}}

The {\cf write-simple} procedure is the same as {\cf write}, except that shared structure is
never represented using datum labels.  This can cause {\cf write-simple} not to
terminate if \var{obj} contains circular structure.

\end{entry}


\begin{entry}{%
\proto{display}{ obj}{write library procedure}
\rproto{display}{ obj port}{write library procedure}}

Writes a representation of \var{obj} to the given textual output \var{port}.
Strings that appear in the written representation are output as if by
{\cf write-string} instead of by {\cf write}.
Symbols are not escaped.  Character
objects appear in the representation as if written by {\cf write-char}
instead of by {\cf write}.

The {\cf display} representation of other objects is unspecified.
However, {\cf display} must not loop forever on 
self-referencing pairs, vectors, or records.  Thus if the
normal {\cf write} representation is used, datum labels are needed
to represent cycles as in {\cf write}.

Implementations may support extended syntax to represent record types or
other types that do not have datum representations.

The {\cf display} procedure returns an unspecified value.

\begin{rationale}
The {\cf write} procedure is intended
for producing mach\-ine-readable output and {\cf display} for producing
human-readable output.  
\end{rationale}
\end{entry}


\begin{entry}{%
\proto{newline}{}{procedure}
\rproto{newline}{ port}{procedure}}

Writes an end of line to textual output \var{port}.  Exactly how this
is done differs
from one operating system to another.  Returns an unspecified value.

\end{entry}


\begin{entry}{%
\proto{write-char}{ char}{procedure}
\rproto{write-char}{ char port}{procedure}}

Writes the character \var{char} (not an external representation of the
character) to the given textual output \var{port} and returns an unspecified
value.  

\end{entry}

\begin{entry}{%
\proto{write-string}{ string}{procedure}
\rproto{write-string}{ string port}{procedure}
\rproto{write-string}{ string port start}{procedure}
\rproto{write-string}{ string port start end}{procedure}}

Writes the characters of \var{string}
from \var{start} to \var{end}
in left-to-right order to the
textual output \var{port}.

\end{entry}

\begin{entry}{%
\proto{write-u8}{ byte}{procedure}
\rproto{write-u8}{ byte port}{procedure}}

Writes the \var{byte} to
the given binary output \var{port} and returns an unspecified value.

\end{entry}

\begin{entry}{%
\proto{write-bytevector}{ bytevector}{procedure}
\rproto{write-bytevector}{ bytevector port}{procedure}
\rproto{write-bytevector}{ bytevector port start}{procedure}
\rproto{write-bytevector}{ bytevector port start end}{procedure}}

Writes the bytes of \var{bytevector}
from \var{start} to \var{end}
in left-to-right order to the
binary output \var{port}.

\end{entry}

\begin{entry}{%
\proto{flush-output-port}{}{procedure}
\rproto{flush-output-port}{ port}{procedure}}

Flushes any buffered output from the buffer of output-port to the
underlying file or device and returns an unspecified value.

\end{entry}


\section{System interface}

Questions of system interface generally fall outside of the domain of this
report.  However, the following operations are important enough to
deserve description here.


\begin{entry}{%
\proto{load}{ filename}{load library procedure}
\rproto{load}{ filename environment-specifier}{load library procedure}}

\domain{It is an error if \var{filename} is not a string.}
An implementation-dependent operation is used to transform
\var{filename} into the name of an existing file
containing Scheme source code.  The {\cf load} procedure reads
expressions and definitions from the file and evaluates them
sequentially in the environment specified by \var{environment-specifier}.
If \var{environment-specifier} is omitted, {\cf (interaction-environment)}
is assumed.

It is unspecified whether the results of the expressions
are printed.  The {\cf load} procedure does not affect the values
returned by {\cf current-input-port} and {\cf current-output-port}.
It returns an unspecified value.


\begin{rationale}
For portability, {\cf load} must operate on source files.
Its operation on other kinds of files necessarily varies among
implementations.
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{file-exists?}{ filename}{file library procedure}}

\domain{It is an error if \var{filename} is not a string.}
The {\cf file-exists?} procedure returns
\schtrue{} if the named file exists at the time the procedure is called,
and \schfalse{} otherwise.

\end{entry}

\begin{entry}{%
\proto{delete-file}{ filename}{file library procedure}}

\domain{It is an error if \var{filename} is not a string.}
The {\cf delete-file} procedure deletes the
named file if it exists and can be deleted, and returns an unspecified
value.  If the file does not exist or cannot be deleted, an error
that satisfies {\cf file-error?} is signaled.

\end{entry}

\begin{entry}{%
\proto{command-line}{}{process-context library procedure}}

Returns the command line passed to the process as a list of
strings.  The first string corresponds to the command name, and is
implementation-dependent.  It is an error to mutate any of these strings.
\end{entry}

\begin{entry}{%
\proto{exit}{}{process-context library procedure}
\rproto{exit}{ obj}{process-context library procedure}}

Runs all outstanding dynamic-wind \var{after} procedures, terminates the
running program, and communicates an exit value to the operating system.
If no argument is supplied, or if \var{obj} is \schtrue{}, the {\cf
exit} procedure should communicate to the operating system that the
program exited normally.  If \var{obj} is \schfalse{}, the {\cf exit}
procedure should communicate to the operating system that the program
exited abnormally.  Otherwise, {\cf exit} should translate \var{obj} into
an appropriate exit value for the operating system, if possible.

The {\cf exit} procedure
must not signal an exception or return to its continuation.

\begin{note}
Because of the requirement to run handlers, this procedure is not just the
operating system's exit procedure.
\end{note}

\end{entry}

\begin{entry}{%
\proto{emergency-exit}{}{process-context library procedure}
\rproto{emergency-exit}{ obj}{process-context library procedure}}

Terminates the program without running any
outstanding dynamic-wind \var{after} procedures
and communicates an exit value to the operating system
in the same manner as {\cf exit}.

\begin{note}
The {\cf emergency-exit} procedure corresponds to the {\cf \_exit} procedure
in Windows and Posix.
\end{note}

\end{entry}


\todo{Shinn: Do we need any description of what an environment variable is?}

\begin{entry}{%
\proto{get-environment-variable}{ name}{process-context library procedure}}

Many operating systems provide each running process with an
\defining{environment} consisting of \defining{environment variables}.
(This environment is not to be confused with the Scheme environments that
can be passed to {\cf eval}: see section~\ref{environments}.)
Both the name and value of an environment variable are strings.
The procedure {\cf get-environment-variable} returns the value 
of the environment variable \var{name},
or \schfalse{} if the named
environment variable is not found.  It may
use locale information to encode the name and decode the value
of the environment variable.  It is an error if \\
{\cf get-environment-variable} can't decode the value.
It is also an error to mutate the resulting string.

\begin{scheme}
(get-environment-variable "PATH") \lev "/usr/local/bin:/usr/bin:/bin"%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{get-environment-variables}{}{process-context library procedure}}

Returns the names and values of all the environment variables as an
alist, where the car of each entry is the name of an environment
variable and the cdr is its value, both as strings.  The order of the list is unspecified.
It is an error to mutate any of these strings or the alist itself.

\begin{scheme}
(get-environment-variables) \lev (("USER" . "root") ("HOME" . "/"))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{current-second}{}{time library procedure}}

Returns an inexact number representing the current time on the International Atomic
Time (TAI) scale.  The value 0.0 represents midnight
on January 1, 1970 TAI (equivalent to ten seconds before midnight Universal Time)
and the value 1.0 represents one TAI
second later.  Neither high accuracy nor high precision are required; in particular,
returning Coordinated Universal Time plus a suitable constant might be
the best an implementation can do.
\end{entry}

\begin{entry}{%
\proto{current-jiffy}{}{time library procedure}}

Returns the number of \defining{jiffies} as an exact integer that have elapsed since an arbitrary,
implementation-defined epoch. A jiffy is an implementation-defined
fraction of a second which is defined by the return value of the
{\cf jiffies-per-second} procedure. The starting epoch is guaranteed to be
constant during a run of the program, but may vary between runs.

\begin{rationale}
Jiffies are allowed to be implementation-dependent so that
{\cf current-jiffy} can execute with minimum overhead. It
should be very likely that a compactly represented integer will suffice
as the returned value.  Any particular jiffy size will be inappropriate
for some implementations: a microsecond is too long for a very fast
machine, while a much smaller unit would force many implementations to
return integers which have to be allocated for most calls, rendering 
{\cf current-jiffy} less useful for accurate timing measurements.
\end{rationale}

\end{entry}

\begin{entry}{%
\proto{jiffies-per-second}{}{time library procedure}}

Returns an exact integer representing the number of jiffies per SI
second. This value is an implementation-specified constant.

\begin{scheme}
(define (time-length)
  (let ((list (make-list 100000))
        (start (current-jiffy)))
    (length list)
    (/ (- (current-jiffy) start)
       (jiffies-per-second))))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{features}{}{procedure}}

Returns a list of the feature identifiers which {\cf cond-expand}
treats as true.  It is an error to modify this list.  Here is an
example of what {\cf features} might return:

\begin{scheme}
(features) \ev
  (r7rs ratios exact-complex full-unicode
   gnu-linux little-endian 
   fantastic-scheme
   fantastic-scheme-1.0
   space-ship-control-system)%
\end{scheme}
\end{entry}

